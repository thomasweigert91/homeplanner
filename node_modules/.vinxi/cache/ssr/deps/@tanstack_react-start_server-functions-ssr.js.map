{
  "version": 3,
  "sources": ["browser-external:node:stream/web", "browser-external:node:stream", "browser-external:node:async_hooks", "../../../../@tanstack/start-server-functions-fetcher/src/index.ts", "../../../../@tanstack/start-server-core/src/transformStreamWithRouter.ts", "../../../../ufo/dist/index.mjs", "../../../../ohash/dist/shared/ohash.BvSMZzli.mjs", "../../../../destr/dist/index.mjs", "../../../../defu/dist/defu.mjs", "../../../../uncrypto/dist/crypto.web.mjs", "../../../../iron-webcrypto/dist/index.js", "../../../../unenv/runtime/_internal/utils.mjs", "../../../../unenv/runtime/mock/proxy.mjs", "../../../../unenv/runtime/node/http/_consts.mjs", "../../../../unenv/runtime/node/events/_events.mjs", "../../../../unenv/runtime/node/events/index.mjs", "../../../../unenv/runtime/node/stream/readable.mjs", "../../../../unenv/runtime/node/stream/writable.mjs", "../../../../unenv/runtime/node/stream/duplex.mjs", "../../../../unenv/runtime/node/net/socket.mjs", "../../../../unenv/runtime/node/http/_request.mjs", "../../../../unenv/runtime/node/http/_response.mjs", "../../../../unenv/runtime/node/http/index.mjs", "../../../../h3/dist/index.mjs", "../../../../unctx/dist/index.mjs", "../../../../@tanstack/start-server-core/src/h3.ts", "../../../../@tanstack/start-server-functions-ssr/src/index.ts"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"node:stream/web\" has been externalized for browser compatibility. Cannot access \"node:stream/web.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"node:stream\" has been externalized for browser compatibility. Cannot access \"node:stream.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"node:async_hooks\" has been externalized for browser compatibility. Cannot access \"node:async_hooks.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "import {\n  encode,\n  isNotFound,\n  isPlainObject,\n  isRedirect,\n} from '@tanstack/router-core'\nimport { startSerializer } from '@tanstack/start-client-core'\nimport type { MiddlewareClientFnOptions } from '@tanstack/start-client-core'\n\nexport async function serverFnFetcher(\n  url: string,\n  args: Array<any>,\n  handler: (url: string, requestInit: RequestInit) => Promise<Response>,\n) {\n  const _first = args[0]\n\n  // If createServerFn was used to wrap the fetcher,\n  // We need to handle the arguments differently\n  if (isPlainObject(_first) && _first.method) {\n    const first = _first as MiddlewareClientFnOptions<any, any, any> & {\n      headers: HeadersInit\n    }\n    const type = first.data instanceof FormData ? 'formData' : 'payload'\n\n    // Arrange the headers\n    const headers = new Headers({\n      ...(type === 'payload'\n        ? {\n            'content-type': 'application/json',\n            accept: 'application/json',\n          }\n        : {}),\n      ...(first.headers instanceof Headers\n        ? Object.fromEntries(first.headers.entries())\n        : first.headers),\n    })\n\n    // If the method is GET, we need to move the payload to the query string\n    if (first.method === 'GET') {\n      // If the method is GET, we need to move the payload to the query string\n      const encodedPayload = encode({\n        payload: startSerializer.stringify({\n          data: first.data,\n          context: first.context,\n        }),\n      })\n\n      if (encodedPayload) {\n        if (url.includes('?')) {\n          url += `&${encodedPayload}`\n        } else {\n          url += `?${encodedPayload}`\n        }\n      }\n    }\n\n    if (url.includes('?')) {\n      url += `&createServerFn`\n    } else {\n      url += `?createServerFn`\n    }\n    if (first.response === 'raw') {\n      url += `&raw`\n    }\n\n    const handlerResponse = await handler(url, {\n      method: first.method,\n      headers,\n      signal: first.signal,\n      ...getFetcherRequestOptions(first),\n    })\n\n    const response = await handleResponseErrors(handlerResponse)\n\n    // Check if the response is JSON\n    if (response.headers.get('content-type')?.includes('application/json')) {\n      // Even though the response is JSON, we need to decode it\n      // because the server may have transformed it\n      const json = startSerializer.decode(await response.json())\n\n      // If the response is a redirect or not found, throw it\n      // for the router to handle\n      if (isRedirect(json) || isNotFound(json) || json instanceof Error) {\n        throw json\n      }\n\n      return json\n    }\n\n    // Must be a raw response\n    return response\n  }\n\n  // If not a custom fetcher, it was probably\n  // a `use server` function, so just proxy the arguments\n  // through as a POST request\n  const response = await handleResponseErrors(\n    await handler(url, {\n      method: 'POST',\n      headers: {\n        Accept: 'application/json',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(args),\n    }),\n  )\n\n  // If the response is JSON, return it parsed\n  const contentType = response.headers.get('content-type')\n  if (contentType && contentType.includes('application/json')) {\n    return startSerializer.decode(await response.json())\n  } else {\n    // Otherwise, return the text as a fallback\n    // If the user wants more than this, they can pass a\n    // request instead\n    return response.text()\n  }\n}\n\nfunction getFetcherRequestOptions(\n  opts: MiddlewareClientFnOptions<any, any, any>,\n) {\n  if (opts.method === 'POST') {\n    if (opts.data instanceof FormData) {\n      opts.data.set('__TSR_CONTEXT', startSerializer.stringify(opts.context))\n      return {\n        body: opts.data,\n      }\n    }\n\n    return {\n      body: startSerializer.stringify({\n        data: opts.data ?? null,\n        context: opts.context,\n      }),\n    }\n  }\n\n  return {}\n}\n\nasync function handleResponseErrors(response: Response) {\n  if (!response.ok) {\n    const contentType = response.headers.get('content-type')\n    const isJson = contentType && contentType.includes('application/json')\n\n    if (isJson) {\n      throw startSerializer.decode(await response.json())\n    }\n\n    throw new Error(await response.text())\n  }\n\n  return response\n}\n", "import { ReadableStream } from 'node:stream/web'\nimport { Readable } from 'node:stream'\nimport { createControlledPromise } from '@tanstack/router-core'\nimport type { AnyRouter } from '@tanstack/router-core'\n\nexport function transformReadableStreamWithRouter(\n  router: AnyRouter,\n  routerStream: ReadableStream,\n) {\n  return transformStreamWithRouter(router, routerStream)\n}\n\nexport function transformPipeableStreamWithRouter(\n  router: AnyRouter,\n  routerStream: Readable,\n) {\n  return Readable.fromWeb(\n    transformStreamWithRouter(router, Readable.toWeb(routerStream)),\n  )\n}\n\n// regex pattern for matching closing body and html tags\nconst patternBodyStart = /(<body)/\nconst patternBodyEnd = /(<\\/body>)/\nconst patternHtmlEnd = /(<\\/html>)/\nconst patternHeadStart = /(<head.*?>)/\n// regex pattern for matching closing tags\nconst patternClosingTag = /(<\\/[a-zA-Z][\\w:.-]*?>)/g\n\nconst textDecoder = new TextDecoder()\n\ntype ReadablePassthrough = {\n  stream: ReadableStream\n  write: (chunk: string) => void\n  end: (chunk?: string) => void\n  destroy: (error: unknown) => void\n  destroyed: boolean\n}\n\nfunction createPassthrough() {\n  let controller: ReadableStreamDefaultController<any>\n  const encoder = new TextEncoder()\n  const stream = new ReadableStream({\n    start(c) {\n      controller = c\n    },\n  })\n\n  const res: ReadablePassthrough = {\n    stream,\n    write: (chunk) => {\n      controller.enqueue(encoder.encode(chunk))\n    },\n    end: (chunk) => {\n      if (chunk) {\n        controller.enqueue(encoder.encode(chunk))\n      }\n      controller.close()\n      res.destroyed = true\n    },\n    destroy: (error) => {\n      controller.error(error)\n    },\n    destroyed: false,\n  }\n\n  return res\n}\n\nasync function readStream(\n  stream: ReadableStream,\n  opts: {\n    onData?: (chunk: ReadableStreamReadValueResult<any>) => void\n    onEnd?: () => void\n    onError?: (error: unknown) => void\n  },\n) {\n  try {\n    const reader = stream.getReader()\n    let chunk\n    while (!(chunk = await reader.read()).done) {\n      opts.onData?.(chunk)\n    }\n    opts.onEnd?.()\n  } catch (error) {\n    opts.onError?.(error)\n  }\n}\n\nexport function transformStreamWithRouter(\n  router: AnyRouter,\n  appStream: ReadableStream,\n) {\n  const finalPassThrough = createPassthrough()\n\n  let isAppRendering = true as boolean\n  let routerStreamBuffer = ''\n  let pendingClosingTags = ''\n  let bodyStarted = false as boolean\n  let headStarted = false as boolean\n  let leftover = ''\n  let leftoverHtml = ''\n\n  function getBufferedRouterStream() {\n    const html = routerStreamBuffer\n    routerStreamBuffer = ''\n    return html\n  }\n\n  function decodeChunk(chunk: unknown): string {\n    if (chunk instanceof Uint8Array) {\n      return textDecoder.decode(chunk)\n    }\n    return String(chunk)\n  }\n\n  const injectedHtmlDonePromise = createControlledPromise<void>()\n\n  let processingCount = 0\n\n  // Process any already-injected HTML\n  router.serverSsr!.injectedHtml.forEach((promise) => {\n    handleInjectedHtml(promise)\n  })\n\n  // Listen for any new injected HTML\n  const stopListeningToInjectedHtml = router.subscribe(\n    'onInjectedHtml',\n    (e) => {\n      handleInjectedHtml(e.promise)\n    },\n  )\n\n  function handleInjectedHtml(promise: Promise<string>) {\n    processingCount++\n\n    promise\n      .then((html) => {\n        if (!bodyStarted) {\n          routerStreamBuffer += html\n        } else {\n          finalPassThrough.write(html)\n        }\n      })\n      .catch(injectedHtmlDonePromise.reject)\n      .finally(() => {\n        processingCount--\n\n        if (!isAppRendering && processingCount === 0) {\n          stopListeningToInjectedHtml()\n          injectedHtmlDonePromise.resolve()\n        }\n      })\n  }\n\n  injectedHtmlDonePromise\n    .then(() => {\n      const finalHtml =\n        leftoverHtml + getBufferedRouterStream() + pendingClosingTags\n\n      finalPassThrough.end(finalHtml)\n    })\n    .catch((err) => {\n      console.error('Error reading routerStream:', err)\n      finalPassThrough.destroy(err)\n    })\n\n  // Transform the appStream\n  readStream(appStream, {\n    onData: (chunk) => {\n      const text = decodeChunk(chunk.value)\n\n      let chunkString = leftover + text\n      const bodyEndMatch = chunkString.match(patternBodyEnd)\n      const htmlEndMatch = chunkString.match(patternHtmlEnd)\n\n      if (!bodyStarted) {\n        const bodyStartMatch = chunkString.match(patternBodyStart)\n        if (bodyStartMatch) {\n          bodyStarted = true\n        }\n      }\n\n      if (!headStarted) {\n        const headStartMatch = chunkString.match(patternHeadStart)\n        if (headStartMatch) {\n          headStarted = true\n          const index = headStartMatch.index!\n          const headTag = headStartMatch[0]\n          const remaining = chunkString.slice(index + headTag.length)\n          finalPassThrough.write(\n            chunkString.slice(0, index) + headTag + getBufferedRouterStream(),\n          )\n          // make sure to only write `remaining` until the next closing tag\n          chunkString = remaining\n        }\n      }\n\n      if (!bodyStarted) {\n        finalPassThrough.write(chunkString)\n        leftover = ''\n        return\n      }\n\n      // If either the body end or html end is in the chunk,\n      // We need to get all of our data in asap\n      if (\n        bodyEndMatch &&\n        htmlEndMatch &&\n        bodyEndMatch.index! < htmlEndMatch.index!\n      ) {\n        const bodyEndIndex = bodyEndMatch.index!\n        pendingClosingTags = chunkString.slice(bodyEndIndex)\n\n        finalPassThrough.write(\n          chunkString.slice(0, bodyEndIndex) + getBufferedRouterStream(),\n        )\n\n        leftover = ''\n        return\n      }\n\n      let result: RegExpExecArray | null\n      let lastIndex = 0\n      while ((result = patternClosingTag.exec(chunkString)) !== null) {\n        lastIndex = result.index + result[0].length\n      }\n\n      if (lastIndex > 0) {\n        const processed =\n          chunkString.slice(0, lastIndex) +\n          getBufferedRouterStream() +\n          leftoverHtml\n\n        finalPassThrough.write(processed)\n        leftover = chunkString.slice(lastIndex)\n      } else {\n        leftover = chunkString\n        leftoverHtml += getBufferedRouterStream()\n      }\n    },\n    onEnd: () => {\n      // Mark the app as done rendering\n      isAppRendering = false\n\n      // If there are no pending promises, resolve the injectedHtmlDonePromise\n      if (processingCount === 0) {\n        injectedHtmlDonePromise.resolve()\n      }\n    },\n    onError: (error) => {\n      console.error('Error reading appStream:', error)\n      finalPassThrough.destroy(error)\n    },\n  })\n\n  return finalPassThrough.stream\n}\n", "const n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = {\n  overflow: \"Overflow Error\",\n  \"not-basic\": \"Illegal Input\",\n  \"invalid-input\": \"Invalid Input\"\n};\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_CARET_RE = /%5e/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7b/gi;\nconst ENC_PIPE_RE = /%7c/gi;\nconst ENC_CURLY_CLOSE_RE = /%7d/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2f/gi;\nconst ENC_ENC_SLASH_RE = /%252f/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(input) {\n  return encode(typeof input === \"string\" ? input : JSON.stringify(input)).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CARET_RE, \"^\").replace(SLASH_RE, \"%2F\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryKey(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(parametersString = \"\") {\n  const object = {};\n  if (parametersString[0] === \"?\") {\n    parametersString = parametersString.slice(1);\n  }\n  for (const parameter of parametersString.split(\"&\")) {\n    const s = parameter.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decodeQueryKey(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (object[key] === void 0) {\n      object[key] = value;\n    } else if (Array.isArray(object[key])) {\n      object[key].push(value);\n    } else {\n      object[key] = [object[key], value];\n    }\n  }\n  return object;\n}\nfunction encodeQueryItem(key, value) {\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    value = String(value);\n  }\n  if (!value) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(value)) {\n    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join(\"&\");\n}\n\nconst PROTOCOL_STRICT_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{1,2})/;\nconst PROTOCOL_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{2})?/;\nconst PROTOCOL_RELATIVE_REGEX = /^([/\\\\]\\s*){2,}[^/\\\\]/;\nconst PROTOCOL_SCRIPT_RE = /^[\\s\\0]*(blob|data|javascript|vbscript):$/i;\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?|\\/#/;\nconst JOIN_LEADING_SLASH_RE = /^\\.?\\//;\nfunction isRelative(inputString) {\n  return [\"./\", \"../\"].some((string_) => inputString.startsWith(string_));\n}\nfunction hasProtocol(inputString, opts = {}) {\n  if (typeof opts === \"boolean\") {\n    opts = { acceptRelative: opts };\n  }\n  if (opts.strict) {\n    return PROTOCOL_STRICT_REGEX.test(inputString);\n  }\n  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);\n}\nfunction isScriptProtocol(protocol) {\n  return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);\n}\nfunction hasTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n  }\n  const [s0, ...s] = path.split(\"?\");\n  const cleanPath = s0.endsWith(\"/\") ? s0.slice(0, -1) : s0;\n  return (cleanPath || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction withTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n    if (!path) {\n      return fragment;\n    }\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.slice(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {\n    if (url) {\n      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, \"\");\n      url = withTrailingSlash(url) + _segment;\n    } else {\n      url = segment;\n    }\n  }\n  return url;\n}\nfunction joinRelativeURL(..._input) {\n  const JOIN_SEGMENT_SPLIT_RE = /\\/(?!\\/)/;\n  const input = _input.filter(Boolean);\n  const segments = [];\n  let segmentsDepth = 0;\n  for (const i of input) {\n    if (!i || i === \"/\") {\n      continue;\n    }\n    for (const [sindex, s] of i.split(JOIN_SEGMENT_SPLIT_RE).entries()) {\n      if (!s || s === \".\") {\n        continue;\n      }\n      if (s === \"..\") {\n        if (segments.length === 1 && hasProtocol(segments[0])) {\n          continue;\n        }\n        segments.pop();\n        segmentsDepth--;\n        continue;\n      }\n      if (sindex === 1 && segments[segments.length - 1]?.endsWith(\":/\")) {\n        segments[segments.length - 1] += \"/\" + s;\n        continue;\n      }\n      segments.push(s);\n      segmentsDepth++;\n    }\n  }\n  let url = segments.join(\"/\");\n  if (segmentsDepth >= 0) {\n    if (input[0]?.startsWith(\"/\") && !url.startsWith(\"/\")) {\n      url = \"/\" + url;\n    } else if (input[0]?.startsWith(\"./\") && !url.startsWith(\"./\")) {\n      url = \"./\" + url;\n    }\n  } else {\n    url = \"../\".repeat(-1 * segmentsDepth) + url;\n  }\n  if (input[input.length - 1]?.endsWith(\"/\") && !url.endsWith(\"/\")) {\n    url += \"/\";\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  let match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    match = input.match(/^\\/{2,}/);\n  }\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.slice(match[0].length);\n}\nfunction normalizeURL(input) {\n  const parsed = parseURL(input);\n  parsed.pathname = encodePath(decodePath(parsed.pathname));\n  parsed.hash = encodeHash(decode(parsed.hash));\n  parsed.host = encodeHost(decode(parsed.host));\n  parsed.search = stringifyQuery(parseQuery(parsed.search));\n  return stringifyParsedURL(parsed);\n}\nfunction resolveURL(base = \"\", ...inputs) {\n  if (typeof base !== \"string\") {\n    throw new TypeError(\n      `URL input should be string received ${typeof base} (${base})`\n    );\n  }\n  const filteredInputs = inputs.filter((input) => isNonEmptyURL(input));\n  if (filteredInputs.length === 0) {\n    return base;\n  }\n  const url = parseURL(base);\n  for (const inputSegment of filteredInputs) {\n    const urlSegment = parseURL(inputSegment);\n    if (urlSegment.pathname) {\n      url.pathname = withTrailingSlash(url.pathname) + withoutLeadingSlash(urlSegment.pathname);\n    }\n    if (urlSegment.hash && urlSegment.hash !== \"#\") {\n      url.hash = urlSegment.hash;\n    }\n    if (urlSegment.search && urlSegment.search !== \"?\") {\n      if (url.search && url.search !== \"?\") {\n        const queryString = stringifyQuery({\n          ...parseQuery(url.search),\n          ...parseQuery(urlSegment.search)\n        });\n        url.search = queryString.length > 0 ? \"?\" + queryString : \"\";\n      } else {\n        url.search = urlSegment.search;\n      }\n    }\n  }\n  return stringifyParsedURL(url);\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, options = {}) {\n  if (!options.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!options.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!options.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\nfunction withFragment(input, hash) {\n  if (!hash || hash === \"#\") {\n    return input;\n  }\n  const parsed = parseURL(input);\n  parsed.hash = hash === \"\" ? \"\" : \"#\" + encodeHash(hash);\n  return stringifyParsedURL(parsed);\n}\nfunction withoutFragment(input) {\n  return stringifyParsedURL({ ...parseURL(input), hash: \"\" });\n}\nfunction withoutHost(input) {\n  const parsed = parseURL(input);\n  return (parsed.pathname || \"/\") + parsed.search + parsed.hash;\n}\n\nconst protocolRelative = Symbol.for(\"ufo:protocolRelative\");\nfunction parseURL(input = \"\", defaultProto) {\n  const _specialProtoMatch = input.match(\n    /^[\\s\\0]*(blob:|data:|javascript:|vbscript:)(.*)/i\n  );\n  if (_specialProtoMatch) {\n    const [, _proto, _pathname = \"\"] = _specialProtoMatch;\n    return {\n      protocol: _proto.toLowerCase(),\n      pathname: _pathname,\n      href: _proto + _pathname,\n      auth: \"\",\n      host: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n  }\n  if (!hasProtocol(input, { acceptRelative: true })) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [, protocol = \"\", auth, hostAndPath = \"\"] = input.replace(/\\\\/g, \"/\").match(/^[\\s\\0]*([\\w+.-]{2,}:)?\\/\\/([^/@]+@)?(.*)/) || [];\n  let [, host = \"\", path = \"\"] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];\n  if (protocol === \"file:\") {\n    path = path.replace(/\\/(?=[A-Za-z]:)/, \"\");\n  }\n  const { pathname, search, hash } = parsePath(path);\n  return {\n    protocol: protocol.toLowerCase(),\n    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : \"\",\n    host,\n    pathname,\n    search,\n    hash,\n    [protocolRelative]: !protocol\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/:]*):?(\\d+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const pathname = parsed.pathname || \"\";\n  const search = parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\";\n  const hash = parsed.hash || \"\";\n  const auth = parsed.auth ? parsed.auth + \"@\" : \"\";\n  const host = parsed.host || \"\";\n  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || \"\") + \"//\" : \"\";\n  return proto + auth + host + pathname + search + hash;\n}\nconst FILENAME_STRICT_REGEX = /\\/([^/]+\\.[^/]+)$/;\nconst FILENAME_REGEX = /\\/([^/]+)$/;\nfunction parseFilename(input = \"\", { strict }) {\n  const { pathname } = parseURL(input);\n  const matches = strict ? pathname.match(FILENAME_STRICT_REGEX) : pathname.match(FILENAME_REGEX);\n  return matches ? matches[1] : void 0;\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass $URL {\n  constructor(input = \"\") {\n    __publicField(this, \"protocol\");\n    __publicField(this, \"host\");\n    __publicField(this, \"auth\");\n    __publicField(this, \"pathname\");\n    __publicField(this, \"query\", {});\n    __publicField(this, \"hash\");\n    if (typeof input !== \"string\") {\n      throw new TypeError(\n        `URL input should be string received ${typeof input} (${input})`\n      );\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length > 0 ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        for (const v of value) {\n          p.append(name, v);\n        }\n      } else {\n        p.append(\n          name,\n          typeof value === \"string\" ? value : JSON.stringify(value)\n        );\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\n\nexport { $URL, cleanDoubleSlashes, createURL, decode, decodePath, decodeQueryKey, decodeQueryValue, encode, encodeHash, encodeHost, encodeParam, encodePath, encodeQueryItem, encodeQueryKey, encodeQueryValue, getQuery, hasLeadingSlash, hasProtocol, hasTrailingSlash, isEmptyURL, isEqual, isNonEmptyURL, isRelative, isSamePath, isScriptProtocol, joinRelativeURL, joinURL, normalizeURL, parseAuth, parseFilename, parseHost, parsePath, parseQuery, parseURL, resolveURL, stringifyParsedURL, stringifyQuery, withBase, withFragment, withHttp, withHttps, withLeadingSlash, withProtocol, withQuery, withTrailingSlash, withoutBase, withoutFragment, withoutHost, withoutLeadingSlash, withoutProtocol, withoutTrailingSlash };\n", "const defaults = Object.freeze({\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false,\n  excludeKeys: void 0,\n  excludeValues: void 0,\n  replacer: void 0\n});\nfunction objectHash(object, options) {\n  if (options) {\n    options = { ...defaults, ...options };\n  } else {\n    options = defaults;\n  }\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nconst defaultPrototypesKeys = Object.freeze([\n  \"prototype\",\n  \"__proto__\",\n  \"constructor\"\n]);\nfunction createHasher(options) {\n  let buff = \"\";\n  let context = /* @__PURE__ */ new Map();\n  const write = (str) => {\n    buff += str;\n  };\n  return {\n    toString() {\n      return buff;\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[type](value);\n    },\n    object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this.object(object.toJSON());\n      }\n      const objString = Object.prototype.toString.call(object);\n      let objType = \"\";\n      const objectLength = objString.length;\n      if (objectLength < 10) {\n        objType = \"unknown:[\" + objString + \"]\";\n      } else {\n        objType = objString.slice(8, objectLength - 1);\n      }\n      objType = objType.toLowerCase();\n      let objectNumber = null;\n      if ((objectNumber = context.get(object)) === void 0) {\n        context.set(object, context.size);\n      } else {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[objType]) {\n          this[objType](object);\n        } else if (!options.ignoreUnknown) {\n          this.unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        let extraKeys = [];\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          extraKeys = defaultPrototypesKeys;\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n          extraKeys = extraKeys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + (keys.length + extraKeys.length) + \":\");\n        const dispatchForKey = (key) => {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        };\n        for (const key of keys) {\n          dispatchForKey(key);\n        }\n        for (const key of extraKeys) {\n          dispatchForKey(key);\n        }\n      }\n    },\n    array(arr, unordered) {\n      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = /* @__PURE__ */ new Map();\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        for (const [key, value] of hasher.getContext()) {\n          contextAdditions.set(key, value);\n        }\n        return hasher.toString();\n      });\n      context = contextAdditions;\n      entries.sort();\n      return this.array(entries, false);\n    },\n    date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this.array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    boolean(bool) {\n      return write(\"bool:\" + bool);\n    },\n    string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string);\n    },\n    function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this.object(fn);\n      }\n    },\n    number(number) {\n      return write(\"number:\" + number);\n    },\n    xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    null() {\n      return write(\"Null\");\n    },\n    undefined() {\n      return write(\"Undefined\");\n    },\n    regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    domwindow() {\n      return write(\"domwindow\");\n    },\n    bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    process() {\n      return write(\"process\");\n    },\n    timer() {\n      return write(\"timer\");\n    },\n    pipe() {\n      return write(\"pipe\");\n    },\n    tcp() {\n      return write(\"tcp\");\n    },\n    udp() {\n      return write(\"udp\");\n    },\n    tty() {\n      return write(\"tty\");\n    },\n    statwatcher() {\n      return write(\"statwatcher\");\n    },\n    securecontext() {\n      return write(\"securecontext\");\n    },\n    connection() {\n      return write(\"connection\");\n    },\n    zlib() {\n      return write(\"zlib\");\n    },\n    context() {\n      return write(\"context\");\n    },\n    nodescript() {\n      return write(\"nodescript\");\n    },\n    httpparser() {\n      return write(\"httpparser\");\n    },\n    dataview() {\n      return write(\"dataview\");\n    },\n    signal() {\n      return write(\"signal\");\n    },\n    fsevent() {\n      return write(\"fsevent\");\n    },\n    tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nconst nativeFunc = \"[native code] }\";\nconst nativeFuncLength = nativeFunc.length;\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;\n}\n\nfunction diff(obj1, obj2, opts = {}) {\n  const h1 = _toHashedObject(obj1, opts);\n  const h2 = _toHashedObject(obj2, opts);\n  return _diff(h1, h2, opts);\n}\nfunction _diff(h1, h2, opts = {}) {\n  const diffs = [];\n  const allProps = /* @__PURE__ */ new Set([\n    ...Object.keys(h1.props || {}),\n    ...Object.keys(h2.props || {})\n  ]);\n  if (h1.props && h2.props) {\n    for (const prop of allProps) {\n      const p1 = h1.props[prop];\n      const p2 = h2.props[prop];\n      if (p1 && p2) {\n        diffs.push(..._diff(h1.props?.[prop], h2.props?.[prop], opts));\n      } else if (p1 || p2) {\n        diffs.push(\n          new DiffEntry((p2 || p1).key, p1 ? \"removed\" : \"added\", p2, p1)\n        );\n      }\n    }\n  }\n  if (allProps.size === 0 && h1.hash !== h2.hash) {\n    diffs.push(new DiffEntry((h2 || h1).key, \"changed\", h2, h1));\n  }\n  return diffs;\n}\nfunction _toHashedObject(obj, opts, key = \"\") {\n  if (obj && typeof obj !== \"object\") {\n    return new DiffHashedObject(key, obj, objectHash(obj, opts));\n  }\n  const props = {};\n  const hashes = [];\n  for (const _key in obj) {\n    props[_key] = _toHashedObject(\n      obj[_key],\n      opts,\n      key ? `${key}.${_key}` : _key\n    );\n    hashes.push(props[_key].hash);\n  }\n  return new DiffHashedObject(key, obj, `{${hashes.join(\":\")}}`, props);\n}\nclass DiffEntry {\n  constructor(key, type, newValue, oldValue) {\n    this.key = key;\n    this.type = type;\n    this.newValue = newValue;\n    this.oldValue = oldValue;\n  }\n  toString() {\n    return this.toJSON();\n  }\n  toJSON() {\n    switch (this.type) {\n      case \"added\": {\n        return `Added   \\`${this.key}\\``;\n      }\n      case \"removed\": {\n        return `Removed \\`${this.key}\\``;\n      }\n      case \"changed\": {\n        return `Changed \\`${this.key}\\` from \\`${this.oldValue?.toString() || \"-\"}\\` to \\`${this.newValue.toString()}\\``;\n      }\n    }\n  }\n}\nclass DiffHashedObject {\n  constructor(key, value, hash, props) {\n    this.key = key;\n    this.value = value;\n    this.hash = hash;\n    this.props = props;\n  }\n  toString() {\n    if (this.props) {\n      return `{${Object.keys(this.props).join(\",\")}}`;\n    } else {\n      return JSON.stringify(this.value);\n    }\n  }\n  toJSON() {\n    const k = this.key || \".\";\n    if (this.props) {\n      return `${k}({${Object.keys(this.props).join(\",\")}})`;\n    }\n    return `${k}(${this.value})`;\n  }\n}\n\nfunction isEqual(object1, object2, hashOptions = {}) {\n  if (object1 === object2) {\n    return true;\n  }\n  if (objectHash(object1, hashOptions) === objectHash(object2, hashOptions)) {\n    return true;\n  }\n  return false;\n}\n\nexport { diff as d, isEqual as i, objectHash as o };\n", "const suspectProtoRx = /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nconst JsonSigRx = /^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\nfunction jsonParseTransform(key, value) {\n  if (key === \"__proto__\" || key === \"constructor\" && value && typeof value === \"object\" && \"prototype\" in value) {\n    warnKeyDropped(key);\n    return;\n  }\n  return value;\n}\nfunction warnKeyDropped(key) {\n  console.warn(`[destr] Dropping \"${key}\" key to prevent prototype pollution.`);\n}\nfunction destr(value, options = {}) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  if (value[0] === '\"' && value[value.length - 1] === '\"' && value.indexOf(\"\\\\\") === -1) {\n    return value.slice(1, -1);\n  }\n  const _value = value.trim();\n  if (_value.length <= 9) {\n    switch (_value.toLowerCase()) {\n      case \"true\": {\n        return true;\n      }\n      case \"false\": {\n        return false;\n      }\n      case \"undefined\": {\n        return void 0;\n      }\n      case \"null\": {\n        return null;\n      }\n      case \"nan\": {\n        return Number.NaN;\n      }\n      case \"infinity\": {\n        return Number.POSITIVE_INFINITY;\n      }\n      case \"-infinity\": {\n        return Number.NEGATIVE_INFINITY;\n      }\n    }\n  }\n  if (!JsonSigRx.test(value)) {\n    if (options.strict) {\n      throw new SyntaxError(\"[destr] Invalid JSON\");\n    }\n    return value;\n  }\n  try {\n    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {\n      if (options.strict) {\n        throw new Error(\"[destr] Possible prototype pollution\");\n      }\n      return JSON.parse(value, jsonParseTransform);\n    }\n    return JSON.parse(value);\n  } catch (error) {\n    if (options.strict) {\n      throw error;\n    }\n    return value;\n  }\n}\nfunction safeDestr(value, options = {}) {\n  return destr(value, { ...options, strict: true });\n}\n\nexport { destr as default, destr, safeDestr };\n", "function isPlainObject(value) {\n  if (value === null || typeof value !== \"object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {\n    return false;\n  }\n  if (Symbol.iterator in value) {\n    return false;\n  }\n  if (Symbol.toStringTag in value) {\n    return Object.prototype.toString.call(value) === \"[object Module]\";\n  }\n  return true;\n}\n\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isPlainObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isPlainObject(value) && isPlainObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\nconst defuFn = createDefu((object, key, currentValue) => {\n  if (object[key] !== void 0 && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((object, key, currentValue) => {\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\n\nexport { createDefu, defu as default, defu, defuArrayFn, defuFn };\n", "const webCrypto = globalThis.crypto;\nconst subtle = webCrypto.subtle;\nconst randomUUID = () => {\n  return webCrypto.randomUUID();\n};\nconst getRandomValues = (array) => {\n  return webCrypto.getRandomValues(array);\n};\nconst _crypto = {\n  randomUUID,\n  getRandomValues,\n  subtle\n};\n\nexport { _crypto as default, getRandomValues, randomUUID, subtle };\n", "// src/utils.ts\nvar alphabetByEncoding = {};\nvar alphabetByValue = Array.from({ length: 64 });\nfor (let i = 0, start = \"A\".charCodeAt(0), limit = \"Z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  alphabetByEncoding[char] = i;\n  alphabetByValue[i] = char;\n}\nfor (let i = 0, start = \"a\".charCodeAt(0), limit = \"z\".charCodeAt(0); i + start <= limit; i++) {\n  const char = String.fromCharCode(i + start);\n  const index = i + 26;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nfor (let i = 0; i < 10; i++) {\n  alphabetByEncoding[i.toString(10)] = i + 52;\n  const char = i.toString(10);\n  const index = i + 52;\n  alphabetByEncoding[char] = index;\n  alphabetByValue[index] = char;\n}\nalphabetByEncoding[\"-\"] = 62;\nalphabetByValue[62] = \"-\";\nalphabetByEncoding[\"_\"] = 63;\nalphabetByValue[63] = \"_\";\nvar bitsPerLetter = 6;\nvar bitsPerByte = 8;\nvar maxLetterValue = 63;\nvar stringToBuffer = (value) => {\n  return new TextEncoder().encode(value);\n};\nvar bufferToString = (value) => {\n  return new TextDecoder().decode(value);\n};\nvar base64urlDecode = (_input) => {\n  const input = _input + \"=\".repeat((4 - _input.length % 4) % 4);\n  let totalByteLength = input.length / 4 * 3;\n  if (input.endsWith(\"==\")) {\n    totalByteLength -= 2;\n  } else if (input.endsWith(\"=\")) {\n    totalByteLength--;\n  }\n  const out = new ArrayBuffer(totalByteLength);\n  const dataView = new DataView(out);\n  for (let i = 0; i < input.length; i += 4) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = i + 3; j <= limit; j++) {\n      if (input[j] === \"=\") {\n        bits >>= bitsPerLetter;\n      } else {\n        if (!(input[j] in alphabetByEncoding)) {\n          throw new TypeError(`Invalid character ${input[j]} in base64 string.`);\n        }\n        bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;\n        bitLength += bitsPerLetter;\n      }\n    }\n    const chunkOffset = i / 4 * 3;\n    bits >>= bitLength % bitsPerByte;\n    const byteLength = Math.floor(bitLength / bitsPerByte);\n    for (let k = 0; k < byteLength; k++) {\n      const offset = (byteLength - k - 1) * bitsPerByte;\n      dataView.setUint8(chunkOffset + k, (bits & 255 << offset) >> offset);\n    }\n  }\n  return new Uint8Array(out);\n};\nvar base64urlEncode = (_input) => {\n  const input = typeof _input === \"string\" ? stringToBuffer(_input) : _input;\n  let str = \"\";\n  for (let i = 0; i < input.length; i += 3) {\n    let bits = 0;\n    let bitLength = 0;\n    for (let j = i, limit = Math.min(i + 3, input.length); j < limit; j++) {\n      bits |= input[j] << (limit - j - 1) * bitsPerByte;\n      bitLength += bitsPerByte;\n    }\n    const bitClusterCount = Math.ceil(bitLength / bitsPerLetter);\n    bits <<= bitClusterCount * bitsPerLetter - bitLength;\n    for (let k = 1; k <= bitClusterCount; k++) {\n      const offset = (bitClusterCount - k) * bitsPerLetter;\n      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];\n    }\n  }\n  return str;\n};\n\n// src/index.ts\nvar defaults = {\n  encryption: { saltBits: 256, algorithm: \"aes-256-cbc\", iterations: 1, minPasswordlength: 32 },\n  integrity: { saltBits: 256, algorithm: \"sha256\", iterations: 1, minPasswordlength: 32 },\n  ttl: 0,\n  timestampSkewSec: 60,\n  localtimeOffsetMsec: 0\n};\nvar clone = (options) => ({\n  ...options,\n  encryption: { ...options.encryption },\n  integrity: { ...options.integrity }\n});\nvar algorithms = {\n  \"aes-128-ctr\": { keyBits: 128, ivBits: 128, name: \"AES-CTR\" },\n  \"aes-256-cbc\": { keyBits: 256, ivBits: 128, name: \"AES-CBC\" },\n  sha256: { keyBits: 256, name: \"SHA-256\" }\n};\nvar macFormatVersion = \"2\";\nvar macPrefix = \"Fe26.2\";\nvar randomBytes = (_crypto, size) => {\n  const bytes = new Uint8Array(size);\n  _crypto.getRandomValues(bytes);\n  return bytes;\n};\nvar randomBits = (_crypto, bits) => {\n  if (bits < 1)\n    throw new Error(\"Invalid random bits count\");\n  const bytes = Math.ceil(bits / 8);\n  return randomBytes(_crypto, bytes);\n};\nvar pbkdf2 = async (_crypto, password, salt, iterations, keyLength, hash) => {\n  const passwordBuffer = stringToBuffer(password);\n  const importedKey = await _crypto.subtle.importKey(\n    \"raw\",\n    passwordBuffer,\n    { name: \"PBKDF2\" },\n    false,\n    [\"deriveBits\"]\n  );\n  const saltBuffer = stringToBuffer(salt);\n  const params = { name: \"PBKDF2\", hash, salt: saltBuffer, iterations };\n  const derivation = await _crypto.subtle.deriveBits(params, importedKey, keyLength * 8);\n  return derivation;\n};\nvar generateKey = async (_crypto, password, options) => {\n  var _a;\n  if (!(password == null ? void 0 : password.length))\n    throw new Error(\"Empty password\");\n  if (options == null || typeof options !== \"object\")\n    throw new Error(\"Bad options\");\n  if (!(options.algorithm in algorithms))\n    throw new Error(`Unknown algorithm: ${options.algorithm}`);\n  const algorithm = algorithms[options.algorithm];\n  const result = {};\n  const hmac = (_a = options.hmac) != null ? _a : false;\n  const id = hmac ? { name: \"HMAC\", hash: algorithm.name } : { name: algorithm.name };\n  const usage = hmac ? [\"sign\", \"verify\"] : [\"encrypt\", \"decrypt\"];\n  if (typeof password === \"string\") {\n    if (password.length < options.minPasswordlength)\n      throw new Error(\n        `Password string too short (min ${options.minPasswordlength} characters required)`\n      );\n    let { salt = \"\" } = options;\n    if (!salt) {\n      const { saltBits = 0 } = options;\n      if (!saltBits)\n        throw new Error(\"Missing salt and saltBits options\");\n      const randomSalt = randomBits(_crypto, saltBits);\n      salt = [...new Uint8Array(randomSalt)].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\");\n    }\n    const derivedKey = await pbkdf2(\n      _crypto,\n      password,\n      salt,\n      options.iterations,\n      algorithm.keyBits / 8,\n      \"SHA-1\"\n    );\n    const importedEncryptionKey = await _crypto.subtle.importKey(\n      \"raw\",\n      derivedKey,\n      id,\n      false,\n      usage\n    );\n    result.key = importedEncryptionKey;\n    result.salt = salt;\n  } else {\n    if (password.length < algorithm.keyBits / 8)\n      throw new Error(\"Key buffer (password) too small\");\n    result.key = await _crypto.subtle.importKey(\"raw\", password, id, false, usage);\n    result.salt = \"\";\n  }\n  if (options.iv)\n    result.iv = options.iv;\n  else if (\"ivBits\" in algorithm)\n    result.iv = randomBits(_crypto, algorithm.ivBits);\n  return result;\n};\nvar getEncryptParams = (algorithm, key, data) => {\n  return [\n    algorithm === \"aes-128-ctr\" ? { name: \"AES-CTR\", counter: key.iv, length: 128 } : { name: \"AES-CBC\", iv: key.iv },\n    key.key,\n    typeof data === \"string\" ? stringToBuffer(data) : data\n  ];\n};\nvar encrypt = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, options);\n  const encrypted = await _crypto.subtle.encrypt(...getEncryptParams(options.algorithm, key, data));\n  return { encrypted: new Uint8Array(encrypted), key };\n};\nvar decrypt = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, options);\n  const decrypted = await _crypto.subtle.decrypt(...getEncryptParams(options.algorithm, key, data));\n  return bufferToString(new Uint8Array(decrypted));\n};\nvar hmacWithPassword = async (_crypto, password, options, data) => {\n  const key = await generateKey(_crypto, password, { ...options, hmac: true });\n  const textBuffer = stringToBuffer(data);\n  const signed = await _crypto.subtle.sign({ name: \"HMAC\" }, key.key, textBuffer);\n  const digest = base64urlEncode(new Uint8Array(signed));\n  return { digest, salt: key.salt };\n};\nvar normalizePassword = (password) => {\n  if (typeof password === \"string\" || password instanceof Uint8Array)\n    return { encryption: password, integrity: password };\n  if (\"secret\" in password)\n    return { id: password.id, encryption: password.secret, integrity: password.secret };\n  return { id: password.id, encryption: password.encryption, integrity: password.integrity };\n};\nvar seal = async (_crypto, object, password, options) => {\n  if (!password)\n    throw new Error(\"Empty password\");\n  const opts = clone(options);\n  const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n  const objectString = JSON.stringify(object);\n  const pass = normalizePassword(password);\n  const { id = \"\", encryption, integrity } = pass;\n  if (id && !/^\\w+$/.test(id))\n    throw new Error(\"Invalid password id\");\n  const { encrypted, key } = await encrypt(_crypto, encryption, opts.encryption, objectString);\n  const encryptedB64 = base64urlEncode(new Uint8Array(encrypted));\n  const iv = base64urlEncode(key.iv);\n  const expiration = opts.ttl ? now + opts.ttl : \"\";\n  const macBaseString = `${macPrefix}*${id}*${key.salt}*${iv}*${encryptedB64}*${expiration}`;\n  const mac = await hmacWithPassword(_crypto, integrity, opts.integrity, macBaseString);\n  const sealed = `${macBaseString}*${mac.salt}*${mac.digest}`;\n  return sealed;\n};\nvar fixedTimeComparison = (a, b) => {\n  let mismatch = a.length === b.length ? 0 : 1;\n  if (mismatch)\n    b = a;\n  for (let i = 0; i < a.length; i += 1)\n    mismatch |= a.charCodeAt(i) ^ b.charCodeAt(i);\n  return mismatch === 0;\n};\nvar unseal = async (_crypto, sealed, password, options) => {\n  if (!password)\n    throw new Error(\"Empty password\");\n  const opts = clone(options);\n  const now = Date.now() + (opts.localtimeOffsetMsec || 0);\n  const parts = sealed.split(\"*\");\n  if (parts.length !== 8)\n    throw new Error(\"Incorrect number of sealed components\");\n  const prefix = parts[0];\n  let passwordId = parts[1];\n  const encryptionSalt = parts[2];\n  const encryptionIv = parts[3];\n  const encryptedB64 = parts[4];\n  const expiration = parts[5];\n  const hmacSalt = parts[6];\n  const hmac = parts[7];\n  const macBaseString = `${prefix}*${passwordId}*${encryptionSalt}*${encryptionIv}*${encryptedB64}*${expiration}`;\n  if (macPrefix !== prefix)\n    throw new Error(\"Wrong mac prefix\");\n  if (expiration) {\n    if (!/^\\d+$/.test(expiration))\n      throw new Error(\"Invalid expiration\");\n    const exp = Number.parseInt(expiration, 10);\n    if (exp <= now - opts.timestampSkewSec * 1e3)\n      throw new Error(\"Expired seal\");\n  }\n  let pass = \"\";\n  passwordId = passwordId || \"default\";\n  if (typeof password === \"string\" || password instanceof Uint8Array)\n    pass = password;\n  else if (passwordId in password) {\n    pass = password[passwordId];\n  } else {\n    throw new Error(`Cannot find password: ${passwordId}`);\n  }\n  pass = normalizePassword(pass);\n  const macOptions = opts.integrity;\n  macOptions.salt = hmacSalt;\n  const mac = await hmacWithPassword(_crypto, pass.integrity, macOptions, macBaseString);\n  if (!fixedTimeComparison(mac.digest, hmac))\n    throw new Error(\"Bad hmac value\");\n  const encrypted = base64urlDecode(encryptedB64);\n  const decryptOptions = opts.encryption;\n  decryptOptions.salt = encryptionSalt;\n  decryptOptions.iv = base64urlDecode(encryptionIv);\n  const decrypted = await decrypt(_crypto, pass.encryption, decryptOptions, encrypted);\n  if (decrypted)\n    return JSON.parse(decrypted);\n  return null;\n};\n\nexport { algorithms, base64urlDecode, base64urlEncode, bufferToString, clone, decrypt, defaults, encrypt, generateKey, hmacWithPassword, macFormatVersion, macPrefix, randomBits, seal, stringToBuffer, unseal };\n", "export function rawHeaders(headers) {\n  const rawHeaders2 = [];\n  for (const key in headers) {\n    if (Array.isArray(headers[key])) {\n      for (const h of headers[key]) {\n        rawHeaders2.push(key, h);\n      }\n    } else {\n      rawHeaders2.push(key, headers[key]);\n    }\n  }\n  return rawHeaders2;\n}\nexport function mergeFns(...functions) {\n  return function(...args) {\n    for (const fn of functions) {\n      fn(...args);\n    }\n  };\n}\nexport function createNotImplementedError(name) {\n  throw new Error(`[unenv] ${name} is not implemented yet!`);\n}\nexport function notImplemented(name) {\n  const fn = () => {\n    throw createNotImplementedError(name);\n  };\n  return Object.assign(fn, { __unenv__: true });\n}\nexport function notImplementedClass(name) {\n  return class {\n    __unenv__ = true;\n    constructor() {\n      throw new Error(`[unenv] ${name} is not implemented yet!`);\n    }\n  };\n}\n", "const fn = function() {\n};\nfunction createMock(name, overrides = {}) {\n  fn.prototype.name = name;\n  const props = {};\n  return new Proxy(fn, {\n    get(_target, prop) {\n      if (prop === \"caller\") {\n        return null;\n      }\n      if (prop === \"__createMock__\") {\n        return createMock;\n      }\n      if (prop === \"__unenv__\") {\n        return true;\n      }\n      if (prop in overrides) {\n        return overrides[prop];\n      }\n      return props[prop] = props[prop] || createMock(`${name}.${prop.toString()}`);\n    },\n    apply(_target, _this, _args) {\n      return createMock(`${name}()`);\n    },\n    construct(_target, _args, _newT) {\n      return createMock(`[${name}]`);\n    },\n    // @ts-ignore (ES6-only - removed in ES7)\n    // https://github.com/tc39/ecma262/issues/161\n    enumerate() {\n      return [];\n    }\n  });\n}\nexport default createMock(\"mock\");\n", "export const METHODS = [\n  \"ACL\",\n  \"BIND\",\n  \"CHECKOUT\",\n  \"CONNECT\",\n  \"COPY\",\n  \"DELETE\",\n  \"GET\",\n  \"HEAD\",\n  \"LINK\",\n  \"LOCK\",\n  \"M-SEARCH\",\n  \"MERGE\",\n  \"MKACTIVITY\",\n  \"MKCALENDAR\",\n  \"MKCOL\",\n  \"MOVE\",\n  \"NOTIFY\",\n  \"OPTIONS\",\n  \"PATCH\",\n  \"POST\",\n  \"PRI\",\n  \"PROPFIND\",\n  \"PROPPATCH\",\n  \"PURGE\",\n  \"PUT\",\n  \"REBIND\",\n  \"REPORT\",\n  \"SEARCH\",\n  \"SOURCE\",\n  \"SUBSCRIBE\",\n  \"TRACE\",\n  \"UNBIND\",\n  \"UNLINK\",\n  \"UNLOCK\",\n  \"UNSUBSCRIBE\"\n];\nexport const STATUS_CODES = {\n  100: \"Continue\",\n  101: \"Switching Protocols\",\n  102: \"Processing\",\n  103: \"Early Hints\",\n  200: \"OK\",\n  201: \"Created\",\n  202: \"Accepted\",\n  203: \"Non-Authoritative Information\",\n  204: \"No Content\",\n  205: \"Reset Content\",\n  206: \"Partial Content\",\n  207: \"Multi-Status\",\n  208: \"Already Reported\",\n  226: \"IM Used\",\n  300: \"Multiple Choices\",\n  301: \"Moved Permanently\",\n  302: \"Found\",\n  303: \"See Other\",\n  304: \"Not Modified\",\n  305: \"Use Proxy\",\n  307: \"Temporary Redirect\",\n  308: \"Permanent Redirect\",\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  402: \"Payment Required\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  405: \"Method Not Allowed\",\n  406: \"Not Acceptable\",\n  407: \"Proxy Authentication Required\",\n  408: \"Request Timeout\",\n  409: \"Conflict\",\n  410: \"Gone\",\n  411: \"Length Required\",\n  412: \"Precondition Failed\",\n  413: \"Payload Too Large\",\n  414: \"URI Too Long\",\n  415: \"Unsupported Media Type\",\n  416: \"Range Not Satisfiable\",\n  417: \"Expectation Failed\",\n  418: \"I'm a Teapot\",\n  421: \"Misdirected Request\",\n  422: \"Unprocessable Entity\",\n  423: \"Locked\",\n  424: \"Failed Dependency\",\n  425: \"Too Early\",\n  426: \"Upgrade Required\",\n  428: \"Precondition Required\",\n  429: \"Too Many Requests\",\n  431: \"Request Header Fields Too Large\",\n  451: \"Unavailable For Legal Reasons\",\n  500: \"Internal Server Error\",\n  501: \"Not Implemented\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n  504: \"Gateway Timeout\",\n  505: \"HTTP Version Not Supported\",\n  506: \"Variant Also Negotiates\",\n  507: \"Insufficient Storage\",\n  508: \"Loop Detected\",\n  509: \"Bandwidth Limit Exceeded\",\n  510: \"Not Extended\",\n  511: \"Network Authentication Required\"\n};\nexport const maxHeaderSize = 16384;\n", "let defaultMaxListeners = 10;\nexport class EventEmitter {\n  __unenv__ = true;\n  _events = /* @__PURE__ */ Object.create(null);\n  _maxListeners;\n  static get defaultMaxListeners() {\n    return defaultMaxListeners;\n  }\n  static set defaultMaxListeners(arg) {\n    if (typeof arg !== \"number\" || arg < 0 || Number.isNaN(arg)) {\n      throw new RangeError(\n        'The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + \".\"\n      );\n    }\n    defaultMaxListeners = arg;\n  }\n  setMaxListeners(n) {\n    if (typeof n !== \"number\" || n < 0 || Number.isNaN(n)) {\n      throw new RangeError(\n        'The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + \".\"\n      );\n    }\n    this._maxListeners = n;\n    return this;\n  }\n  getMaxListeners() {\n    return _getMaxListeners(this);\n  }\n  emit(type, ...args) {\n    if (!this._events[type] || this._events[type].length === 0) {\n      return false;\n    }\n    if (type === \"error\") {\n      let er;\n      if (args.length > 0) {\n        er = args[0];\n      }\n      if (er instanceof Error) {\n        throw er;\n      }\n      const err = new Error(\n        \"Unhandled error.\" + (er ? \" (\" + er.message + \")\" : \"\")\n      );\n      err.context = er;\n      throw err;\n    }\n    for (const _listener of this._events[type]) {\n      (_listener.listener || _listener).apply(this, args);\n    }\n    return true;\n  }\n  addListener(type, listener) {\n    return _addListener(this, type, listener, false);\n  }\n  on(type, listener) {\n    return _addListener(this, type, listener, false);\n  }\n  prependListener(type, listener) {\n    return _addListener(this, type, listener, true);\n  }\n  once(type, listener) {\n    return this.on(type, _wrapOnce(this, type, listener));\n  }\n  prependOnceListener(type, listener) {\n    return this.prependListener(type, _wrapOnce(this, type, listener));\n  }\n  removeListener(type, listener) {\n    return _removeListener(this, type, listener);\n  }\n  off(type, listener) {\n    return this.removeListener(type, listener);\n  }\n  removeAllListeners(type) {\n    return _removeAllListeners(this, type);\n  }\n  listeners(type) {\n    return _listeners(this, type, true);\n  }\n  rawListeners(type) {\n    return _listeners(this, type, false);\n  }\n  listenerCount(type) {\n    return this.rawListeners(type).length;\n  }\n  eventNames() {\n    return Object.keys(this._events);\n  }\n}\nexport function once(emitter, name) {\n  return new Promise(function(resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n    function resolver() {\n      if (typeof emitter.removeListener === \"function\") {\n        emitter.removeListener(\"error\", errorListener);\n      }\n      resolve(Array.prototype.slice.call(arguments));\n    }\n    _eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== \"error\") {\n      _addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\nfunction _addListener(target, type, listener, prepend) {\n  _checkListener(listener);\n  if (target._events.newListener !== void 0) {\n    target.emit(\"newListener\", type, listener.listener || listener);\n  }\n  if (!target._events[type]) {\n    target._events[type] = [];\n  }\n  if (prepend) {\n    target._events[type].unshift(listener);\n  } else {\n    target._events[type].push(listener);\n  }\n  const maxListeners = _getMaxListeners(target);\n  if (maxListeners > 0 && target._events[type].length > maxListeners && !target._events[type].warned) {\n    target._events[type].warned = true;\n    const warning = new Error(\n      `[unenv] Possible EventEmitter memory leak detected. ${target._events[type].length} ${type} listeners added. Use emitter.setMaxListeners() to increase limit`\n    );\n    warning.name = \"MaxListenersExceededWarning\";\n    warning.emitter = target;\n    warning.type = type;\n    warning.count = target._events[type]?.length;\n    console.warn(warning);\n  }\n  return target;\n}\nfunction _removeListener(target, type, listener) {\n  _checkListener(listener);\n  if (!target._events[type] || target._events[type].length === 0) {\n    return target;\n  }\n  const lenBeforeFilter = target._events[type].length;\n  target._events[type] = target._events[type].filter((fn) => fn !== listener);\n  if (lenBeforeFilter === target._events[type].length) {\n    return target;\n  }\n  if (target._events.removeListener) {\n    target.emit(\"removeListener\", type, listener.listener || listener);\n  }\n  if (target._events[type].length === 0) {\n    delete target._events[type];\n  }\n  return target;\n}\nfunction _removeAllListeners(target, type) {\n  if (!target._events[type] || target._events[type].length === 0) {\n    return target;\n  }\n  if (target._events.removeListener) {\n    for (const _listener of target._events[type]) {\n      target.emit(\"removeListener\", type, _listener.listener || _listener);\n    }\n  }\n  delete target._events[type];\n  return target;\n}\nfunction _wrapOnce(target, type, listener) {\n  let fired = false;\n  const wrapper = (...args) => {\n    if (fired) {\n      return;\n    }\n    target.removeListener(type, wrapper);\n    fired = true;\n    return args.length === 0 ? listener.call(target) : listener.apply(target, args);\n  };\n  wrapper.listener = listener;\n  return wrapper;\n}\nfunction _getMaxListeners(target) {\n  return target._maxListeners ?? EventEmitter.defaultMaxListeners;\n}\nfunction _listeners(target, type, unwrap) {\n  let listeners = target._events[type];\n  if (typeof listeners === \"function\") {\n    listeners = [listeners];\n  }\n  return unwrap ? listeners.map((l) => l.listener || l) : listeners;\n}\nfunction _checkListener(listener) {\n  if (typeof listener !== \"function\") {\n    throw new TypeError(\n      'The \"listener\" argument must be of type Function. Received type ' + typeof listener\n    );\n  }\n}\nfunction _addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === \"function\") {\n    _eventTargetAgnosticAddListener(emitter, \"error\", handler, flags);\n  }\n}\nfunction _eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === \"function\") {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === \"function\") {\n    emitter.addEventListener(name, listener);\n  } else {\n    throw new TypeError(\n      'The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter\n    );\n  }\n}\n", "import { EventEmitter as _EventEmitter, once as _once } from \"./_events.mjs\";\nexport const EventEmitter = globalThis.EventEmitter || _EventEmitter;\nexport const once = _once;\nexport default {\n  EventEmitter,\n  once\n};\n", "import { createNotImplementedError } from \"../../_internal/utils.mjs\";\nimport { EventEmitter } from \"../events/index.mjs\";\nexport class _Readable extends EventEmitter {\n  __unenv__ = true;\n  readableEncoding = null;\n  readableEnded = true;\n  readableFlowing = false;\n  readableHighWaterMark = 0;\n  readableLength = 0;\n  readableObjectMode = false;\n  readableAborted = false;\n  readableDidRead = false;\n  closed = false;\n  errored = null;\n  readable = false;\n  destroyed = false;\n  static from(_iterable, options) {\n    return new _Readable(options);\n  }\n  constructor(_opts) {\n    super();\n  }\n  _read(_size) {\n  }\n  read(_size) {\n  }\n  setEncoding(_encoding) {\n    return this;\n  }\n  pause() {\n    return this;\n  }\n  resume() {\n    return this;\n  }\n  isPaused() {\n    return true;\n  }\n  unpipe(_destination) {\n    return this;\n  }\n  unshift(_chunk, _encoding) {\n  }\n  wrap(_oldStream) {\n    return this;\n  }\n  push(_chunk, _encoding) {\n    return false;\n  }\n  _destroy(_error, _callback) {\n    this.removeAllListeners();\n  }\n  destroy(error) {\n    this.destroyed = true;\n    this._destroy(error);\n    return this;\n  }\n  pipe(_destenition, _options) {\n    return {};\n  }\n  compose(stream, options) {\n    throw new Error(\"[unenv] Method not implemented.\");\n  }\n  [Symbol.asyncDispose]() {\n    this.destroy();\n    return Promise.resolve();\n  }\n  // eslint-disable-next-line require-yield\n  async *[Symbol.asyncIterator]() {\n    throw createNotImplementedError(\"Readable.asyncIterator\");\n  }\n  iterator(options) {\n    throw createNotImplementedError(\"Readable.iterator\");\n  }\n  map(fn, options) {\n    throw createNotImplementedError(\"Readable.map\");\n  }\n  filter(fn, options) {\n    throw createNotImplementedError(\"Readable.filter\");\n  }\n  forEach(fn, options) {\n    throw createNotImplementedError(\"Readable.forEach\");\n  }\n  reduce(fn, initialValue, options) {\n    throw createNotImplementedError(\"Readable.reduce\");\n  }\n  find(fn, options) {\n    throw createNotImplementedError(\"Readable.find\");\n  }\n  findIndex(fn, options) {\n    throw createNotImplementedError(\"Readable.findIndex\");\n  }\n  some(fn, options) {\n    throw createNotImplementedError(\"Readable.some\");\n  }\n  toArray(options) {\n    throw createNotImplementedError(\"Readable.toArray\");\n  }\n  every(fn, options) {\n    throw createNotImplementedError(\"Readable.every\");\n  }\n  flatMap(fn, options) {\n    throw createNotImplementedError(\"Readable.flatMap\");\n  }\n  drop(limit, options) {\n    throw createNotImplementedError(\"Readable.drop\");\n  }\n  take(limit, options) {\n    throw createNotImplementedError(\"Readable.take\");\n  }\n  asIndexedPairs(options) {\n    throw createNotImplementedError(\"Readable.asIndexedPairs\");\n  }\n}\nexport const Readable = globalThis.Readable || _Readable;\n", "import { EventEmitter } from \"../events/index.mjs\";\nclass _Writable extends EventEmitter {\n  __unenv__ = true;\n  writable = true;\n  writableEnded = false;\n  writableFinished = false;\n  writableHighWaterMark = 0;\n  writableLength = 0;\n  writableObjectMode = false;\n  writableCorked = 0;\n  closed = false;\n  errored = null;\n  writableNeedDrain = false;\n  destroyed = false;\n  _data;\n  _encoding = \"utf-8\";\n  constructor(_opts) {\n    super();\n  }\n  pipe(_destenition, _options) {\n    return {};\n  }\n  _write(chunk, encoding, callback) {\n    if (this.writableEnded) {\n      if (callback) {\n        callback();\n      }\n      return;\n    }\n    if (this._data === void 0) {\n      this._data = chunk;\n    } else {\n      const a = typeof this._data === \"string\" ? Buffer.from(this._data, this._encoding || encoding || \"utf8\") : this._data;\n      const b = typeof chunk === \"string\" ? Buffer.from(chunk, encoding || this._encoding || \"utf8\") : chunk;\n      this._data = Buffer.concat([a, b]);\n    }\n    this._encoding = encoding;\n    if (callback) {\n      callback();\n    }\n  }\n  _writev(_chunks, _callback) {\n  }\n  _destroy(_error, _callback) {\n  }\n  _final(_callback) {\n  }\n  write(chunk, arg2, arg3) {\n    const encoding = typeof arg2 === \"string\" ? this._encoding : \"utf-8\";\n    const cb = typeof arg2 === \"function\" ? arg2 : typeof arg3 === \"function\" ? arg3 : void 0;\n    this._write(chunk, encoding, cb);\n    return true;\n  }\n  setDefaultEncoding(_encoding) {\n    return this;\n  }\n  end(arg1, arg2, arg3) {\n    const callback = typeof arg1 === \"function\" ? arg1 : typeof arg2 === \"function\" ? arg2 : typeof arg3 === \"function\" ? arg3 : void 0;\n    if (this.writableEnded) {\n      if (callback) {\n        callback();\n      }\n      return this;\n    }\n    const data = arg1 === callback ? void 0 : arg1;\n    if (data) {\n      const encoding = arg2 === callback ? void 0 : arg2;\n      this.write(data, encoding, callback);\n    }\n    this.writableEnded = true;\n    this.writableFinished = true;\n    this.emit(\"close\");\n    this.emit(\"finish\");\n    return this;\n  }\n  cork() {\n  }\n  uncork() {\n  }\n  destroy(_error) {\n    this.destroyed = true;\n    delete this._data;\n    this.removeAllListeners();\n    return this;\n  }\n  compose(stream, options) {\n    throw new Error(\"[h3] Method not implemented.\");\n  }\n}\nexport const Writable = globalThis.Writable || _Writable;\n", "import { mergeFns } from \"../../_internal/utils.mjs\";\nimport { Readable } from \"./readable.mjs\";\nimport { Writable } from \"./writable.mjs\";\nconst __Duplex = class {\n  allowHalfOpen = true;\n  _destroy;\n  constructor(readable = new Readable(), writable = new Writable()) {\n    Object.assign(this, readable);\n    Object.assign(this, writable);\n    this._destroy = mergeFns(readable._destroy, writable._destroy);\n  }\n};\nfunction getDuplex() {\n  Object.assign(__Duplex.prototype, Readable.prototype);\n  Object.assign(__Duplex.prototype, Writable.prototype);\n  return __Duplex;\n}\nexport const _Duplex = /* @__PURE__ */ getDuplex();\nexport const Duplex = globalThis.Duplex || _Duplex;\n", "import { Duplex } from \"../stream/duplex.mjs\";\nexport class Socket extends Duplex {\n  __unenv__ = true;\n  bufferSize = 0;\n  bytesRead = 0;\n  bytesWritten = 0;\n  connecting = false;\n  destroyed = false;\n  pending = false;\n  localAddress = \"\";\n  localPort = 0;\n  remoteAddress = \"\";\n  remoteFamily = \"\";\n  remotePort = 0;\n  autoSelectFamilyAttemptedAddresses = [];\n  readyState = \"readOnly\";\n  constructor(_options) {\n    super();\n  }\n  write(_buffer, _arg1, _arg2) {\n    return false;\n  }\n  connect(_arg1, _arg2, _arg3) {\n    return this;\n  }\n  end(_arg1, _arg2, _arg3) {\n    return this;\n  }\n  setEncoding(_encoding) {\n    return this;\n  }\n  pause() {\n    return this;\n  }\n  resume() {\n    return this;\n  }\n  setTimeout(_timeout, _callback) {\n    return this;\n  }\n  setNoDelay(_noDelay) {\n    return this;\n  }\n  setKeepAlive(_enable, _initialDelay) {\n    return this;\n  }\n  address() {\n    return {};\n  }\n  unref() {\n    return this;\n  }\n  ref() {\n    return this;\n  }\n  destroySoon() {\n    this.destroy();\n  }\n  resetAndDestroy() {\n    const err = new Error(\"ERR_SOCKET_CLOSED\");\n    err.code = \"ERR_SOCKET_CLOSED\";\n    this.destroy(err);\n    return this;\n  }\n}\nexport class SocketAddress {\n  __unenv__ = true;\n  address;\n  family;\n  port;\n  flowlabel;\n  constructor(options) {\n    this.address = options.address;\n    this.family = options.family;\n    this.port = options.port;\n    this.flowlabel = options.flowlabel;\n  }\n}\n", "import { Socket } from \"../net/socket.mjs\";\nimport { Readable } from \"../stream/readable.mjs\";\nimport { rawHeaders } from \"../../_internal/utils.mjs\";\nexport class IncomingMessage extends Readable {\n  __unenv__ = {};\n  aborted = false;\n  httpVersion = \"1.1\";\n  httpVersionMajor = 1;\n  httpVersionMinor = 1;\n  complete = true;\n  connection;\n  socket;\n  headers = {};\n  trailers = {};\n  method = \"GET\";\n  url = \"/\";\n  statusCode = 200;\n  statusMessage = \"\";\n  closed = false;\n  errored = null;\n  readable = false;\n  constructor(socket) {\n    super();\n    this.socket = this.connection = socket || new Socket();\n  }\n  get rawHeaders() {\n    return rawHeaders(this.headers);\n  }\n  get rawTrailers() {\n    return [];\n  }\n  setTimeout(_msecs, _callback) {\n    return this;\n  }\n  get headersDistinct() {\n    return _distinct(this.headers);\n  }\n  get trailersDistinct() {\n    return _distinct(this.trailers);\n  }\n}\nfunction _distinct(obj) {\n  const d = {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key) {\n      d[key] = (Array.isArray(value) ? value : [value]).filter(\n        Boolean\n      );\n    }\n  }\n  return d;\n}\n", "import { Writable } from \"../stream/writable.mjs\";\nexport class ServerResponse extends Writable {\n  __unenv__ = true;\n  statusCode = 200;\n  statusMessage = \"\";\n  upgrading = false;\n  chunkedEncoding = false;\n  shouldKeepAlive = false;\n  useChunkedEncodingByDefault = false;\n  sendDate = false;\n  finished = false;\n  headersSent = false;\n  strictContentLength = false;\n  connection = null;\n  socket = null;\n  req;\n  _headers = {};\n  constructor(req) {\n    super();\n    this.req = req;\n  }\n  assignSocket(socket) {\n    socket._httpMessage = this;\n    this.socket = socket;\n    this.connection = socket;\n    this.emit(\"socket\", socket);\n    this._flush();\n  }\n  _flush() {\n    this.flushHeaders();\n  }\n  detachSocket(_socket) {\n  }\n  writeContinue(_callback) {\n  }\n  writeHead(statusCode, arg1, arg2) {\n    if (statusCode) {\n      this.statusCode = statusCode;\n    }\n    if (typeof arg1 === \"string\") {\n      this.statusMessage = arg1;\n      arg1 = void 0;\n    }\n    const headers = arg2 || arg1;\n    if (headers) {\n      if (Array.isArray(headers)) {\n      } else {\n        for (const key in headers) {\n          this.setHeader(key, headers[key]);\n        }\n      }\n    }\n    this.headersSent = true;\n    return this;\n  }\n  writeProcessing() {\n  }\n  setTimeout(_msecs, _callback) {\n    return this;\n  }\n  appendHeader(name, value) {\n    name = name.toLowerCase();\n    const current = this._headers[name];\n    const all = [\n      ...Array.isArray(current) ? current : [current],\n      ...Array.isArray(value) ? value : [value]\n    ].filter(Boolean);\n    this._headers[name] = all.length > 1 ? all : all[0];\n    return this;\n  }\n  setHeader(name, value) {\n    this._headers[name.toLowerCase()] = value;\n    return this;\n  }\n  getHeader(name) {\n    return this._headers[name.toLowerCase()];\n  }\n  getHeaders() {\n    return this._headers;\n  }\n  getHeaderNames() {\n    return Object.keys(this._headers);\n  }\n  hasHeader(name) {\n    return name.toLowerCase() in this._headers;\n  }\n  removeHeader(name) {\n    delete this._headers[name.toLowerCase()];\n  }\n  addTrailers(_headers) {\n  }\n  flushHeaders() {\n  }\n  writeEarlyHints(_headers, cb) {\n    if (typeof cb === \"function\") {\n      cb();\n    }\n  }\n}\n", "import { notImplemented } from \"../../_internal/utils.mjs\";\nimport mock from \"../../mock/proxy.mjs\";\nimport * as consts from \"./_consts.mjs\";\nimport { IncomingMessage } from \"./_request.mjs\";\nimport { ServerResponse } from \"./_response.mjs\";\nexport * from \"./_consts.mjs\";\nexport * from \"./_request.mjs\";\nexport * from \"./_response.mjs\";\nexport const createServer = notImplemented(\"http.createServer\");\nexport const request = notImplemented(\"http.request\");\nexport const get = notImplemented(\"http.get\");\nexport const Server = mock.__createMock__(\"http.Server\");\nexport const OutgoingMessage = mock.__createMock__(\n  \"http.OutgoingMessage\"\n);\nexport const ClientRequest = mock.__createMock__(\"http.ClientRequest\");\nexport const Agent = mock.__createMock__(\"http.Agent\");\nexport const globalAgent = new Agent();\nexport const validateHeaderName = notImplemented(\"http.validateHeaderName\");\nexport const validateHeaderValue = notImplemented(\"http.validateHeaderValue\");\nexport const setMaxIdleHTTPParsers = notImplemented(\"http.setMaxIdleHTTPParsers\");\nexport default {\n  ...consts,\n  IncomingMessage,\n  ServerResponse,\n  createServer,\n  request,\n  get,\n  Server,\n  OutgoingMessage,\n  ClientRequest,\n  Agent,\n  globalAgent,\n  validateHeaderName,\n  validateHeaderValue,\n  setMaxIdleHTTPParsers\n};\n", "import { withoutTrailingSlash, withoutBase, getQuery as getQuery$1, decode, decodePath, withLeadingSlash, parseURL, joinURL } from 'ufo';\nimport { parse as parse$1, serialize } from 'cookie-es';\nimport { objectHash } from 'ohash';\nimport { createRouter as createRouter$1, toRouteMatcher } from 'radix3';\nimport destr from 'destr';\nimport { defu } from 'defu';\nimport crypto from 'uncrypto';\nimport { seal, defaults, unseal } from 'iron-webcrypto';\nimport { IncomingMessage, ServerResponse } from 'unenv/runtime/node/http/index';\n\nfunction useBase(base, handler) {\n  base = withoutTrailingSlash(base);\n  if (!base || base === \"/\") {\n    return handler;\n  }\n  return eventHandler(async (event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    const _path = event._path || event.node.req.url || \"/\";\n    event._path = withoutBase(event.path || \"/\", base);\n    event.node.req.url = event._path;\n    try {\n      return await handler(event);\n    } finally {\n      event._path = event.node.req.url = _path;\n    }\n  });\n}\n\nfunction hasProp(obj, prop) {\n  try {\n    return prop in obj;\n  } catch {\n    return false;\n  }\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass H3Error extends Error {\n  constructor(message, opts = {}) {\n    super(message, opts);\n    __publicField$2(this, \"statusCode\", 500);\n    __publicField$2(this, \"fatal\", false);\n    __publicField$2(this, \"unhandled\", false);\n    __publicField$2(this, \"statusMessage\");\n    __publicField$2(this, \"data\");\n    __publicField$2(this, \"cause\");\n    if (opts.cause && !this.cause) {\n      this.cause = opts.cause;\n    }\n  }\n  toJSON() {\n    const obj = {\n      message: this.message,\n      statusCode: sanitizeStatusCode(this.statusCode, 500)\n    };\n    if (this.statusMessage) {\n      obj.statusMessage = sanitizeStatusMessage(this.statusMessage);\n    }\n    if (this.data !== void 0) {\n      obj.data = this.data;\n    }\n    return obj;\n  }\n}\n__publicField$2(H3Error, \"__h3_error__\", true);\nfunction createError(input) {\n  if (typeof input === \"string\") {\n    return new H3Error(input);\n  }\n  if (isError(input)) {\n    return input;\n  }\n  const err = new H3Error(input.message ?? input.statusMessage ?? \"\", {\n    cause: input.cause || input\n  });\n  if (hasProp(input, \"stack\")) {\n    try {\n      Object.defineProperty(err, \"stack\", {\n        get() {\n          return input.stack;\n        }\n      });\n    } catch {\n      try {\n        err.stack = input.stack;\n      } catch {\n      }\n    }\n  }\n  if (input.data) {\n    err.data = input.data;\n  }\n  if (input.statusCode) {\n    err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);\n  } else if (input.status) {\n    err.statusCode = sanitizeStatusCode(input.status, err.statusCode);\n  }\n  if (input.statusMessage) {\n    err.statusMessage = input.statusMessage;\n  } else if (input.statusText) {\n    err.statusMessage = input.statusText;\n  }\n  if (err.statusMessage) {\n    const originalMessage = err.statusMessage;\n    const sanitizedMessage = sanitizeStatusMessage(err.statusMessage);\n    if (sanitizedMessage !== originalMessage) {\n      console.warn(\n        \"[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.\"\n      );\n    }\n  }\n  if (input.fatal !== void 0) {\n    err.fatal = input.fatal;\n  }\n  if (input.unhandled !== void 0) {\n    err.unhandled = input.unhandled;\n  }\n  return err;\n}\nfunction sendError(event, error, debug) {\n  if (event.handled) {\n    return;\n  }\n  const h3Error = isError(error) ? error : createError(error);\n  const responseBody = {\n    statusCode: h3Error.statusCode,\n    statusMessage: h3Error.statusMessage,\n    stack: [],\n    data: h3Error.data\n  };\n  if (debug) {\n    responseBody.stack = (h3Error.stack || \"\").split(\"\\n\").map((l) => l.trim());\n  }\n  if (event.handled) {\n    return;\n  }\n  const _code = Number.parseInt(h3Error.statusCode);\n  setResponseStatus(event, _code, h3Error.statusMessage);\n  event.node.res.setHeader(\"content-type\", MIMES.json);\n  event.node.res.end(JSON.stringify(responseBody, void 0, 2));\n}\nfunction isError(input) {\n  return input?.constructor?.__h3_error__ === true;\n}\n\nfunction parse(multipartBodyBuffer, boundary) {\n  let lastline = \"\";\n  let state = 0 /* INIT */;\n  let buffer = [];\n  const allParts = [];\n  let currentPartHeaders = [];\n  for (let i = 0; i < multipartBodyBuffer.length; i++) {\n    const prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;\n    const currByte = multipartBodyBuffer[i];\n    const newLineChar = currByte === 10 || currByte === 13;\n    if (!newLineChar) {\n      lastline += String.fromCodePoint(currByte);\n    }\n    const newLineDetected = currByte === 10 && prevByte === 13;\n    if (0 /* INIT */ === state && newLineDetected) {\n      if (\"--\" + boundary === lastline) {\n        state = 1 /* READING_HEADERS */;\n      }\n      lastline = \"\";\n    } else if (1 /* READING_HEADERS */ === state && newLineDetected) {\n      if (lastline.length > 0) {\n        const i2 = lastline.indexOf(\":\");\n        if (i2 > 0) {\n          const name = lastline.slice(0, i2).toLowerCase();\n          const value = lastline.slice(i2 + 1).trim();\n          currentPartHeaders.push([name, value]);\n        }\n      } else {\n        state = 2 /* READING_DATA */;\n        buffer = [];\n      }\n      lastline = \"\";\n    } else if (2 /* READING_DATA */ === state) {\n      if (lastline.length > boundary.length + 4) {\n        lastline = \"\";\n      }\n      if (\"--\" + boundary === lastline) {\n        const j = buffer.length - lastline.length;\n        const part = buffer.slice(0, j - 1);\n        allParts.push(process(part, currentPartHeaders));\n        buffer = [];\n        currentPartHeaders = [];\n        lastline = \"\";\n        state = 3 /* READING_PART_SEPARATOR */;\n      } else {\n        buffer.push(currByte);\n      }\n      if (newLineDetected) {\n        lastline = \"\";\n      }\n    } else if (3 /* READING_PART_SEPARATOR */ === state && newLineDetected) {\n      state = 1 /* READING_HEADERS */;\n    }\n  }\n  return allParts;\n}\nfunction process(data, headers) {\n  const dataObj = {};\n  const contentDispositionHeader = headers.find((h) => h[0] === \"content-disposition\")?.[1] || \"\";\n  for (const i of contentDispositionHeader.split(\";\")) {\n    const s = i.split(\"=\");\n    if (s.length !== 2) {\n      continue;\n    }\n    const key = (s[0] || \"\").trim();\n    if (key === \"name\" || key === \"filename\") {\n      const _value = (s[1] || \"\").trim().replace(/\"/g, \"\");\n      dataObj[key] = Buffer.from(_value, \"latin1\").toString(\"utf8\");\n    }\n  }\n  const contentType = headers.find((h) => h[0] === \"content-type\")?.[1] || \"\";\n  if (contentType) {\n    dataObj.type = contentType;\n  }\n  dataObj.data = Buffer.from(data);\n  return dataObj;\n}\n\nasync function validateData(data, fn) {\n  try {\n    const res = await fn(data);\n    if (res === false) {\n      throw createValidationError();\n    }\n    if (res === true) {\n      return data;\n    }\n    return res ?? data;\n  } catch (error) {\n    throw createValidationError(error);\n  }\n}\nfunction createValidationError(validateError) {\n  throw createError({\n    status: 400,\n    statusMessage: \"Validation Error\",\n    message: validateError?.message || \"Validation Error\",\n    data: validateError\n  });\n}\n\nfunction getQuery(event) {\n  return getQuery$1(event.path || \"\");\n}\nfunction getValidatedQuery(event, validate) {\n  const query = getQuery(event);\n  return validateData(query, validate);\n}\nfunction getRouterParams(event, opts = {}) {\n  let params = event.context.params || {};\n  if (opts.decode) {\n    params = { ...params };\n    for (const key in params) {\n      params[key] = decode(params[key]);\n    }\n  }\n  return params;\n}\nfunction getValidatedRouterParams(event, validate, opts = {}) {\n  const routerParams = getRouterParams(event, opts);\n  return validateData(routerParams, validate);\n}\nfunction getRouterParam(event, name, opts = {}) {\n  const params = getRouterParams(event, opts);\n  return params[name];\n}\nfunction getMethod(event, defaultMethod = \"GET\") {\n  return (event.node.req.method || defaultMethod).toUpperCase();\n}\nfunction isMethod(event, expected, allowHead) {\n  if (allowHead && event.method === \"HEAD\") {\n    return true;\n  }\n  if (typeof expected === \"string\") {\n    if (event.method === expected) {\n      return true;\n    }\n  } else if (expected.includes(event.method)) {\n    return true;\n  }\n  return false;\n}\nfunction assertMethod(event, expected, allowHead) {\n  if (!isMethod(event, expected, allowHead)) {\n    throw createError({\n      statusCode: 405,\n      statusMessage: \"HTTP method is not allowed.\"\n    });\n  }\n}\nfunction getRequestHeaders(event) {\n  const _headers = {};\n  for (const key in event.node.req.headers) {\n    const val = event.node.req.headers[key];\n    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(\", \") : val;\n  }\n  return _headers;\n}\nconst getHeaders = getRequestHeaders;\nfunction getRequestHeader(event, name) {\n  const headers = getRequestHeaders(event);\n  const value = headers[name.toLowerCase()];\n  return value;\n}\nconst getHeader = getRequestHeader;\nfunction getRequestHost(event, opts = {}) {\n  if (opts.xForwardedHost) {\n    const xForwardedHost = event.node.req.headers[\"x-forwarded-host\"];\n    if (xForwardedHost) {\n      return xForwardedHost;\n    }\n  }\n  return event.node.req.headers.host || \"localhost\";\n}\nfunction getRequestProtocol(event, opts = {}) {\n  if (opts.xForwardedProto !== false && event.node.req.headers[\"x-forwarded-proto\"] === \"https\") {\n    return \"https\";\n  }\n  return event.node.req.connection?.encrypted ? \"https\" : \"http\";\n}\nconst DOUBLE_SLASH_RE = /[/\\\\]{2,}/g;\nfunction getRequestPath(event) {\n  const path = (event.node.req.url || \"/\").replace(DOUBLE_SLASH_RE, \"/\");\n  return path;\n}\nfunction getRequestURL(event, opts = {}) {\n  const host = getRequestHost(event, opts);\n  const protocol = getRequestProtocol(event, opts);\n  const path = (event.node.req.originalUrl || event.path).replace(\n    /^[/\\\\]+/g,\n    \"/\"\n  );\n  return new URL(path, `${protocol}://${host}`);\n}\nfunction toWebRequest(event) {\n  return event.web?.request || new Request(getRequestURL(event), {\n    // @ts-ignore Undici option\n    duplex: \"half\",\n    method: event.method,\n    headers: event.headers,\n    body: getRequestWebStream(event)\n  });\n}\nfunction getRequestIP(event, opts = {}) {\n  if (event.context.clientAddress) {\n    return event.context.clientAddress;\n  }\n  if (opts.xForwardedFor) {\n    const xForwardedFor = getRequestHeader(event, \"x-forwarded-for\")?.split(\",\").shift()?.trim();\n    if (xForwardedFor) {\n      return xForwardedFor;\n    }\n  }\n  if (event.node.req.socket.remoteAddress) {\n    return event.node.req.socket.remoteAddress;\n  }\n}\n\nconst RawBodySymbol = Symbol.for(\"h3RawBody\");\nconst ParsedBodySymbol = Symbol.for(\"h3ParsedBody\");\nconst PayloadMethods$1 = [\"PATCH\", \"POST\", \"PUT\", \"DELETE\"];\nfunction readRawBody(event, encoding = \"utf8\") {\n  assertMethod(event, PayloadMethods$1);\n  const _rawBody = event._requestBody || event.web?.request?.body || event.node.req[RawBodySymbol] || event.node.req.rawBody || event.node.req.body;\n  if (_rawBody) {\n    const promise2 = Promise.resolve(_rawBody).then((_resolved) => {\n      if (Buffer.isBuffer(_resolved)) {\n        return _resolved;\n      }\n      if (typeof _resolved.pipeTo === \"function\") {\n        return new Promise((resolve, reject) => {\n          const chunks = [];\n          _resolved.pipeTo(\n            new WritableStream({\n              write(chunk) {\n                chunks.push(chunk);\n              },\n              close() {\n                resolve(Buffer.concat(chunks));\n              },\n              abort(reason) {\n                reject(reason);\n              }\n            })\n          ).catch(reject);\n        });\n      } else if (typeof _resolved.pipe === \"function\") {\n        return new Promise((resolve, reject) => {\n          const chunks = [];\n          _resolved.on(\"data\", (chunk) => {\n            chunks.push(chunk);\n          }).on(\"end\", () => {\n            resolve(Buffer.concat(chunks));\n          }).on(\"error\", reject);\n        });\n      }\n      if (_resolved.constructor === Object) {\n        return Buffer.from(JSON.stringify(_resolved));\n      }\n      if (_resolved instanceof URLSearchParams) {\n        return Buffer.from(_resolved.toString());\n      }\n      return Buffer.from(_resolved);\n    });\n    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;\n  }\n  if (!Number.parseInt(event.node.req.headers[\"content-length\"] || \"\") && !String(event.node.req.headers[\"transfer-encoding\"] ?? \"\").split(\",\").map((e) => e.trim()).filter(Boolean).includes(\"chunked\")) {\n    return Promise.resolve(void 0);\n  }\n  const promise = event.node.req[RawBodySymbol] = new Promise(\n    (resolve, reject) => {\n      const bodyData = [];\n      event.node.req.on(\"error\", (err) => {\n        reject(err);\n      }).on(\"data\", (chunk) => {\n        bodyData.push(chunk);\n      }).on(\"end\", () => {\n        resolve(Buffer.concat(bodyData));\n      });\n    }\n  );\n  const result = encoding ? promise.then((buff) => buff.toString(encoding)) : promise;\n  return result;\n}\nasync function readBody(event, options = {}) {\n  const request = event.node.req;\n  if (hasProp(request, ParsedBodySymbol)) {\n    return request[ParsedBodySymbol];\n  }\n  const contentType = request.headers[\"content-type\"] || \"\";\n  const body = await readRawBody(event);\n  let parsed;\n  if (contentType === \"application/json\") {\n    parsed = _parseJSON(body, options.strict ?? true);\n  } else if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\n    parsed = _parseURLEncodedBody(body);\n  } else if (contentType.startsWith(\"text/\")) {\n    parsed = body;\n  } else {\n    parsed = _parseJSON(body, options.strict ?? false);\n  }\n  request[ParsedBodySymbol] = parsed;\n  return parsed;\n}\nasync function readValidatedBody(event, validate) {\n  const _body = await readBody(event, { strict: true });\n  return validateData(_body, validate);\n}\nasync function readMultipartFormData(event) {\n  const contentType = getRequestHeader(event, \"content-type\");\n  if (!contentType || !contentType.startsWith(\"multipart/form-data\")) {\n    return;\n  }\n  const boundary = contentType.match(/boundary=([^;]*)(;|$)/i)?.[1];\n  if (!boundary) {\n    return;\n  }\n  const body = await readRawBody(event, false);\n  if (!body) {\n    return;\n  }\n  return parse(body, boundary);\n}\nasync function readFormData(event) {\n  return await toWebRequest(event).formData();\n}\nfunction getRequestWebStream(event) {\n  if (!PayloadMethods$1.includes(event.method)) {\n    return;\n  }\n  const bodyStream = event.web?.request?.body || event._requestBody;\n  if (bodyStream) {\n    return bodyStream;\n  }\n  const _hasRawBody = RawBodySymbol in event.node.req || \"rawBody\" in event.node.req || \"body\" in event.node.req || \"__unenv__\" in event.node.req;\n  if (_hasRawBody) {\n    return new ReadableStream({\n      async start(controller) {\n        const _rawBody = await readRawBody(event, false);\n        if (_rawBody) {\n          controller.enqueue(_rawBody);\n        }\n        controller.close();\n      }\n    });\n  }\n  return new ReadableStream({\n    start: (controller) => {\n      event.node.req.on(\"data\", (chunk) => {\n        controller.enqueue(chunk);\n      });\n      event.node.req.on(\"end\", () => {\n        controller.close();\n      });\n      event.node.req.on(\"error\", (err) => {\n        controller.error(err);\n      });\n    }\n  });\n}\nfunction _parseJSON(body = \"\", strict) {\n  if (!body) {\n    return void 0;\n  }\n  try {\n    return destr(body, { strict });\n  } catch {\n    throw createError({\n      statusCode: 400,\n      statusMessage: \"Bad Request\",\n      message: \"Invalid JSON body\"\n    });\n  }\n}\nfunction _parseURLEncodedBody(body) {\n  const form = new URLSearchParams(body);\n  const parsedForm = /* @__PURE__ */ Object.create(null);\n  for (const [key, value] of form.entries()) {\n    if (hasProp(parsedForm, key)) {\n      if (!Array.isArray(parsedForm[key])) {\n        parsedForm[key] = [parsedForm[key]];\n      }\n      parsedForm[key].push(value);\n    } else {\n      parsedForm[key] = value;\n    }\n  }\n  return parsedForm;\n}\n\nfunction handleCacheHeaders(event, opts) {\n  const cacheControls = [\"public\", ...opts.cacheControls || []];\n  let cacheMatched = false;\n  if (opts.maxAge !== void 0) {\n    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);\n  }\n  if (opts.modifiedTime) {\n    const modifiedTime = new Date(opts.modifiedTime);\n    const ifModifiedSince = event.node.req.headers[\"if-modified-since\"];\n    event.node.res.setHeader(\"last-modified\", modifiedTime.toUTCString());\n    if (ifModifiedSince && new Date(ifModifiedSince) >= opts.modifiedTime) {\n      cacheMatched = true;\n    }\n  }\n  if (opts.etag) {\n    event.node.res.setHeader(\"etag\", opts.etag);\n    const ifNonMatch = event.node.req.headers[\"if-none-match\"];\n    if (ifNonMatch === opts.etag) {\n      cacheMatched = true;\n    }\n  }\n  event.node.res.setHeader(\"cache-control\", cacheControls.join(\", \"));\n  if (cacheMatched) {\n    event.node.res.statusCode = 304;\n    if (!event.handled) {\n      event.node.res.end();\n    }\n    return true;\n  }\n  return false;\n}\n\nconst MIMES = {\n  html: \"text/html\",\n  json: \"application/json\"\n};\n\nconst DISALLOWED_STATUS_CHARS = /[^\\u0009\\u0020-\\u007E]/g;\nfunction sanitizeStatusMessage(statusMessage = \"\") {\n  return statusMessage.replace(DISALLOWED_STATUS_CHARS, \"\");\n}\nfunction sanitizeStatusCode(statusCode, defaultStatusCode = 200) {\n  if (!statusCode) {\n    return defaultStatusCode;\n  }\n  if (typeof statusCode === \"string\") {\n    statusCode = Number.parseInt(statusCode, 10);\n  }\n  if (statusCode < 100 || statusCode > 999) {\n    return defaultStatusCode;\n  }\n  return statusCode;\n}\n\nfunction parseCookies(event) {\n  return parse$1(event.node.req.headers.cookie || \"\");\n}\nfunction getCookie(event, name) {\n  return parseCookies(event)[name];\n}\nfunction setCookie(event, name, value, serializeOptions) {\n  serializeOptions = { path: \"/\", ...serializeOptions };\n  const cookieStr = serialize(name, value, serializeOptions);\n  let setCookies = event.node.res.getHeader(\"set-cookie\");\n  if (!Array.isArray(setCookies)) {\n    setCookies = [setCookies];\n  }\n  const _optionsHash = objectHash(serializeOptions);\n  setCookies = setCookies.filter((cookieValue) => {\n    return cookieValue && _optionsHash !== objectHash(parse$1(cookieValue));\n  });\n  event.node.res.setHeader(\"set-cookie\", [...setCookies, cookieStr]);\n}\nfunction deleteCookie(event, name, serializeOptions) {\n  setCookie(event, name, \"\", {\n    ...serializeOptions,\n    maxAge: 0\n  });\n}\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString.flatMap((c) => splitCookiesString(c));\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n  const cookiesStrings = [];\n  let pos = 0;\n  let start;\n  let ch;\n  let lastComma;\n  let nextStart;\n  let cookiesSeparatorFound;\n  const skipWhitespace = () => {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  };\n  const notSpecialChar = () => {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  };\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          cookiesSeparatorFound = true;\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.slice(start, lastComma));\n          start = pos;\n        } else {\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.slice(start));\n    }\n  }\n  return cookiesStrings;\n}\n\nfunction serializeIterableValue(value) {\n  switch (typeof value) {\n    case \"string\": {\n      return value;\n    }\n    case \"boolean\":\n    case \"number\":\n    case \"bigint\":\n    case \"symbol\": {\n      return value.toString();\n    }\n    case \"function\":\n    case \"undefined\": {\n      return void 0;\n    }\n    case \"object\": {\n      if (value instanceof Uint8Array) {\n        return value;\n      }\n      return JSON.stringify(value);\n    }\n  }\n}\nfunction coerceIterable(iterable) {\n  if (typeof iterable === \"function\") {\n    iterable = iterable();\n  }\n  if (Symbol.iterator in iterable) {\n    return iterable[Symbol.iterator]();\n  }\n  if (Symbol.asyncIterator in iterable) {\n    return iterable[Symbol.asyncIterator]();\n  }\n  return iterable;\n}\n\nconst defer = typeof setImmediate === \"undefined\" ? (fn) => fn() : setImmediate;\nfunction send(event, data, type) {\n  if (type) {\n    defaultContentType(event, type);\n  }\n  return new Promise((resolve) => {\n    defer(() => {\n      if (!event.handled) {\n        event.node.res.end(data);\n      }\n      resolve();\n    });\n  });\n}\nfunction sendNoContent(event, code) {\n  if (event.handled) {\n    return;\n  }\n  if (!code && event.node.res.statusCode !== 200) {\n    code = event.node.res.statusCode;\n  }\n  const _code = sanitizeStatusCode(code, 204);\n  if (_code === 204) {\n    event.node.res.removeHeader(\"content-length\");\n  }\n  event.node.res.writeHead(_code);\n  event.node.res.end();\n}\nfunction setResponseStatus(event, code, text) {\n  if (code) {\n    event.node.res.statusCode = sanitizeStatusCode(\n      code,\n      event.node.res.statusCode\n    );\n  }\n  if (text) {\n    event.node.res.statusMessage = sanitizeStatusMessage(text);\n  }\n}\nfunction getResponseStatus(event) {\n  return event.node.res.statusCode;\n}\nfunction getResponseStatusText(event) {\n  return event.node.res.statusMessage;\n}\nfunction defaultContentType(event, type) {\n  if (type && event.node.res.statusCode !== 304 && !event.node.res.getHeader(\"content-type\")) {\n    event.node.res.setHeader(\"content-type\", type);\n  }\n}\nfunction sendRedirect(event, location, code = 302) {\n  event.node.res.statusCode = sanitizeStatusCode(\n    code,\n    event.node.res.statusCode\n  );\n  event.node.res.setHeader(\"location\", location);\n  const encodedLoc = location.replace(/\"/g, \"%22\");\n  const html = `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`;\n  return send(event, html, MIMES.html);\n}\nfunction getResponseHeaders(event) {\n  return event.node.res.getHeaders();\n}\nfunction getResponseHeader(event, name) {\n  return event.node.res.getHeader(name);\n}\nfunction setResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    event.node.res.setHeader(\n      name,\n      value\n    );\n  }\n}\nconst setHeaders = setResponseHeaders;\nfunction setResponseHeader(event, name, value) {\n  event.node.res.setHeader(name, value);\n}\nconst setHeader = setResponseHeader;\nfunction appendResponseHeaders(event, headers) {\n  for (const [name, value] of Object.entries(headers)) {\n    appendResponseHeader(event, name, value);\n  }\n}\nconst appendHeaders = appendResponseHeaders;\nfunction appendResponseHeader(event, name, value) {\n  let current = event.node.res.getHeader(name);\n  if (!current) {\n    event.node.res.setHeader(name, value);\n    return;\n  }\n  if (!Array.isArray(current)) {\n    current = [current.toString()];\n  }\n  event.node.res.setHeader(name, [...current, value]);\n}\nconst appendHeader = appendResponseHeader;\nfunction clearResponseHeaders(event, headerNames) {\n  if (headerNames && headerNames.length > 0) {\n    for (const name of headerNames) {\n      removeResponseHeader(event, name);\n    }\n  } else {\n    for (const [name] of Object.entries(getResponseHeaders(event))) {\n      removeResponseHeader(event, name);\n    }\n  }\n}\nfunction removeResponseHeader(event, name) {\n  return event.node.res.removeHeader(name);\n}\nfunction isStream(data) {\n  if (!data || typeof data !== \"object\") {\n    return false;\n  }\n  if (typeof data.pipe === \"function\") {\n    if (typeof data._read === \"function\") {\n      return true;\n    }\n    if (typeof data.abort === \"function\") {\n      return true;\n    }\n  }\n  if (typeof data.pipeTo === \"function\") {\n    return true;\n  }\n  return false;\n}\nfunction isWebResponse(data) {\n  return typeof Response !== \"undefined\" && data instanceof Response;\n}\nfunction sendStream(event, stream) {\n  if (!stream || typeof stream !== \"object\") {\n    throw new Error(\"[h3] Invalid stream provided.\");\n  }\n  event.node.res._data = stream;\n  if (!event.node.res.socket) {\n    event._handled = true;\n    return Promise.resolve();\n  }\n  if (hasProp(stream, \"pipeTo\") && typeof stream.pipeTo === \"function\") {\n    return stream.pipeTo(\n      new WritableStream({\n        write(chunk) {\n          event.node.res.write(chunk);\n        }\n      })\n    ).then(() => {\n      event.node.res.end();\n    });\n  }\n  if (hasProp(stream, \"pipe\") && typeof stream.pipe === \"function\") {\n    return new Promise((resolve, reject) => {\n      stream.pipe(event.node.res);\n      if (stream.on) {\n        stream.on(\"end\", () => {\n          event.node.res.end();\n          resolve();\n        });\n        stream.on(\"error\", (error) => {\n          reject(error);\n        });\n      }\n      event.node.res.on(\"close\", () => {\n        if (stream.abort) {\n          stream.abort();\n        }\n      });\n    });\n  }\n  throw new Error(\"[h3] Invalid or incompatible stream provided.\");\n}\nconst noop = () => {\n};\nfunction writeEarlyHints(event, hints, cb = noop) {\n  if (!event.node.res.socket) {\n    cb();\n    return;\n  }\n  if (typeof hints === \"string\" || Array.isArray(hints)) {\n    hints = { link: hints };\n  }\n  if (hints.link) {\n    hints.link = Array.isArray(hints.link) ? hints.link : hints.link.split(\",\");\n  }\n  const headers = Object.entries(hints).map(\n    (e) => [e[0].toLowerCase(), e[1]]\n  );\n  if (headers.length === 0) {\n    cb();\n    return;\n  }\n  let hint = \"HTTP/1.1 103 Early Hints\";\n  if (hints.link) {\n    hint += `\\r\nLink: ${hints.link.join(\", \")}`;\n  }\n  for (const [header, value] of headers) {\n    if (header === \"link\") {\n      continue;\n    }\n    hint += `\\r\n${header}: ${value}`;\n  }\n  if (event.node.res.socket) {\n    event.node.res.socket.write(\n      `${hint}\\r\n\\r\n`,\n      \"utf8\",\n      cb\n    );\n  } else {\n    cb();\n  }\n}\nfunction sendWebResponse(event, response) {\n  for (const [key, value] of response.headers) {\n    if (key === \"set-cookie\") {\n      event.node.res.appendHeader(key, splitCookiesString(value));\n    } else {\n      event.node.res.setHeader(key, value);\n    }\n  }\n  if (response.status) {\n    event.node.res.statusCode = sanitizeStatusCode(\n      response.status,\n      event.node.res.statusCode\n    );\n  }\n  if (response.statusText) {\n    event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);\n  }\n  if (response.redirected) {\n    event.node.res.setHeader(\"location\", response.url);\n  }\n  if (!response.body) {\n    event.node.res.end();\n    return;\n  }\n  return sendStream(event, response.body);\n}\nfunction sendIterable(event, iterable, options) {\n  const serializer = options?.serializer ?? serializeIterableValue;\n  const iterator = coerceIterable(iterable);\n  return sendStream(\n    event,\n    new ReadableStream({\n      async pull(controller) {\n        const { value, done } = await iterator.next();\n        if (value !== void 0) {\n          const chunk = serializer(value);\n          if (chunk !== void 0) {\n            controller.enqueue(chunk);\n          }\n        }\n        if (done) {\n          controller.close();\n        }\n      },\n      cancel() {\n        iterator.return?.();\n      }\n    })\n  );\n}\n\nfunction resolveCorsOptions(options = {}) {\n  const defaultOptions = {\n    origin: \"*\",\n    methods: \"*\",\n    allowHeaders: \"*\",\n    exposeHeaders: \"*\",\n    credentials: false,\n    maxAge: false,\n    preflight: {\n      statusCode: 204\n    }\n  };\n  return defu(options, defaultOptions);\n}\nfunction isPreflightRequest(event) {\n  const origin = getRequestHeader(event, \"origin\");\n  const accessControlRequestMethod = getRequestHeader(\n    event,\n    \"access-control-request-method\"\n  );\n  return event.method === \"OPTIONS\" && !!origin && !!accessControlRequestMethod;\n}\nfunction isCorsOriginAllowed(origin, options) {\n  const { origin: originOption } = options;\n  if (!origin || !originOption || originOption === \"*\" || originOption === \"null\") {\n    return true;\n  }\n  if (Array.isArray(originOption)) {\n    return originOption.some((_origin) => {\n      if (_origin instanceof RegExp) {\n        return _origin.test(origin);\n      }\n      return origin === _origin;\n    });\n  }\n  return originOption(origin);\n}\nfunction createOriginHeaders(event, options) {\n  const { origin: originOption } = options;\n  const origin = getRequestHeader(event, \"origin\");\n  if (!origin || !originOption || originOption === \"*\") {\n    return { \"access-control-allow-origin\": \"*\" };\n  }\n  if (typeof originOption === \"string\") {\n    return { \"access-control-allow-origin\": originOption, vary: \"origin\" };\n  }\n  return isCorsOriginAllowed(origin, options) ? { \"access-control-allow-origin\": origin, vary: \"origin\" } : {};\n}\nfunction createMethodsHeaders(options) {\n  const { methods } = options;\n  if (!methods) {\n    return {};\n  }\n  if (methods === \"*\") {\n    return { \"access-control-allow-methods\": \"*\" };\n  }\n  return methods.length > 0 ? { \"access-control-allow-methods\": methods.join(\",\") } : {};\n}\nfunction createCredentialsHeaders(options) {\n  const { credentials } = options;\n  if (credentials) {\n    return { \"access-control-allow-credentials\": \"true\" };\n  }\n  return {};\n}\nfunction createAllowHeaderHeaders(event, options) {\n  const { allowHeaders } = options;\n  if (!allowHeaders || allowHeaders === \"*\" || allowHeaders.length === 0) {\n    const header = getRequestHeader(event, \"access-control-request-headers\");\n    return header ? {\n      \"access-control-allow-headers\": header,\n      vary: \"access-control-request-headers\"\n    } : {};\n  }\n  return {\n    \"access-control-allow-headers\": allowHeaders.join(\",\"),\n    vary: \"access-control-request-headers\"\n  };\n}\nfunction createExposeHeaders(options) {\n  const { exposeHeaders } = options;\n  if (!exposeHeaders) {\n    return {};\n  }\n  if (exposeHeaders === \"*\") {\n    return { \"access-control-expose-headers\": exposeHeaders };\n  }\n  return { \"access-control-expose-headers\": exposeHeaders.join(\",\") };\n}\nfunction appendCorsPreflightHeaders(event, options) {\n  appendHeaders(event, createOriginHeaders(event, options));\n  appendHeaders(event, createCredentialsHeaders(options));\n  appendHeaders(event, createExposeHeaders(options));\n  appendHeaders(event, createMethodsHeaders(options));\n  appendHeaders(event, createAllowHeaderHeaders(event, options));\n}\nfunction appendCorsHeaders(event, options) {\n  appendHeaders(event, createOriginHeaders(event, options));\n  appendHeaders(event, createCredentialsHeaders(options));\n  appendHeaders(event, createExposeHeaders(options));\n}\n\nfunction handleCors(event, options) {\n  const _options = resolveCorsOptions(options);\n  if (isPreflightRequest(event)) {\n    appendCorsPreflightHeaders(event, options);\n    sendNoContent(event, _options.preflight.statusCode);\n    return true;\n  }\n  appendCorsHeaders(event, options);\n  return false;\n}\n\nasync function getRequestFingerprint(event, opts = {}) {\n  const fingerprint = [];\n  if (opts.ip !== false) {\n    fingerprint.push(\n      getRequestIP(event, { xForwardedFor: opts.xForwardedFor })\n    );\n  }\n  if (opts.method === true) {\n    fingerprint.push(event.method);\n  }\n  if (opts.path === true) {\n    fingerprint.push(event.path);\n  }\n  if (opts.userAgent === true) {\n    fingerprint.push(getRequestHeader(event, \"user-agent\"));\n  }\n  const fingerprintString = fingerprint.filter(Boolean).join(\"|\");\n  if (!fingerprintString) {\n    return null;\n  }\n  if (opts.hash === false) {\n    return fingerprintString;\n  }\n  const buffer = await crypto.subtle.digest(\n    opts.hash || \"SHA-1\",\n    new TextEncoder().encode(fingerprintString)\n  );\n  const hash = [...new Uint8Array(buffer)].map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hash;\n}\n\nconst PayloadMethods = /* @__PURE__ */ new Set([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"]);\nconst ignoredHeaders = /* @__PURE__ */ new Set([\n  \"transfer-encoding\",\n  \"connection\",\n  \"keep-alive\",\n  \"upgrade\",\n  \"expect\",\n  \"host\",\n  \"accept\"\n]);\nasync function proxyRequest(event, target, opts = {}) {\n  let body;\n  let duplex;\n  if (PayloadMethods.has(event.method)) {\n    if (opts.streamRequest) {\n      body = getRequestWebStream(event);\n      duplex = \"half\";\n    } else {\n      body = await readRawBody(event, false).catch(() => void 0);\n    }\n  }\n  const method = opts.fetchOptions?.method || event.method;\n  const fetchHeaders = mergeHeaders(\n    getProxyRequestHeaders(event),\n    opts.fetchOptions?.headers,\n    opts.headers\n  );\n  return sendProxy(event, target, {\n    ...opts,\n    fetchOptions: {\n      method,\n      body,\n      duplex,\n      ...opts.fetchOptions,\n      headers: fetchHeaders\n    }\n  });\n}\nasync function sendProxy(event, target, opts = {}) {\n  let response;\n  try {\n    response = await _getFetch(opts.fetch)(target, {\n      headers: opts.headers,\n      ignoreResponseError: true,\n      // make $ofetch.raw transparent\n      ...opts.fetchOptions\n    });\n  } catch (error) {\n    throw createError({\n      status: 502,\n      statusMessage: \"Bad Gateway\",\n      cause: error\n    });\n  }\n  event.node.res.statusCode = sanitizeStatusCode(\n    response.status,\n    event.node.res.statusCode\n  );\n  event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);\n  const cookies = [];\n  for (const [key, value] of response.headers.entries()) {\n    if (key === \"content-encoding\") {\n      continue;\n    }\n    if (key === \"content-length\") {\n      continue;\n    }\n    if (key === \"set-cookie\") {\n      cookies.push(...splitCookiesString(value));\n      continue;\n    }\n    event.node.res.setHeader(key, value);\n  }\n  if (cookies.length > 0) {\n    event.node.res.setHeader(\n      \"set-cookie\",\n      cookies.map((cookie) => {\n        if (opts.cookieDomainRewrite) {\n          cookie = rewriteCookieProperty(\n            cookie,\n            opts.cookieDomainRewrite,\n            \"domain\"\n          );\n        }\n        if (opts.cookiePathRewrite) {\n          cookie = rewriteCookieProperty(\n            cookie,\n            opts.cookiePathRewrite,\n            \"path\"\n          );\n        }\n        return cookie;\n      })\n    );\n  }\n  if (opts.onResponse) {\n    await opts.onResponse(event, response);\n  }\n  if (response._data !== void 0) {\n    return response._data;\n  }\n  if (event.handled) {\n    return;\n  }\n  if (opts.sendStream === false) {\n    const data = new Uint8Array(await response.arrayBuffer());\n    return event.node.res.end(data);\n  }\n  if (response.body) {\n    for await (const chunk of response.body) {\n      event.node.res.write(chunk);\n    }\n  }\n  return event.node.res.end();\n}\nfunction getProxyRequestHeaders(event) {\n  const headers = /* @__PURE__ */ Object.create(null);\n  const reqHeaders = getRequestHeaders(event);\n  for (const name in reqHeaders) {\n    if (!ignoredHeaders.has(name)) {\n      headers[name] = reqHeaders[name];\n    }\n  }\n  return headers;\n}\nfunction fetchWithEvent(event, req, init, options) {\n  return _getFetch(options?.fetch)(req, {\n    ...init,\n    context: init?.context || event.context,\n    headers: {\n      ...getProxyRequestHeaders(event),\n      ...init?.headers\n    }\n  });\n}\nfunction _getFetch(_fetch) {\n  if (_fetch) {\n    return _fetch;\n  }\n  if (globalThis.fetch) {\n    return globalThis.fetch;\n  }\n  throw new Error(\n    \"fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js.\"\n  );\n}\nfunction rewriteCookieProperty(header, map, property) {\n  const _map = typeof map === \"string\" ? { \"*\": map } : map;\n  return header.replace(\n    new RegExp(`(;\\\\s*${property}=)([^;]+)`, \"gi\"),\n    (match, prefix, previousValue) => {\n      let newValue;\n      if (previousValue in _map) {\n        newValue = _map[previousValue];\n      } else if (\"*\" in _map) {\n        newValue = _map[\"*\"];\n      } else {\n        return match;\n      }\n      return newValue ? prefix + newValue : \"\";\n    }\n  );\n}\nfunction mergeHeaders(defaults, ...inputs) {\n  const _inputs = inputs.filter(Boolean);\n  if (_inputs.length === 0) {\n    return defaults;\n  }\n  const merged = new Headers(defaults);\n  for (const input of _inputs) {\n    for (const [key, value] of Object.entries(input)) {\n      if (value !== void 0) {\n        merged.set(key, value);\n      }\n    }\n  }\n  return merged;\n}\n\nconst getSessionPromise = Symbol(\"getSession\");\nconst DEFAULT_NAME = \"h3\";\nconst DEFAULT_COOKIE = {\n  path: \"/\",\n  secure: true,\n  httpOnly: true\n};\nasync function useSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  await getSession(event, config);\n  const sessionManager = {\n    get id() {\n      return event.context.sessions?.[sessionName]?.id;\n    },\n    get data() {\n      return event.context.sessions?.[sessionName]?.data || {};\n    },\n    update: async (update) => {\n      await updateSession(event, config, update);\n      return sessionManager;\n    },\n    clear: () => {\n      clearSession(event, config);\n      return Promise.resolve(sessionManager);\n    }\n  };\n  return sessionManager;\n}\nasync function getSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  if (!event.context.sessions) {\n    event.context.sessions = /* @__PURE__ */ Object.create(null);\n  }\n  const existingSession = event.context.sessions[sessionName];\n  if (existingSession) {\n    return existingSession[getSessionPromise] || existingSession;\n  }\n  const session = {\n    id: \"\",\n    createdAt: 0,\n    data: /* @__PURE__ */ Object.create(null)\n  };\n  event.context.sessions[sessionName] = session;\n  let sealedSession;\n  if (config.sessionHeader !== false) {\n    const headerName = typeof config.sessionHeader === \"string\" ? config.sessionHeader.toLowerCase() : `x-${sessionName.toLowerCase()}-session`;\n    const headerValue = event.node.req.headers[headerName];\n    if (typeof headerValue === \"string\") {\n      sealedSession = headerValue;\n    }\n  }\n  if (!sealedSession) {\n    sealedSession = getCookie(event, sessionName);\n  }\n  if (sealedSession) {\n    const promise = unsealSession(event, config, sealedSession).catch(() => {\n    }).then((unsealed) => {\n      Object.assign(session, unsealed);\n      delete event.context.sessions[sessionName][getSessionPromise];\n      return session;\n    });\n    event.context.sessions[sessionName][getSessionPromise] = promise;\n    await promise;\n  }\n  if (!session.id) {\n    session.id = config.generateId?.() ?? (config.crypto || crypto).randomUUID();\n    session.createdAt = Date.now();\n    await updateSession(event, config);\n  }\n  return session;\n}\nasync function updateSession(event, config, update) {\n  const sessionName = config.name || DEFAULT_NAME;\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\n  if (typeof update === \"function\") {\n    update = update(session.data);\n  }\n  if (update) {\n    Object.assign(session.data, update);\n  }\n  if (config.cookie !== false) {\n    const sealed = await sealSession(event, config);\n    setCookie(event, sessionName, sealed, {\n      ...DEFAULT_COOKIE,\n      expires: config.maxAge ? new Date(session.createdAt + config.maxAge * 1e3) : void 0,\n      ...config.cookie\n    });\n  }\n  return session;\n}\nasync function sealSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\n  const sealed = await seal(config.crypto || crypto, session, config.password, {\n    ...defaults,\n    ttl: config.maxAge ? config.maxAge * 1e3 : 0,\n    ...config.seal\n  });\n  return sealed;\n}\nasync function unsealSession(_event, config, sealed) {\n  const unsealed = await unseal(\n    config.crypto || crypto,\n    sealed,\n    config.password,\n    {\n      ...defaults,\n      ttl: config.maxAge ? config.maxAge * 1e3 : 0,\n      ...config.seal\n    }\n  );\n  if (config.maxAge) {\n    const age = Date.now() - (unsealed.createdAt || Number.NEGATIVE_INFINITY);\n    if (age > config.maxAge * 1e3) {\n      throw new Error(\"Session expired!\");\n    }\n  }\n  return unsealed;\n}\nfunction clearSession(event, config) {\n  const sessionName = config.name || DEFAULT_NAME;\n  if (event.context.sessions?.[sessionName]) {\n    delete event.context.sessions[sessionName];\n  }\n  setCookie(event, sessionName, \"\", {\n    ...DEFAULT_COOKIE,\n    ...config.cookie\n  });\n  return Promise.resolve();\n}\n\nfunction formatEventStreamMessage(message) {\n  let result = \"\";\n  if (message.id) {\n    result += `id: ${message.id}\n`;\n  }\n  if (message.event) {\n    result += `event: ${message.event}\n`;\n  }\n  if (typeof message.retry === \"number\" && Number.isInteger(message.retry)) {\n    result += `retry: ${message.retry}\n`;\n  }\n  result += `data: ${message.data}\n\n`;\n  return result;\n}\nfunction formatEventStreamMessages(messages) {\n  let result = \"\";\n  for (const msg of messages) {\n    result += formatEventStreamMessage(msg);\n  }\n  return result;\n}\nfunction setEventStreamHeaders(event) {\n  const headers = {\n    \"Content-Type\": \"text/event-stream\",\n    \"Cache-Control\": \"private, no-cache, no-store, no-transform, must-revalidate, max-age=0\",\n    \"X-Accel-Buffering\": \"no\"\n    // prevent nginx from buffering the response\n  };\n  if (!isHttp2Request(event)) {\n    headers.Connection = \"keep-alive\";\n  }\n  setResponseHeaders(event, headers);\n}\nfunction isHttp2Request(event) {\n  return getHeader(event, \":path\") !== void 0 && getHeader(event, \":method\") !== void 0;\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass EventStream {\n  constructor(event, opts = {}) {\n    __publicField$1(this, \"_h3Event\");\n    __publicField$1(this, \"_transformStream\", new TransformStream());\n    __publicField$1(this, \"_writer\");\n    __publicField$1(this, \"_encoder\", new TextEncoder());\n    __publicField$1(this, \"_writerIsClosed\", false);\n    __publicField$1(this, \"_paused\", false);\n    __publicField$1(this, \"_unsentData\");\n    __publicField$1(this, \"_disposed\", false);\n    __publicField$1(this, \"_handled\", false);\n    this._h3Event = event;\n    this._writer = this._transformStream.writable.getWriter();\n    this._writer.closed.then(() => {\n      this._writerIsClosed = true;\n    });\n    if (opts.autoclose !== false) {\n      this._h3Event.node.req.on(\"close\", () => this.close());\n    }\n  }\n  async push(message) {\n    if (typeof message === \"string\") {\n      await this._sendEvent({ data: message });\n      return;\n    }\n    if (Array.isArray(message)) {\n      if (message.length === 0) {\n        return;\n      }\n      if (typeof message[0] === \"string\") {\n        const msgs = [];\n        for (const item of message) {\n          msgs.push({ data: item });\n        }\n        await this._sendEvents(msgs);\n        return;\n      }\n      await this._sendEvents(message);\n      return;\n    }\n    await this._sendEvent(message);\n  }\n  async _sendEvent(message) {\n    if (this._writerIsClosed) {\n      return;\n    }\n    if (this._paused && !this._unsentData) {\n      this._unsentData = formatEventStreamMessage(message);\n      return;\n    }\n    if (this._paused) {\n      this._unsentData += formatEventStreamMessage(message);\n      return;\n    }\n    await this._writer.write(this._encoder.encode(formatEventStreamMessage(message))).catch();\n  }\n  async _sendEvents(messages) {\n    if (this._writerIsClosed) {\n      return;\n    }\n    const payload = formatEventStreamMessages(messages);\n    if (this._paused && !this._unsentData) {\n      this._unsentData = payload;\n      return;\n    }\n    if (this._paused) {\n      this._unsentData += payload;\n      return;\n    }\n    await this._writer.write(this._encoder.encode(payload)).catch();\n  }\n  pause() {\n    this._paused = true;\n  }\n  get isPaused() {\n    return this._paused;\n  }\n  async resume() {\n    this._paused = false;\n    await this.flush();\n  }\n  async flush() {\n    if (this._writerIsClosed) {\n      return;\n    }\n    if (this._unsentData?.length) {\n      await this._writer.write(this._encoder.encode(this._unsentData));\n      this._unsentData = void 0;\n    }\n  }\n  /**\n   * Close the stream and the connection if the stream is being sent to the client\n   */\n  async close() {\n    if (this._disposed) {\n      return;\n    }\n    if (!this._writerIsClosed) {\n      try {\n        await this._writer.close();\n      } catch {\n      }\n    }\n    if (this._h3Event._handled && this._handled && !this._h3Event.node.res.closed) {\n      this._h3Event.node.res.end();\n    }\n    this._disposed = true;\n  }\n  /**\n   * Triggers callback when the writable stream is closed.\n   * It is also triggered after calling the `close()` method.\n   */\n  onClosed(cb) {\n    this._writer.closed.then(cb);\n  }\n  async send() {\n    setEventStreamHeaders(this._h3Event);\n    setResponseStatus(this._h3Event, 200);\n    this._h3Event._handled = true;\n    this._handled = true;\n    await sendStream(this._h3Event, this._transformStream.readable);\n  }\n}\n\nfunction createEventStream(event, opts) {\n  return new EventStream(event, opts);\n}\n\nasync function serveStatic(event, options) {\n  if (event.method !== \"GET\" && event.method !== \"HEAD\") {\n    if (!options.fallthrough) {\n      throw createError({\n        statusMessage: \"Method Not Allowed\",\n        statusCode: 405\n      });\n    }\n    return false;\n  }\n  const originalId = decodePath(\n    withLeadingSlash(withoutTrailingSlash(parseURL(event.path).pathname))\n  );\n  const acceptEncodings = parseAcceptEncoding(\n    getRequestHeader(event, \"accept-encoding\"),\n    options.encodings\n  );\n  if (acceptEncodings.length > 1) {\n    setResponseHeader(event, \"vary\", \"accept-encoding\");\n  }\n  let id = originalId;\n  let meta;\n  const _ids = idSearchPaths(\n    originalId,\n    acceptEncodings,\n    options.indexNames || [\"/index.html\"]\n  );\n  for (const _id of _ids) {\n    const _meta = await options.getMeta(_id);\n    if (_meta) {\n      meta = _meta;\n      id = _id;\n      break;\n    }\n  }\n  if (!meta) {\n    if (!options.fallthrough) {\n      throw createError({\n        statusMessage: \"Cannot find static asset \" + id,\n        statusCode: 404\n      });\n    }\n    return false;\n  }\n  if (meta.etag && !getResponseHeader(event, \"etag\")) {\n    setResponseHeader(event, \"etag\", meta.etag);\n  }\n  const ifNotMatch = meta.etag && getRequestHeader(event, \"if-none-match\") === meta.etag;\n  if (ifNotMatch) {\n    setResponseStatus(event, 304, \"Not Modified\");\n    return send(event, \"\");\n  }\n  if (meta.mtime) {\n    const mtimeDate = new Date(meta.mtime);\n    const ifModifiedSinceH = getRequestHeader(event, \"if-modified-since\");\n    if (ifModifiedSinceH && new Date(ifModifiedSinceH) >= mtimeDate) {\n      setResponseStatus(event, 304, \"Not Modified\");\n      return send(event, null);\n    }\n    if (!getResponseHeader(event, \"last-modified\")) {\n      setResponseHeader(event, \"last-modified\", mtimeDate.toUTCString());\n    }\n  }\n  if (meta.type && !getResponseHeader(event, \"content-type\")) {\n    setResponseHeader(event, \"content-type\", meta.type);\n  }\n  if (meta.encoding && !getResponseHeader(event, \"content-encoding\")) {\n    setResponseHeader(event, \"content-encoding\", meta.encoding);\n  }\n  if (meta.size !== void 0 && meta.size > 0 && !getResponseHeader(event, \"content-length\")) {\n    setResponseHeader(event, \"content-length\", meta.size);\n  }\n  if (event.method === \"HEAD\") {\n    return send(event, null);\n  }\n  const contents = await options.getContents(id);\n  return isStream(contents) ? sendStream(event, contents) : send(event, contents);\n}\nfunction parseAcceptEncoding(header, encodingMap) {\n  if (!encodingMap || !header) {\n    return [];\n  }\n  return String(header || \"\").split(\",\").map((e) => encodingMap[e.trim()]).filter(Boolean);\n}\nfunction idSearchPaths(id, encodings, indexNames) {\n  const ids = [];\n  for (const suffix of [\"\", ...indexNames]) {\n    for (const encoding of [...encodings, \"\"]) {\n      ids.push(`${id}${suffix}${encoding}`);\n    }\n  }\n  return ids;\n}\n\nfunction defineWebSocket(hooks) {\n  return hooks;\n}\nfunction defineWebSocketHandler(hooks) {\n  return defineEventHandler({\n    handler() {\n      throw createError({\n        statusCode: 426,\n        statusMessage: \"Upgrade Required\"\n      });\n    },\n    websocket: hooks\n  });\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass H3Event {\n  constructor(req, res) {\n    __publicField(this, \"__is_event__\", true);\n    // Context\n    __publicField(this, \"node\");\n    // Node\n    __publicField(this, \"web\");\n    // Web\n    __publicField(this, \"context\", {});\n    // Shared\n    // Request\n    __publicField(this, \"_method\");\n    __publicField(this, \"_path\");\n    __publicField(this, \"_headers\");\n    __publicField(this, \"_requestBody\");\n    // Response\n    __publicField(this, \"_handled\", false);\n    // Hooks\n    __publicField(this, \"_onBeforeResponseCalled\");\n    __publicField(this, \"_onAfterResponseCalled\");\n    this.node = { req, res };\n  }\n  // --- Request ---\n  get method() {\n    if (!this._method) {\n      this._method = (this.node.req.method || \"GET\").toUpperCase();\n    }\n    return this._method;\n  }\n  get path() {\n    return this._path || this.node.req.url || \"/\";\n  }\n  get headers() {\n    if (!this._headers) {\n      this._headers = _normalizeNodeHeaders(this.node.req.headers);\n    }\n    return this._headers;\n  }\n  // --- Respoonse ---\n  get handled() {\n    return this._handled || this.node.res.writableEnded || this.node.res.headersSent;\n  }\n  respondWith(response) {\n    return Promise.resolve(response).then(\n      (_response) => sendWebResponse(this, _response)\n    );\n  }\n  // --- Utils ---\n  toString() {\n    return `[${this.method}] ${this.path}`;\n  }\n  toJSON() {\n    return this.toString();\n  }\n  // --- Deprecated ---\n  /** @deprecated Please use `event.node.req` instead. */\n  get req() {\n    return this.node.req;\n  }\n  /** @deprecated Please use `event.node.res` instead. */\n  get res() {\n    return this.node.res;\n  }\n}\nfunction isEvent(input) {\n  return hasProp(input, \"__is_event__\");\n}\nfunction createEvent(req, res) {\n  return new H3Event(req, res);\n}\nfunction _normalizeNodeHeaders(nodeHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of Object.entries(nodeHeaders)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        headers.append(name, item);\n      }\n    } else if (value) {\n      headers.set(name, value);\n    }\n  }\n  return headers;\n}\n\nfunction defineEventHandler(handler) {\n  if (typeof handler === \"function\") {\n    handler.__is_handler__ = true;\n    return handler;\n  }\n  const _hooks = {\n    onRequest: _normalizeArray(handler.onRequest),\n    onBeforeResponse: _normalizeArray(handler.onBeforeResponse)\n  };\n  const _handler = (event) => {\n    return _callHandler(event, handler.handler, _hooks);\n  };\n  _handler.__is_handler__ = true;\n  _handler.__resolve__ = handler.handler.__resolve__;\n  _handler.__websocket__ = handler.websocket;\n  return _handler;\n}\nfunction _normalizeArray(input) {\n  return input ? Array.isArray(input) ? input : [input] : void 0;\n}\nasync function _callHandler(event, handler, hooks) {\n  if (hooks.onRequest) {\n    for (const hook of hooks.onRequest) {\n      await hook(event);\n      if (event.handled) {\n        return;\n      }\n    }\n  }\n  const body = await handler(event);\n  const response = { body };\n  if (hooks.onBeforeResponse) {\n    for (const hook of hooks.onBeforeResponse) {\n      await hook(event, response);\n    }\n  }\n  return response.body;\n}\nconst eventHandler = defineEventHandler;\nfunction defineRequestMiddleware(fn) {\n  return fn;\n}\nfunction defineResponseMiddleware(fn) {\n  return fn;\n}\nfunction isEventHandler(input) {\n  return hasProp(input, \"__is_handler__\");\n}\nfunction toEventHandler(input, _, _route) {\n  if (!isEventHandler(input)) {\n    console.warn(\n      \"[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.\",\n      _route && _route !== \"/\" ? `\n     Route: ${_route}` : \"\",\n      `\n     Handler: ${input}`\n    );\n  }\n  return input;\n}\nfunction dynamicEventHandler(initial) {\n  let current = initial;\n  const wrapper = eventHandler((event) => {\n    if (current) {\n      return current(event);\n    }\n  });\n  wrapper.set = (handler) => {\n    current = handler;\n  };\n  return wrapper;\n}\nfunction defineLazyEventHandler(factory) {\n  let _promise;\n  let _resolved;\n  const resolveHandler = () => {\n    if (_resolved) {\n      return Promise.resolve(_resolved);\n    }\n    if (!_promise) {\n      _promise = Promise.resolve(factory()).then((r) => {\n        const handler2 = r.default || r;\n        if (typeof handler2 !== \"function\") {\n          throw new TypeError(\n            \"Invalid lazy handler result. It should be a function:\",\n            handler2\n          );\n        }\n        _resolved = { handler: toEventHandler(r.default || r) };\n        return _resolved;\n      });\n    }\n    return _promise;\n  };\n  const handler = eventHandler((event) => {\n    if (_resolved) {\n      return _resolved.handler(event);\n    }\n    return resolveHandler().then((r) => r.handler(event));\n  });\n  handler.__resolve__ = resolveHandler;\n  return handler;\n}\nconst lazyEventHandler = defineLazyEventHandler;\n\nconst H3Headers = globalThis.Headers;\nconst H3Response = globalThis.Response;\n\nfunction createApp(options = {}) {\n  const stack = [];\n  const handler = createAppEventHandler(stack, options);\n  const resolve = createResolver(stack);\n  handler.__resolve__ = resolve;\n  const getWebsocket = cachedFn(() => websocketOptions(resolve, options));\n  const app = {\n    // @ts-expect-error\n    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),\n    resolve,\n    handler,\n    stack,\n    options,\n    get websocket() {\n      return getWebsocket();\n    }\n  };\n  return app;\n}\nfunction use(app, arg1, arg2, arg3) {\n  if (Array.isArray(arg1)) {\n    for (const i of arg1) {\n      use(app, i, arg2, arg3);\n    }\n  } else if (Array.isArray(arg2)) {\n    for (const i of arg2) {\n      use(app, arg1, i, arg3);\n    }\n  } else if (typeof arg1 === \"string\") {\n    app.stack.push(\n      normalizeLayer({ ...arg3, route: arg1, handler: arg2 })\n    );\n  } else if (typeof arg1 === \"function\") {\n    app.stack.push(normalizeLayer({ ...arg2, handler: arg1 }));\n  } else {\n    app.stack.push(normalizeLayer({ ...arg1 }));\n  }\n  return app;\n}\nfunction createAppEventHandler(stack, options) {\n  const spacing = options.debug ? 2 : void 0;\n  return eventHandler(async (event) => {\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\n    const _reqPath = event._path || event.node.req.url || \"/\";\n    let _layerPath;\n    if (options.onRequest) {\n      await options.onRequest(event);\n    }\n    for (const layer of stack) {\n      if (layer.route.length > 1) {\n        if (!_reqPath.startsWith(layer.route)) {\n          continue;\n        }\n        _layerPath = _reqPath.slice(layer.route.length) || \"/\";\n      } else {\n        _layerPath = _reqPath;\n      }\n      if (layer.match && !layer.match(_layerPath, event)) {\n        continue;\n      }\n      event._path = _layerPath;\n      event.node.req.url = _layerPath;\n      const val = await layer.handler(event);\n      const _body = val === void 0 ? void 0 : await val;\n      if (_body !== void 0) {\n        const _response = { body: _body };\n        if (options.onBeforeResponse) {\n          event._onBeforeResponseCalled = true;\n          await options.onBeforeResponse(event, _response);\n        }\n        await handleHandlerResponse(event, _response.body, spacing);\n        if (options.onAfterResponse) {\n          event._onAfterResponseCalled = true;\n          await options.onAfterResponse(event, _response);\n        }\n        return;\n      }\n      if (event.handled) {\n        if (options.onAfterResponse) {\n          event._onAfterResponseCalled = true;\n          await options.onAfterResponse(event, void 0);\n        }\n        return;\n      }\n    }\n    if (!event.handled) {\n      throw createError({\n        statusCode: 404,\n        statusMessage: `Cannot find any path matching ${event.path || \"/\"}.`\n      });\n    }\n    if (options.onAfterResponse) {\n      event._onAfterResponseCalled = true;\n      await options.onAfterResponse(event, void 0);\n    }\n  });\n}\nfunction createResolver(stack) {\n  return async (path) => {\n    let _layerPath;\n    for (const layer of stack) {\n      if (layer.route === \"/\" && !layer.handler.__resolve__) {\n        continue;\n      }\n      if (!path.startsWith(layer.route)) {\n        continue;\n      }\n      _layerPath = path.slice(layer.route.length) || \"/\";\n      if (layer.match && !layer.match(_layerPath, void 0)) {\n        continue;\n      }\n      let res = { route: layer.route, handler: layer.handler };\n      if (res.handler.__resolve__) {\n        const _res = await res.handler.__resolve__(_layerPath);\n        if (!_res) {\n          continue;\n        }\n        res = {\n          ...res,\n          ..._res,\n          route: joinURL(res.route || \"/\", _res.route || \"/\")\n        };\n      }\n      return res;\n    }\n  };\n}\nfunction normalizeLayer(input) {\n  let handler = input.handler;\n  if (handler.handler) {\n    handler = handler.handler;\n  }\n  if (input.lazy) {\n    handler = lazyEventHandler(handler);\n  } else if (!isEventHandler(handler)) {\n    handler = toEventHandler(handler, void 0, input.route);\n  }\n  return {\n    route: withoutTrailingSlash(input.route),\n    match: input.match,\n    handler\n  };\n}\nfunction handleHandlerResponse(event, val, jsonSpace) {\n  if (val === null) {\n    return sendNoContent(event);\n  }\n  if (val) {\n    if (isWebResponse(val)) {\n      return sendWebResponse(event, val);\n    }\n    if (isStream(val)) {\n      return sendStream(event, val);\n    }\n    if (val.buffer) {\n      return send(event, val);\n    }\n    if (val.arrayBuffer && typeof val.arrayBuffer === \"function\") {\n      return val.arrayBuffer().then((arrayBuffer) => {\n        return send(event, Buffer.from(arrayBuffer), val.type);\n      });\n    }\n    if (val instanceof Error) {\n      throw createError(val);\n    }\n    if (typeof val.end === \"function\") {\n      return true;\n    }\n  }\n  const valType = typeof val;\n  if (valType === \"string\") {\n    return send(event, val, MIMES.html);\n  }\n  if (valType === \"object\" || valType === \"boolean\" || valType === \"number\") {\n    return send(event, JSON.stringify(val, void 0, jsonSpace), MIMES.json);\n  }\n  if (valType === \"bigint\") {\n    return send(event, val.toString(), MIMES.json);\n  }\n  throw createError({\n    statusCode: 500,\n    statusMessage: `[h3] Cannot send ${valType} as response.`\n  });\n}\nfunction cachedFn(fn) {\n  let cache;\n  return () => {\n    if (!cache) {\n      cache = fn();\n    }\n    return cache;\n  };\n}\nfunction websocketOptions(evResolver, appOptions) {\n  return {\n    ...appOptions.websocket,\n    async resolve(info) {\n      const url = info.request?.url || info.url || \"/\";\n      const { pathname } = typeof url === \"string\" ? parseURL(url) : url;\n      const resolved = await evResolver(pathname);\n      return resolved?.handler?.__websocket__ || {};\n    }\n  };\n}\n\nconst RouterMethods = [\n  \"connect\",\n  \"delete\",\n  \"get\",\n  \"head\",\n  \"options\",\n  \"post\",\n  \"put\",\n  \"trace\",\n  \"patch\"\n];\nfunction createRouter(opts = {}) {\n  const _router = createRouter$1({});\n  const routes = {};\n  let _matcher;\n  const router = {};\n  const addRoute = (path, handler, method) => {\n    let route = routes[path];\n    if (!route) {\n      routes[path] = route = { path, handlers: {} };\n      _router.insert(path, route);\n    }\n    if (Array.isArray(method)) {\n      for (const m of method) {\n        addRoute(path, handler, m);\n      }\n    } else {\n      route.handlers[method] = toEventHandler(handler, void 0, path);\n    }\n    return router;\n  };\n  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || \"all\");\n  for (const method of RouterMethods) {\n    router[method] = (path, handle) => router.add(path, handle, method);\n  }\n  const matchHandler = (path = \"/\", method = \"get\") => {\n    const qIndex = path.indexOf(\"?\");\n    if (qIndex !== -1) {\n      path = path.slice(0, Math.max(0, qIndex));\n    }\n    const matched = _router.lookup(path);\n    if (!matched || !matched.handlers) {\n      return {\n        error: createError({\n          statusCode: 404,\n          name: \"Not Found\",\n          statusMessage: `Cannot find any route matching ${path || \"/\"}.`\n        })\n      };\n    }\n    let handler = matched.handlers[method] || matched.handlers.all;\n    if (!handler) {\n      if (!_matcher) {\n        _matcher = toRouteMatcher(_router);\n      }\n      const _matches = _matcher.matchAll(path).reverse();\n      for (const _match of _matches) {\n        if (_match.handlers[method]) {\n          handler = _match.handlers[method];\n          matched.handlers[method] = matched.handlers[method] || handler;\n          break;\n        }\n        if (_match.handlers.all) {\n          handler = _match.handlers.all;\n          matched.handlers.all = matched.handlers.all || handler;\n          break;\n        }\n      }\n    }\n    if (!handler) {\n      return {\n        error: createError({\n          statusCode: 405,\n          name: \"Method Not Allowed\",\n          statusMessage: `Method ${method} is not allowed on this route.`\n        })\n      };\n    }\n    return { matched, handler };\n  };\n  const isPreemptive = opts.preemptive || opts.preemtive;\n  router.handler = eventHandler((event) => {\n    const match = matchHandler(\n      event.path,\n      event.method.toLowerCase()\n    );\n    if (\"error\" in match) {\n      if (isPreemptive) {\n        throw match.error;\n      } else {\n        return;\n      }\n    }\n    event.context.matchedRoute = match.matched;\n    const params = match.matched.params || {};\n    event.context.params = params;\n    return Promise.resolve(match.handler(event)).then((res) => {\n      if (res === void 0 && isPreemptive) {\n        return null;\n      }\n      return res;\n    });\n  });\n  router.handler.__resolve__ = async (path) => {\n    path = withLeadingSlash(path);\n    const match = matchHandler(path);\n    if (\"error\" in match) {\n      return;\n    }\n    let res = {\n      route: match.matched.path,\n      handler: match.handler\n    };\n    if (match.handler.__resolve__) {\n      const _res = await match.handler.__resolve__(path);\n      if (!_res) {\n        return;\n      }\n      res = { ...res, ..._res };\n    }\n    return res;\n  };\n  return router;\n}\n\nconst defineNodeListener = (handler) => handler;\nconst defineNodeMiddleware = (middleware) => middleware;\nfunction fromNodeMiddleware(handler) {\n  if (isEventHandler(handler)) {\n    return handler;\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\n      \"Invalid handler. It should be a function:\",\n      handler\n    );\n  }\n  return eventHandler((event) => {\n    return callNodeListener(\n      handler,\n      event.node.req,\n      event.node.res\n    );\n  });\n}\nfunction toNodeListener(app) {\n  const toNodeHandle = async function(req, res) {\n    const event = createEvent(req, res);\n    try {\n      await app.handler(event);\n    } catch (_error) {\n      const error = createError(_error);\n      if (!isError(_error)) {\n        error.unhandled = true;\n      }\n      setResponseStatus(event, error.statusCode, error.statusMessage);\n      if (app.options.onError) {\n        await app.options.onError(error, event);\n      }\n      if (event.handled) {\n        return;\n      }\n      if (error.unhandled || error.fatal) {\n        console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n      }\n      if (app.options.onBeforeResponse && !event._onBeforeResponseCalled) {\n        await app.options.onBeforeResponse(event, { body: error });\n      }\n      await sendError(event, error, !!app.options.debug);\n      if (app.options.onAfterResponse && !event._onAfterResponseCalled) {\n        await app.options.onAfterResponse(event, { body: error });\n      }\n    }\n  };\n  return toNodeHandle;\n}\nfunction promisifyNodeListener(handler) {\n  return function(req, res) {\n    return callNodeListener(handler, req, res);\n  };\n}\nfunction callNodeListener(handler, req, res) {\n  const isMiddleware = handler.length > 2;\n  return new Promise((resolve, reject) => {\n    const next = (err) => {\n      if (isMiddleware) {\n        res.off(\"close\", next);\n        res.off(\"error\", next);\n      }\n      return err ? reject(createError(err)) : resolve(void 0);\n    };\n    try {\n      const returned = handler(req, res, next);\n      if (isMiddleware && returned === void 0) {\n        res.once(\"close\", next);\n        res.once(\"error\", next);\n      } else {\n        resolve(returned);\n      }\n    } catch (error) {\n      next(error);\n    }\n  });\n}\n\nfunction toPlainHandler(app) {\n  const handler = (request) => {\n    return _handlePlainRequest(app, request);\n  };\n  return handler;\n}\nfunction fromPlainHandler(handler) {\n  return eventHandler(async (event) => {\n    const res = await handler({\n      method: event.method,\n      path: event.path,\n      headers: Object.fromEntries(event.headers.entries()),\n      body: getRequestWebStream(event),\n      context: event.context\n    });\n    setResponseStatus(event, res.status, res.statusText);\n    for (const [key, value] of res.headers) {\n      setResponseHeader(event, key, value);\n    }\n    return res.body;\n  });\n}\nasync function _handlePlainRequest(app, request) {\n  const path = request.path;\n  const method = (request.method || \"GET\").toUpperCase();\n  const headers = new Headers(request.headers);\n  const nodeReq = new IncomingMessage();\n  const nodeRes = new ServerResponse(nodeReq);\n  nodeReq.method = method;\n  nodeReq.url = path;\n  nodeReq.headers = Object.fromEntries(headers.entries());\n  const event = createEvent(nodeReq, nodeRes);\n  event._method = method;\n  event._path = path;\n  event._headers = headers;\n  if (request.body) {\n    event._requestBody = request.body;\n  }\n  if (request._eventOverrides) {\n    Object.assign(event, request._eventOverrides);\n  }\n  if (request.context) {\n    Object.assign(event.context, request.context);\n  }\n  try {\n    await app.handler(event);\n  } catch (_error) {\n    const error = createError(_error);\n    if (!isError(_error)) {\n      error.unhandled = true;\n    }\n    if (app.options.onError) {\n      await app.options.onError(error, event);\n    }\n    if (!event.handled) {\n      if (error.unhandled || error.fatal) {\n        console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\n      }\n      await sendError(event, error, !!app.options.debug);\n    }\n  }\n  return {\n    status: nodeRes.statusCode,\n    statusText: nodeRes.statusMessage,\n    headers: _normalizeUnenvHeaders(nodeRes._headers),\n    body: nodeRes._data\n  };\n}\nfunction _normalizeUnenvHeaders(input) {\n  const headers = [];\n  const cookies = [];\n  for (const _key in input) {\n    const key = _key.toLowerCase();\n    if (key === \"set-cookie\") {\n      cookies.push(\n        ...splitCookiesString(input[\"set-cookie\"])\n      );\n      continue;\n    }\n    const value = input[key];\n    if (Array.isArray(value)) {\n      for (const _value of value) {\n        headers.push([key, _value]);\n      }\n    } else if (value !== void 0) {\n      headers.push([key, String(value)]);\n    }\n  }\n  if (cookies.length > 0) {\n    for (const cookie of cookies) {\n      headers.push([\"set-cookie\", cookie]);\n    }\n  }\n  return headers;\n}\n\nfunction toWebHandler(app) {\n  const webHandler = (request, context) => {\n    return _handleWebRequest(app, request, context);\n  };\n  return webHandler;\n}\nfunction fromWebHandler(handler) {\n  return eventHandler((event) => handler(toWebRequest(event), event.context));\n}\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\nasync function _handleWebRequest(app, request, context) {\n  const url = new URL(request.url);\n  const res = await _handlePlainRequest(app, {\n    _eventOverrides: {\n      web: { request, url }\n    },\n    context,\n    method: request.method,\n    path: url.pathname + url.search,\n    headers: request.headers,\n    body: request.body\n  });\n  const body = nullBodyResponses.has(res.status) || request.method === \"HEAD\" ? null : res.body;\n  return new Response(body, {\n    status: res.status,\n    statusText: res.statusText,\n    headers: res.headers\n  });\n}\n\nexport { H3Error, H3Event, H3Headers, H3Response, MIMES, appendCorsHeaders, appendCorsPreflightHeaders, appendHeader, appendHeaders, appendResponseHeader, appendResponseHeaders, assertMethod, callNodeListener, clearResponseHeaders, clearSession, createApp, createAppEventHandler, createError, createEvent, createEventStream, createRouter, defaultContentType, defineEventHandler, defineLazyEventHandler, defineNodeListener, defineNodeMiddleware, defineRequestMiddleware, defineResponseMiddleware, defineWebSocket, defineWebSocketHandler, deleteCookie, dynamicEventHandler, eventHandler, fetchWithEvent, fromNodeMiddleware, fromPlainHandler, fromWebHandler, getCookie, getHeader, getHeaders, getMethod, getProxyRequestHeaders, getQuery, getRequestFingerprint, getRequestHeader, getRequestHeaders, getRequestHost, getRequestIP, getRequestPath, getRequestProtocol, getRequestURL, getRequestWebStream, getResponseHeader, getResponseHeaders, getResponseStatus, getResponseStatusText, getRouterParam, getRouterParams, getSession, getValidatedQuery, getValidatedRouterParams, handleCacheHeaders, handleCors, isCorsOriginAllowed, isError, isEvent, isEventHandler, isMethod, isPreflightRequest, isStream, isWebResponse, lazyEventHandler, parseCookies, promisifyNodeListener, proxyRequest, readBody, readFormData, readMultipartFormData, readRawBody, readValidatedBody, removeResponseHeader, sanitizeStatusCode, sanitizeStatusMessage, sealSession, send, sendError, sendIterable, sendNoContent, sendProxy, sendRedirect, sendStream, sendWebResponse, serveStatic, setCookie, setHeader, setHeaders, setResponseHeader, setResponseHeaders, setResponseStatus, splitCookiesString, toEventHandler, toNodeListener, toPlainHandler, toWebHandler, toWebRequest, unsealSession, updateSession, use, useBase, useSession, writeEarlyHints };\n", "function createContext(opts = {}) {\n  let currentInstance;\n  let isSingleton = false;\n  const checkConflict = (instance) => {\n    if (currentInstance && currentInstance !== instance) {\n      throw new Error(\"Context conflict\");\n    }\n  };\n  let als;\n  if (opts.asyncContext) {\n    const _AsyncLocalStorage = opts.AsyncLocalStorage || globalThis.AsyncLocalStorage;\n    if (_AsyncLocalStorage) {\n      als = new _AsyncLocalStorage();\n    } else {\n      console.warn(\"[unctx] `AsyncLocalStorage` is not provided.\");\n    }\n  }\n  const _getCurrentInstance = () => {\n    if (als) {\n      const instance = als.getStore();\n      if (instance !== void 0) {\n        return instance;\n      }\n    }\n    return currentInstance;\n  };\n  return {\n    use: () => {\n      const _instance = _getCurrentInstance();\n      if (_instance === void 0) {\n        throw new Error(\"Context is not available\");\n      }\n      return _instance;\n    },\n    tryUse: () => {\n      return _getCurrentInstance();\n    },\n    set: (instance, replace) => {\n      if (!replace) {\n        checkConflict(instance);\n      }\n      currentInstance = instance;\n      isSingleton = true;\n    },\n    unset: () => {\n      currentInstance = void 0;\n      isSingleton = false;\n    },\n    call: (instance, callback) => {\n      checkConflict(instance);\n      currentInstance = instance;\n      try {\n        return als ? als.run(instance, callback) : callback();\n      } finally {\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n      }\n    },\n    async callAsync(instance, callback) {\n      currentInstance = instance;\n      const onRestore = () => {\n        currentInstance = instance;\n      };\n      const onLeave = () => currentInstance === instance ? onRestore : void 0;\n      asyncHandlers.add(onLeave);\n      try {\n        const r = als ? als.run(instance, callback) : callback();\n        if (!isSingleton) {\n          currentInstance = void 0;\n        }\n        return await r;\n      } finally {\n        asyncHandlers.delete(onLeave);\n      }\n    }\n  };\n}\nfunction createNamespace(defaultOpts = {}) {\n  const contexts = {};\n  return {\n    get(key, opts = {}) {\n      if (!contexts[key]) {\n        contexts[key] = createContext({ ...defaultOpts, ...opts });\n      }\n      return contexts[key];\n    }\n  };\n}\nconst _globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : {};\nconst globalKey = \"__unctx__\";\nconst defaultNamespace = _globalThis[globalKey] || (_globalThis[globalKey] = createNamespace());\nconst getContext = (key, opts = {}) => defaultNamespace.get(key, opts);\nconst useContext = (key, opts = {}) => getContext(key, opts).use;\nconst asyncHandlersKey = \"__unctx_async_handlers__\";\nconst asyncHandlers = _globalThis[asyncHandlersKey] || (_globalThis[asyncHandlersKey] = /* @__PURE__ */ new Set());\nfunction executeAsync(function_) {\n  const restores = [];\n  for (const leaveHandler of asyncHandlers) {\n    const restore2 = leaveHandler();\n    if (restore2) {\n      restores.push(restore2);\n    }\n  }\n  const restore = () => {\n    for (const restore2 of restores) {\n      restore2();\n    }\n  };\n  let awaitable = function_();\n  if (awaitable && typeof awaitable === \"object\" && \"catch\" in awaitable) {\n    awaitable = awaitable.catch((error) => {\n      restore();\n      throw error;\n    });\n  }\n  return [awaitable, restore];\n}\nfunction withAsyncContext(function_, transformed) {\n  if (!transformed) {\n    console.warn(\n      \"[unctx] `withAsyncContext` needs transformation for async context support in\",\n      function_,\n      \"\\n\",\n      function_.toString()\n    );\n  }\n  return function_;\n}\n\nexport { createContext, createNamespace, defaultNamespace, executeAsync, getContext, useContext, withAsyncContext };\n", "import { AsyncLocalStorage } from 'node:async_hooks'\nimport {\n  H3Event,\n  appendCorsHeaders as _appendCorsHeaders,\n  appendCorsPreflightHeaders as _appendCorsPreflightHeaders,\n  appendHeader as _appendHeader,\n  appendHeaders as _appendHeaders,\n  appendResponseHeader as _appendResponseHeader,\n  appendResponseHeaders as _appendResponseHeaders,\n  assertMethod as _assertMethod,\n  clearResponseHeaders as _clearResponseHeaders,\n  clearSession as _clearSession,\n  defaultContentType as _defaultContentType,\n  deleteCookie as _deleteCookie,\n  fetchWithEvent as _fetchWithEvent,\n  getCookie as _getCookie,\n  getHeader as _getHeader,\n  getHeaders as _getHeaders,\n  getProxyRequestHeaders as _getProxyRequestHeaders,\n  getQuery as _getQuery,\n  getRequestFingerprint as _getRequestFingerprint,\n  getRequestHeader as _getRequestHeader,\n  getRequestHeaders as _getRequestHeaders,\n  getRequestHost as _getRequestHost,\n  getRequestIP as _getRequestIP,\n  getRequestProtocol as _getRequestProtocol,\n  getRequestURL as _getRequestURL,\n  getRequestWebStream as _getRequestWebStream,\n  getResponseHeader as _getResponseHeader,\n  getResponseHeaders as _getResponseHeaders,\n  getResponseStatus as _getResponseStatus,\n  getResponseStatusText as _getResponseStatusText,\n  getRouterParam as _getRouterParam,\n  getRouterParams as _getRouterParams,\n  getSession as _getSession,\n  getValidatedQuery as _getValidatedQuery,\n  getValidatedRouterParams as _getValidatedRouterParams,\n  handleCacheHeaders as _handleCacheHeaders,\n  handleCors as _handleCors,\n  isMethod as _isMethod,\n  isPreflightRequest as _isPreflightRequest,\n  parseCookies as _parseCookies,\n  proxyRequest as _proxyRequest,\n  readBody as _readBody,\n  readFormData as _readFormData,\n  readMultipartFormData as _readMultipartFormData,\n  readRawBody as _readRawBody,\n  readValidatedBody as _readValidatedBody,\n  removeResponseHeader as _removeResponseHeader,\n  sealSession as _sealSession,\n  send as _send,\n  sendError as _sendError,\n  sendNoContent as _sendNoContent,\n  sendProxy as _sendProxy,\n  sendRedirect as _sendRedirect,\n  sendStream as _sendStream,\n  sendWebResponse as _sendWebResponse,\n  setCookie as _setCookie,\n  setHeader as _setHeader,\n  setHeaders as _setHeaders,\n  setResponseHeader as _setResponseHeader,\n  setResponseHeaders as _setResponseHeaders,\n  setResponseStatus as _setResponseStatus,\n  unsealSession as _unsealSession,\n  updateSession as _updateSession,\n  useSession as _useSession,\n  writeEarlyHints as _writeEarlyHints,\n} from 'h3'\nimport { getContext as getUnctxContext } from 'unctx'\nimport type {\n  Encoding,\n  HTTPHeaderName,\n  InferEventInput,\n  _RequestMiddleware,\n  _ResponseMiddleware,\n} from 'h3'\n\nfunction _setContext(event: H3Event, key: string, value: any) {\n  event.context[key] = value\n}\n\nfunction _getContext(event: H3Event, key: string) {\n  return event.context[key]\n}\n\nexport function defineMiddleware(options: {\n  onRequest?: _RequestMiddleware | Array<_RequestMiddleware>\n  onBeforeResponse?: _ResponseMiddleware | Array<_ResponseMiddleware>\n}) {\n  return options\n}\n\nfunction toWebRequestH3(event: H3Event) {\n  /**\n   * @type {ReadableStream | undefined}\n   */\n  let readableStream: ReadableStream | undefined\n\n  const url = getRequestURL(event)\n  const base = {\n    // @ts-ignore Undici option\n    duplex: 'half',\n    method: event.method,\n    headers: event.headers,\n  }\n\n  if ((event.node.req as any).body instanceof ArrayBuffer) {\n    return new Request(url, {\n      ...base,\n      body: (event.node.req as any).body,\n    })\n  }\n\n  return new Request(url, {\n    ...base,\n    get body() {\n      if (readableStream) {\n        return readableStream\n      }\n      readableStream = getRequestWebStream(event)\n      return readableStream\n    },\n  })\n}\n\nexport function toWebRequest(event: H3Event) {\n  event.web ??= {\n    request: toWebRequestH3(event),\n    url: getRequestURL(event),\n  }\n  return event.web.request\n}\n\nexport {\n  H3Error,\n  H3Event,\n  MIMES,\n  callNodeListener,\n  createApp,\n  createAppEventHandler,\n  createEvent,\n  createRouter,\n  defineEventHandler,\n  defineLazyEventHandler,\n  defineNodeListener,\n  defineNodeMiddleware,\n  defineRequestMiddleware,\n  defineResponseMiddleware,\n  dynamicEventHandler,\n  defineWebSocket,\n  eventHandler,\n  splitCookiesString,\n  fromNodeMiddleware,\n  fromPlainHandler,\n  fromWebHandler,\n  isError,\n  isEventHandler,\n  isWebResponse,\n  lazyEventHandler,\n  promisifyNodeListener,\n  serveStatic,\n  toEventHandler,\n  toNodeListener,\n  toPlainHandler,\n  toWebHandler,\n  isCorsOriginAllowed,\n  isStream,\n  createError,\n  sanitizeStatusCode,\n  sanitizeStatusMessage,\n  useBase,\n  type AddRouteShortcuts,\n  type App,\n  type AppOptions,\n  type AppUse,\n  type CacheConditions,\n  type CreateRouterOptions,\n  type Duplex,\n  type DynamicEventHandler,\n  type Encoding,\n  type EventHandler,\n  type EventHandlerObject,\n  type EventHandlerRequest,\n  type EventHandlerResponse,\n  type H3CorsOptions,\n  type H3EventContext,\n  type HTTPHeaderName,\n  type HTTPMethod,\n  type InferEventInput,\n  type InputLayer,\n  type InputStack,\n  type Layer,\n  type LazyEventHandler,\n  type Matcher,\n  type MultiPartData,\n  type NodeEventContext,\n  type NodeListener,\n  type NodeMiddleware,\n  type NodePromisifiedHandler,\n  type PlainHandler,\n  type PlainRequest,\n  type PlainResponse,\n  type ProxyOptions,\n  type RequestFingerprintOptions,\n  type RequestHeaders,\n  type RouteNode,\n  type Router,\n  type RouterMethod,\n  type RouterUse,\n  type ServeStaticOptions,\n  type Session,\n  type SessionConfig,\n  type SessionData,\n  type Stack,\n  type StaticAssetMeta,\n  type ValidateFunction,\n  type ValidateResult,\n  type WebEventContext,\n  type WebHandler,\n  type _RequestMiddleware,\n  type _ResponseMiddleware,\n} from 'h3'\n\nfunction getHTTPEvent() {\n  return getEvent()\n}\n\nexport const HTTPEventSymbol = Symbol('$HTTPEvent')\n\nexport function isEvent(\n  obj: any,\n): obj is H3Event | { [HTTPEventSymbol]: H3Event } {\n  return (\n    typeof obj === 'object' &&\n    (obj instanceof H3Event ||\n      obj?.[HTTPEventSymbol] instanceof H3Event ||\n      obj?.__is_event__ === true)\n  )\n  // Implement logic to check if obj is an H3Event\n}\n\ntype Tail<T> = T extends [any, ...infer U] ? U : never\n\ntype PrependOverload<\n  TOriginal extends (...args: Array<any>) => any,\n  TOverload extends (...args: Array<any>) => any,\n> = TOverload & TOriginal\n\n// add an overload to the function without the event argument\ntype WrapFunction<TFn extends (...args: Array<any>) => any> = PrependOverload<\n  TFn,\n  (\n    ...args: Parameters<TFn> extends [H3Event, ...infer TArgs]\n      ? TArgs\n      : Parameters<TFn>\n  ) => ReturnType<TFn>\n>\n\nfunction createWrapperFunction<TFn extends (...args: Array<any>) => any>(\n  h3Function: TFn,\n): WrapFunction<TFn> {\n  return function (...args: Array<any>) {\n    const event = args[0]\n    if (!isEvent(event)) {\n      if (!(globalThis as any).app.config.server.experimental?.asyncContext) {\n        throw new Error(\n          'AsyncLocalStorage was not enabled. Use the `server.experimental.asyncContext: true` option in your app configuration to enable it. Or, pass the instance of HTTPEvent that you have as the first argument to the function.',\n        )\n      }\n      args.unshift(getHTTPEvent())\n    } else {\n      args[0] =\n        event instanceof H3Event || (event as any).__is_event__\n          ? event\n          : event[HTTPEventSymbol]\n    }\n\n    return (h3Function as any)(...args)\n  } as any\n}\n\n// Creating wrappers for each utility and exporting them with their original names\ntype WrappedReadRawBody = <TEncoding extends Encoding = 'utf8'>(\n  ...args: Tail<Parameters<typeof _readRawBody<TEncoding>>>\n) => ReturnType<typeof _readRawBody<TEncoding>>\nexport const readRawBody: PrependOverload<\n  typeof _readRawBody,\n  WrappedReadRawBody\n> = createWrapperFunction(_readRawBody)\ntype WrappedReadBody = <T, TEventInput = InferEventInput<'body', H3Event, T>>(\n  ...args: Tail<Parameters<typeof _readBody<T, H3Event, TEventInput>>>\n) => ReturnType<typeof _readBody<T, H3Event, TEventInput>>\nexport const readBody: PrependOverload<typeof _readBody, WrappedReadBody> =\n  createWrapperFunction(_readBody)\ntype WrappedGetQuery = <\n  T,\n  TEventInput = Exclude<InferEventInput<'query', H3Event, T>, undefined>,\n>(\n  ...args: Tail<Parameters<typeof _getQuery<T, H3Event, TEventInput>>>\n) => ReturnType<typeof _getQuery<T, H3Event, TEventInput>>\nexport const getQuery: PrependOverload<typeof _getQuery, WrappedGetQuery> =\n  createWrapperFunction(_getQuery)\nexport const isMethod = createWrapperFunction(_isMethod)\nexport const isPreflightRequest = createWrapperFunction(_isPreflightRequest)\ntype WrappedGetValidatedQuery = <\n  T,\n  TEventInput = InferEventInput<'query', H3Event, T>,\n>(\n  ...args: Tail<Parameters<typeof _getValidatedQuery<T, H3Event, TEventInput>>>\n) => ReturnType<typeof _getValidatedQuery<T, H3Event, TEventInput>>\nexport const getValidatedQuery: PrependOverload<\n  typeof _getValidatedQuery,\n  WrappedGetValidatedQuery\n> = createWrapperFunction(_getValidatedQuery)\nexport const getRouterParams = createWrapperFunction(_getRouterParams)\nexport const getRouterParam = createWrapperFunction(_getRouterParam)\ntype WrappedGetValidatedRouterParams = <\n  T,\n  TEventInput = InferEventInput<'routerParams', H3Event, T>,\n>(\n  ...args: Tail<\n    Parameters<typeof _getValidatedRouterParams<T, H3Event, TEventInput>>\n  >\n) => ReturnType<typeof _getValidatedRouterParams<T, H3Event, TEventInput>>\nexport const getValidatedRouterParams: PrependOverload<\n  typeof _getValidatedRouterParams,\n  WrappedGetValidatedRouterParams\n> = createWrapperFunction(_getValidatedRouterParams)\nexport const assertMethod = createWrapperFunction(_assertMethod)\nexport const getRequestHeaders = createWrapperFunction(_getRequestHeaders)\nexport const getRequestHeader = createWrapperFunction(_getRequestHeader)\nexport const getRequestURL = createWrapperFunction(_getRequestURL)\nexport const getRequestHost = createWrapperFunction(_getRequestHost)\nexport const getRequestProtocol = createWrapperFunction(_getRequestProtocol)\nexport const getRequestIP = createWrapperFunction(_getRequestIP)\nexport const send = createWrapperFunction(_send)\nexport const sendNoContent = createWrapperFunction(_sendNoContent)\nexport const setResponseStatus = createWrapperFunction(_setResponseStatus)\nexport const getResponseStatus = createWrapperFunction(_getResponseStatus)\nexport const getResponseStatusText = createWrapperFunction(\n  _getResponseStatusText,\n)\nexport const getResponseHeaders = createWrapperFunction(_getResponseHeaders)\nexport const getResponseHeader = createWrapperFunction(_getResponseHeader)\nexport const setResponseHeaders = createWrapperFunction(_setResponseHeaders)\ntype WrappedSetResponseHeader = <T extends HTTPHeaderName>(\n  ...args: Tail<Parameters<typeof _setResponseHeader<T>>>\n) => ReturnType<typeof _setResponseHeader<T>>\nexport const setResponseHeader: PrependOverload<\n  typeof _setResponseHeader,\n  WrappedSetResponseHeader\n> = createWrapperFunction(_setResponseHeader)\nexport const appendResponseHeaders = createWrapperFunction(\n  _appendResponseHeaders,\n)\ntype WrappedAppendResponseHeader = <T extends HTTPHeaderName>(\n  ...args: Tail<Parameters<typeof _appendResponseHeader<T>>>\n) => ReturnType<typeof _appendResponseHeader<T>>\nexport const appendResponseHeader: PrependOverload<\n  typeof _appendResponseHeader,\n  WrappedAppendResponseHeader\n> = createWrapperFunction(_appendResponseHeader)\nexport const defaultContentType = createWrapperFunction(_defaultContentType)\nexport const sendRedirect = createWrapperFunction(_sendRedirect)\nexport const sendStream = createWrapperFunction(_sendStream)\nexport const writeEarlyHints = createWrapperFunction(_writeEarlyHints)\nexport const sendError = createWrapperFunction(_sendError)\nexport const sendProxy = createWrapperFunction(_sendProxy)\nexport const proxyRequest = createWrapperFunction(_proxyRequest)\ntype WrappedFetchWithEvent = <\n  T = unknown,\n  TResponse = any,\n  TFetch extends (req: RequestInfo | URL, opts?: any) => any = typeof fetch,\n>(\n  ...args: Tail<Parameters<typeof _fetchWithEvent<T, TResponse, TFetch>>>\n) => ReturnType<typeof _fetchWithEvent<T, TResponse, TFetch>>\nexport const fetchWithEvent: PrependOverload<\n  typeof _fetchWithEvent,\n  WrappedFetchWithEvent\n> = createWrapperFunction(_fetchWithEvent)\nexport const getProxyRequestHeaders = createWrapperFunction(\n  _getProxyRequestHeaders,\n)\n\nexport const parseCookies = createWrapperFunction(_parseCookies)\nexport const getCookie = createWrapperFunction(_getCookie)\nexport const setCookie = createWrapperFunction(_setCookie)\nexport const deleteCookie = createWrapperFunction(_deleteCookie)\n// not exported :(\ntype SessionDataT = Record<string, any>\ntype WrappedUseSession = <T extends SessionDataT>(\n  ...args: Tail<Parameters<typeof _useSession<T>>>\n) => ReturnType<typeof _useSession<T>>\n// we need to `as` these because the WrapFunction doesn't work for them\n// because they also accept CompatEvent instead of H3Event\nexport const useSession = createWrapperFunction(_useSession) as PrependOverload<\n  typeof _useSession,\n  WrappedUseSession\n>\ntype WrappedGetSession = <T extends SessionDataT>(\n  ...args: Tail<Parameters<typeof _getSession<T>>>\n) => ReturnType<typeof _getSession<T>>\nexport const getSession = createWrapperFunction(_getSession) as PrependOverload<\n  typeof _getSession,\n  WrappedGetSession\n>\ntype WrappedUpdateSession = <T extends SessionDataT>(\n  ...args: Tail<Parameters<typeof _updateSession<T>>>\n) => ReturnType<typeof _updateSession<T>>\nexport const updateSession: PrependOverload<\n  typeof _updateSession,\n  WrappedUpdateSession\n> = createWrapperFunction(_updateSession)\ntype WrappedSealSession = <T extends SessionDataT>(\n  ...args: Tail<Parameters<typeof _sealSession<T>>>\n) => ReturnType<typeof _sealSession<T>>\nexport const sealSession = createWrapperFunction(\n  _sealSession,\n) as PrependOverload<typeof _sealSession, WrappedSealSession>\nexport const unsealSession = createWrapperFunction(_unsealSession)\nexport const clearSession = createWrapperFunction(_clearSession)\nexport const handleCacheHeaders = createWrapperFunction(_handleCacheHeaders)\nexport const handleCors = createWrapperFunction(_handleCors)\nexport const appendCorsHeaders = createWrapperFunction(_appendCorsHeaders)\nexport const appendCorsPreflightHeaders = createWrapperFunction(\n  _appendCorsPreflightHeaders,\n)\nexport const sendWebResponse = createWrapperFunction(_sendWebResponse)\ntype WrappedAppendHeader = <T extends HTTPHeaderName>(\n  ...args: Tail<Parameters<typeof _appendHeader<T>>>\n) => ReturnType<typeof _appendHeader<T>>\nexport const appendHeader: PrependOverload<\n  typeof _appendHeader,\n  WrappedAppendHeader\n> = createWrapperFunction(_appendHeader)\nexport const appendHeaders = createWrapperFunction(_appendHeaders)\ntype WrappedSetHeader = <T extends HTTPHeaderName>(\n  ...args: Tail<Parameters<typeof _setHeader<T>>>\n) => ReturnType<typeof _setHeader<T>>\nexport const setHeader: PrependOverload<typeof _setHeader, WrappedSetHeader> =\n  createWrapperFunction(_setHeader)\nexport const setHeaders = createWrapperFunction(_setHeaders)\nexport const getHeader = createWrapperFunction(_getHeader)\nexport const getHeaders = createWrapperFunction(_getHeaders)\nexport const getRequestFingerprint = createWrapperFunction(\n  _getRequestFingerprint,\n)\nexport const getRequestWebStream = createWrapperFunction(_getRequestWebStream)\nexport const readFormData = createWrapperFunction(_readFormData)\nexport const readMultipartFormData = createWrapperFunction(\n  _readMultipartFormData,\n)\ntype WrappedReadValidatedBody = <\n  T,\n  TEventInput = InferEventInput<'body', H3Event, T>,\n>(\n  ...args: Tail<Parameters<typeof _readValidatedBody<T, H3Event, TEventInput>>>\n) => ReturnType<typeof _readValidatedBody<T, H3Event, TEventInput>>\nexport const readValidatedBody: PrependOverload<\n  typeof _readValidatedBody,\n  WrappedReadValidatedBody\n> = createWrapperFunction(_readValidatedBody)\nexport const removeResponseHeader = createWrapperFunction(_removeResponseHeader)\nexport const getContext = createWrapperFunction(_getContext)\nexport const setContext = createWrapperFunction(_setContext)\n\nexport const clearResponseHeaders = createWrapperFunction(_clearResponseHeaders)\n\nexport const getWebRequest = createWrapperFunction(toWebRequest)\n\nexport { createApp as createServer } from 'h3'\n\nfunction getNitroAsyncContext() {\n  const nitroAsyncContext = getUnctxContext('nitro-app', {\n    asyncContext: (globalThis as any).app.config.server.experimental\n      ?.asyncContext\n      ? true\n      : false,\n    AsyncLocalStorage,\n  })\n\n  return nitroAsyncContext\n}\n\nexport function getEvent() {\n  const event = (getNitroAsyncContext().use() as any).event as\n    | H3Event\n    | undefined\n  if (!event) {\n    throw new Error(\n      `No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.`,\n    )\n  }\n  return event\n}\n\nexport async function handleHTTPEvent(event: H3Event) {\n  return await (globalThis as any).$handle(event)\n}\n", "/// <reference types=\"node\" />\nimport { serverFnFetcher } from '@tanstack/start-server-functions-fetcher'\nimport { mergeHeaders } from '@tanstack/start-client-core'\nimport { getEvent, getHeaders } from '@tanstack/start-server-core'\nimport type { CreateRpcFn } from '@tanstack/server-functions-plugin'\n\nfunction sanitizeBase(base: string) {\n  return base.replace(/^\\/|\\/$/g, '')\n}\n\nexport const createSsrRpc: CreateRpcFn = (functionId, serverBase) => {\n  const url = `/${sanitizeBase(serverBase)}/${functionId}`\n\n  const ssrFn = (...args: Array<any>) => {\n    return serverFnFetcher(url, args, async (url, requestInit) => {\n      // pass on the headers from the document request to the server function fetch\n      requestInit.headers = mergeHeaders(getHeaders(), requestInit.headers)\n      // @ts-expect-error The $fetch.native method is not typed yet\n      const res: Response = await $fetch.native(url, requestInit)\n      const event = getEvent()\n      const mergedHeaders = mergeHeaders(\n        res.headers,\n        (event as any).___ssrRpcResponseHeaders,\n      )\n\n      // any response headers set in the server function need to be set on the document response\n      // we attach the headers to the event so we can later set them\n      ;(event as any).___ssrRpcResponseHeaders = mergedHeaders\n      return res\n    })\n  }\n\n  return Object.assign(ssrFn, {\n    url,\n    functionId,\n  })\n}\n"],
  "mappings": "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",
  "names": ["response", "fn", "isPlainObject", "defaults", "defaults", "_crypto", "fn", "fn", "EventEmitter", "EventEmitter", "fn", "Readable", "EventEmitter", "Readable", "Readable", "parse", "process", "fn", "getQuery", "request", "parse", "fn", "mergeHeaders", "defaults", "__publicField", "r", "getRequestURL", "getRequestWebStream", "toWebRequest", "readRawBody", "_readRawBody", "readBody", "_readBody", "getQuery", "_getQuery", "isMethod", "_isMethod", "isPreflightRequest", "_isPreflightRequest", "getValidatedQuery", "_getValidatedQuery", "getRouterParams", "_getRouterParams", "getRouterParam", "_getRouterParam", "getValidatedRouterParams", "_getValidatedRouterParams", "assertMethod", "_assertMethod", "getRequestHeaders", "_getRequestHeaders", "getRequestHeader", "_getRequestHeader", "_getRequestURL", "getRequestHost", "_getRequestHost", "getRequestProtocol", "_getRequestProtocol", "getRequestIP", "_getRequestIP", "send", "_send", "sendNoContent", "_sendNoContent", "setResponseStatus", "_setResponseStatus", "getResponseStatus", "_getResponseStatus", "getResponseStatusText", "_getResponseStatusText", "getResponseHeaders", "_getResponseHeaders", "getResponseHeader", "_getResponseHeader", "setResponseHeaders", "_setResponseHeaders", "setResponseHeader", "_setResponseHeader", "appendResponseHeaders", "_appendResponseHeaders", "appendResponseHeader", "_appendResponseHeader", "defaultContentType", "_defaultContentType", "sendRedirect", "_sendRedirect", "sendStream", "_sendStream", "writeEarlyHints", "_writeEarlyHints", "sendError", "_sendError", "sendProxy", "_sendProxy", "proxyRequest", "_proxyRequest", "fetchWithEvent", "_fetchWithEvent", "getProxyRequestHeaders", "_getProxyRequestHeaders", "parseCookies", "_parseCookies", "getCookie", "_getCookie", "setCookie", "_setCookie", "deleteCookie", "_deleteCookie", "useSession", "_useSession", "getSession", "_getSession", "updateSession", "_updateSession", "sealSession", "_sealSession", "unsealSession", "_unsealSession", "clearSession", "_clearSession", "handleCacheHeaders", "_handleCacheHeaders", "handleCors", "_handleCors", "appendCorsHeaders", "_appendCorsHeaders", "appendCorsPreflightHeaders", "_appendCorsPreflightHeaders", "sendWebResponse", "_sendWebResponse", "appendHeader", "_appendHeader", "appendHeaders", "_appendHeaders", "setHeader", "_setHeader", "setHeaders", "_setHeaders", "getHeader", "_getHeader", "getHeaders", "_getHeaders", "getRequestFingerprint", "_getRequestFingerprint", "_getRequestWebStream", "readFormData", "_readFormData", "readMultipartFormData", "_readMultipartFormData", "readValidatedBody", "_readValidatedBody", "removeResponseHeader", "_removeResponseHeader", "getContext", "clearResponseHeaders", "_clearResponseHeaders", "getUnctxContext", "url", "getHeaders"]
}
