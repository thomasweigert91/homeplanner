{
  "version": 3,
  "sources": ["../../../../convex/src/react-clerk/ConvexProviderWithClerk.tsx", "../../../../convex/src/react/ConvexAuthState.tsx", "../../../../convex/src/values/base64.ts", "../../../../convex/src/values/value.ts", "../../../../convex/src/values/errors.ts", "../../../../convex/src/server/functionName.ts", "../../../../convex/src/server/components/paths.ts", "../../../../convex/src/server/api.ts", "../../../../convex/src/browser/long.ts", "../../../../jwt-decode/build/esm/index.js", "../../../../convex/src/browser/sync/authentication_manager.ts", "../../../../convex/src/react/client.ts", "../../../../convex/src/react/use_queries.ts", "../../../../convex/src/react/use_subscription.ts"],
  "sourcesContent": ["import React from \"react\";\n\nimport { ReactNode, useCallback, useMemo } from \"react\";\nimport { AuthTokenFetcher } from \"../browser/sync/client.js\";\nimport { ConvexProviderWithAuth } from \"../react/ConvexAuthState.js\";\n\n// Until we can import from our own entry points (requires TypeScript 4.7),\n// just describe the interface enough to help users pass the right type.\ntype IConvexReactClient = {\n  setAuth(fetchToken: AuthTokenFetcher): void;\n  clearAuth(): void;\n};\n\n// https://clerk.com/docs/reference/clerk-react/useauth\ntype UseAuth = () => {\n  isLoaded: boolean;\n  isSignedIn: boolean | undefined;\n  getToken: (options: {\n    template?: \"convex\";\n    skipCache?: boolean;\n  }) => Promise<string | null>;\n  // We don't use these properties but they should trigger a new token fetch.\n  orgId: string | undefined | null;\n  orgRole: string | undefined | null;\n};\n\n/**\n * A wrapper React component which provides a {@link react.ConvexReactClient}\n * authenticated with Clerk.\n *\n * It must be wrapped by a configured `ClerkProvider`, from\n * `@clerk/clerk-react`, `@clerk/clerk-expo`, `@clerk/nextjs` or\n * another React-based Clerk client library and have the corresponding\n * `useAuth` hook passed in.\n *\n * See [Convex Clerk](https://docs.convex.dev/auth/clerk) on how to set up\n * Convex with Clerk.\n *\n * @public\n */\nexport function ConvexProviderWithClerk({\n  children,\n  client,\n  useAuth,\n}: {\n  children: ReactNode;\n  client: IConvexReactClient;\n  useAuth: UseAuth; // useAuth from Clerk\n}) {\n  const useAuthFromClerk = useUseAuthFromClerk(useAuth);\n  return (\n    <ConvexProviderWithAuth client={client} useAuth={useAuthFromClerk}>\n      {children}\n    </ConvexProviderWithAuth>\n  );\n}\n\nfunction useUseAuthFromClerk(useAuth: UseAuth) {\n  return useMemo(\n    () =>\n      function useAuthFromClerk() {\n        const { isLoaded, isSignedIn, getToken, orgId, orgRole } = useAuth();\n        const fetchAccessToken = useCallback(\n          async ({ forceRefreshToken }: { forceRefreshToken: boolean }) => {\n            try {\n              return getToken({\n                template: \"convex\",\n                skipCache: forceRefreshToken,\n              });\n            } catch {\n              return null;\n            }\n          },\n          // Build a new fetchAccessToken to trigger setAuth() whenever these change.\n          // Anything else from the JWT Clerk wants to be reactive goes here too.\n          // Clerk's Expo useAuth hook is not memoized so we don't include getToken.\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          [orgId, orgRole],\n        );\n        return useMemo(\n          () => ({\n            isLoading: !isLoaded,\n            isAuthenticated: isSignedIn ?? false,\n            fetchAccessToken,\n          }),\n          [isLoaded, isSignedIn, fetchAccessToken],\n        );\n      },\n    [useAuth],\n  );\n}\n", "import React, {\n  createContext,\n  ReactNode,\n  useContext,\n  useEffect,\n  useState,\n} from \"react\";\nimport { AuthTokenFetcher } from \"../browser/sync/client.js\";\nimport { ConvexProvider } from \"./client.js\";\n\n// Until we can import from our own entry points (requires TypeScript 4.7),\n// just describe the interface enough to help users pass the right type.\ntype IConvexReactClient = {\n  setAuth(\n    fetchToken: AuthTokenFetcher,\n    onChange: (isAuthenticated: boolean) => void,\n  ): void;\n  clearAuth(): void;\n};\n\n/**\n * Type representing the state of an auth integration with Convex.\n *\n * @public\n */\nexport type ConvexAuthState = {\n  isLoading: boolean;\n  isAuthenticated: boolean;\n};\n\nconst ConvexAuthContext = createContext<ConvexAuthState>(undefined as any);\n\n/**\n * Get the {@link ConvexAuthState} within a React component.\n *\n * This relies on a Convex auth integration provider being above in the React\n * component tree.\n *\n * @returns The current {@link ConvexAuthState}.\n *\n * @public\n */\nexport function useConvexAuth(): {\n  isLoading: boolean;\n  isAuthenticated: boolean;\n} {\n  const authContext = useContext(ConvexAuthContext);\n  if (authContext === undefined) {\n    throw new Error(\n      \"Could not find `ConvexProviderWithAuth` (or `ConvexProviderWithClerk` \" +\n        \"or `ConvexProviderWithAuth0`) \" +\n        \"as an ancestor component. This component may be missing, or you \" +\n        \"might have two instances of the `convex/react` module loaded in your \" +\n        \"project.\",\n    );\n  }\n  return authContext;\n}\n\n/**\n * A replacement for {@link ConvexProvider} which additionally provides\n * {@link ConvexAuthState} to descendants of this component.\n *\n * Use this to integrate any auth provider with Convex. The `useAuth` prop\n * should be a React hook that returns the provider's authentication state\n * and a function to fetch a JWT access token.\n *\n * If the `useAuth` prop function updates causing a rerender then auth state\n * wil transition to loading and the `fetchAccessToken()` function called again.\n *\n * See [Custom Auth Integration](https://docs.convex.dev/auth/advanced/custom-auth) for more information.\n *\n * @public\n */\nexport function ConvexProviderWithAuth({\n  children,\n  client,\n  useAuth,\n}: {\n  children?: ReactNode;\n  client: IConvexReactClient;\n  useAuth: () => {\n    isLoading: boolean;\n    isAuthenticated: boolean;\n    fetchAccessToken: (args: {\n      forceRefreshToken: boolean;\n    }) => Promise<string | null>;\n  };\n}) {\n  const {\n    isLoading: authProviderLoading,\n    isAuthenticated: authProviderAuthenticated,\n    fetchAccessToken,\n  } = useAuth();\n  const [isConvexAuthenticated, setIsConvexAuthenticated] = useState<\n    boolean | null\n  >(null);\n\n  // If the useAuth went back to the authProviderLoading state (which is unusual but possible)\n  // reset the Convex auth state to null so that we can correctly\n  // transition the state from \"loading\" to \"authenticated\"\n  // without going through \"unauthenticated\".\n  if (authProviderLoading && isConvexAuthenticated !== null) {\n    setIsConvexAuthenticated(null);\n  }\n\n  // If the useAuth goes to not authenticated then isConvexAuthenticated should reflect that.\n  if (\n    !authProviderLoading &&\n    !authProviderAuthenticated &&\n    isConvexAuthenticated !== false\n  ) {\n    setIsConvexAuthenticated(false);\n  }\n\n  return (\n    <ConvexAuthContext.Provider\n      value={{\n        isLoading: isConvexAuthenticated === null,\n        isAuthenticated:\n          authProviderAuthenticated && (isConvexAuthenticated ?? false),\n      }}\n    >\n      <ConvexAuthStateFirstEffect\n        authProviderAuthenticated={authProviderAuthenticated}\n        fetchAccessToken={fetchAccessToken}\n        authProviderLoading={authProviderLoading}\n        client={client}\n        setIsConvexAuthenticated={setIsConvexAuthenticated}\n      />\n      <ConvexProvider client={client as any}>{children}</ConvexProvider>\n      <ConvexAuthStateLastEffect\n        authProviderAuthenticated={authProviderAuthenticated}\n        fetchAccessToken={fetchAccessToken}\n        authProviderLoading={authProviderLoading}\n        client={client}\n        setIsConvexAuthenticated={setIsConvexAuthenticated}\n      />\n    </ConvexAuthContext.Provider>\n  );\n}\n\n// First child ensures we `setAuth` before\n// other child components subscribe to queries via `useEffect`.\nfunction ConvexAuthStateFirstEffect({\n  authProviderAuthenticated,\n  fetchAccessToken,\n  authProviderLoading,\n  client,\n  setIsConvexAuthenticated,\n}: {\n  authProviderAuthenticated: boolean;\n  fetchAccessToken: (args: {\n    forceRefreshToken: boolean;\n  }) => Promise<string | null>;\n  authProviderLoading: boolean;\n  client: IConvexReactClient;\n  setIsConvexAuthenticated: React.Dispatch<\n    React.SetStateAction<boolean | null>\n  >;\n}) {\n  useEffect(() => {\n    let isThisEffectRelevant = true;\n    if (authProviderAuthenticated) {\n      client.setAuth(fetchAccessToken, (backendReportsIsAuthenticated) => {\n        if (isThisEffectRelevant) {\n          setIsConvexAuthenticated(() => backendReportsIsAuthenticated);\n        }\n      });\n      return () => {\n        isThisEffectRelevant = false;\n\n        // If unmounting or something changed before we finished fetching the token\n        // we shouldn't transition to a loaded state.\n        setIsConvexAuthenticated((isConvexAuthenticated) =>\n          isConvexAuthenticated ? false : null,\n        );\n      };\n    }\n  }, [\n    authProviderAuthenticated,\n    fetchAccessToken,\n    authProviderLoading,\n    client,\n    setIsConvexAuthenticated,\n  ]);\n  return null;\n}\n\n// Last child ensures we `clearAuth` last,\n// so that queries from unmounted sibling components\n// unsubscribe first and don't rerun without auth on the server\nfunction ConvexAuthStateLastEffect({\n  authProviderAuthenticated,\n  fetchAccessToken,\n  authProviderLoading,\n  client,\n  setIsConvexAuthenticated,\n}: {\n  authProviderAuthenticated: boolean;\n  fetchAccessToken: (args: {\n    forceRefreshToken: boolean;\n  }) => Promise<string | null>;\n  authProviderLoading: boolean;\n  client: IConvexReactClient;\n  setIsConvexAuthenticated: React.Dispatch<\n    React.SetStateAction<boolean | null>\n  >;\n}) {\n  useEffect(() => {\n    // If rendered with authProviderAuthenticated=true then clear that auth on in cleanup.\n    if (authProviderAuthenticated) {\n      return () => {\n        client.clearAuth();\n        // Set state back to loading in case this is a transition from one\n        // fetchToken function to another which signals a new auth context,\n        // e.g. a new orgId from Clerk. Auth context changes like this\n        // return isAuthenticated: true from useAuth() but if\n        // useAuth reports isAuthenticated: false on the next render\n        // then this null value will be overridden to false.\n        setIsConvexAuthenticated(() => null);\n      };\n    }\n  }, [\n    authProviderAuthenticated,\n    fetchAccessToken,\n    authProviderLoading,\n    client,\n    setIsConvexAuthenticated,\n  ]);\n  return null;\n}\n", "/*\nhttps://github.com/beatgammit/base64-js/blob/88957c9943c7e2a0f03cdf73e71d579e433627d3/index.js\nCopyright (c) 2014 Jameson Little\nThe MIT License (MIT)\n*/\n\n// Vendored because this library has no ESM build, and some environments\n// (SvelteKit) are happiest when all dependencies are ESM.\n\nvar lookup: string[] = [];\nvar revLookup: number[] = [];\nvar Arr = Uint8Array;\n\nvar code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup[\"-\".charCodeAt(0)] = 62;\nrevLookup[\"_\".charCodeAt(0)] = 63;\n\nfunction getLens(b64: string) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf(\"=\");\n  if (validLen === -1) validLen = len;\n\n  var placeHoldersLen = validLen === len ? 0 : 4 - (validLen % 4);\n\n  return [validLen, placeHoldersLen];\n}\n\n// base64 is 4/3 + up to two characters of the original data\n/** @public */\nexport function byteLength(b64: string): number {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;\n}\n\nfunction _byteLength(_b64: string, validLen: number, placeHoldersLen: number) {\n  return ((validLen + placeHoldersLen) * 3) / 4 - placeHoldersLen;\n}\n\n/** @public */\nexport function toByteArray(b64: string): Uint8Array {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n  var curByte = 0;\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = (tmp >> 16) & 0xff;\n    arr[curByte++] = (tmp >> 8) & 0xff;\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[curByte++] = (tmp >> 8) & 0xff;\n    arr[curByte++] = tmp & 0xff;\n  }\n\n  return arr;\n}\n\nfunction tripletToBase64(num: number) {\n  return (\n    lookup[(num >> 18) & 0x3f] +\n    lookup[(num >> 12) & 0x3f] +\n    lookup[(num >> 6) & 0x3f] +\n    lookup[num & 0x3f]\n  );\n}\n\nfunction encodeChunk(uint8: Uint8Array, start: number, end: number) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xff0000) +\n      ((uint8[i + 1] << 8) & 0xff00) +\n      (uint8[i + 2] & 0xff);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join(\"\");\n}\n\n/** @public */\nexport function fromByteArray(uint8: Uint8Array): string {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(\n      encodeChunk(\n        uint8,\n        i,\n        i + maxChunkLength > len2 ? len2 : i + maxChunkLength,\n      ),\n    );\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(lookup[tmp >> 2] + lookup[(tmp << 4) & 0x3f] + \"==\");\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 10] +\n        lookup[(tmp >> 4) & 0x3f] +\n        lookup[(tmp << 2) & 0x3f] +\n        \"=\",\n    );\n  }\n\n  return parts.join(\"\");\n}\n", "/**\n * Utilities for working with values stored in Convex.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n * @module\n */\nimport * as Base64 from \"./base64.js\";\nimport { isSimpleObject } from \"../common/index.js\";\n\nconst LITTLE_ENDIAN = true;\n// This code is used by code that may not have bigint literals.\nconst MIN_INT64 = BigInt(\"-9223372036854775808\");\nconst MAX_INT64 = BigInt(\"9223372036854775807\");\nconst ZERO = BigInt(\"0\");\nconst EIGHT = BigInt(\"8\");\nconst TWOFIFTYSIX = BigInt(\"256\");\n\n/**\n * The type of JavaScript values serializable to JSON.\n *\n * @public\n */\nexport type JSONValue =\n  | null\n  | boolean\n  | number\n  | string\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\n/**\n * An identifier for a document in Convex.\n *\n * Convex documents are uniquely identified by their `Id`, which is accessible\n * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/database/document-ids).\n *\n * Documents can be loaded using `db.get(id)` in query and mutation functions.\n *\n * IDs are base 32 encoded strings which are URL safe.\n *\n * IDs are just strings at runtime, but this type can be used to distinguish them from other\n * strings at compile time.\n *\n * If you're using code generation, use the `Id` type generated for your data model in\n * `convex/_generated/dataModel.d.ts`.\n *\n * @typeParam TableName - A string literal type of the table name (like \"users\").\n *\n * @public\n */\nexport type Id<TableName extends string> = string & { __tableName: TableName };\n\n/**\n * A value supported by Convex.\n *\n * Values can be:\n * - stored inside of documents.\n * - used as arguments and return types to queries and mutation functions.\n *\n * You can see the full set of supported types at\n * [Types](https://docs.convex.dev/using/types).\n *\n * @public\n */\nexport type Value =\n  | null\n  | bigint\n  | number\n  | boolean\n  | string\n  | ArrayBuffer\n  | Value[]\n  | { [key: string]: undefined | Value };\n\n/**\n * The types of {@link Value} that can be used to represent numbers.\n *\n * @public\n */\nexport type NumericValue = bigint | number;\n\nfunction isSpecial(n: number) {\n  return Number.isNaN(n) || !Number.isFinite(n) || Object.is(n, -0);\n}\n\nexport function slowBigIntToBase64(value: bigint): string {\n  // the conversion is easy if we pretend it's unsigned\n  if (value < ZERO) {\n    value -= MIN_INT64 + MIN_INT64;\n  }\n  let hex = value.toString(16);\n  if (hex.length % 2 === 1) hex = \"0\" + hex;\n\n  const bytes = new Uint8Array(new ArrayBuffer(8));\n  let i = 0;\n  for (const hexByte of hex.match(/.{2}/g)!.reverse()) {\n    bytes.set([parseInt(hexByte, 16)], i++);\n    value >>= EIGHT;\n  }\n  return Base64.fromByteArray(bytes);\n}\n\nexport function slowBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`,\n    );\n  }\n  let value = ZERO;\n  let power = ZERO;\n  for (const byte of integerBytes) {\n    value += BigInt(byte) * TWOFIFTYSIX ** power;\n    power++;\n  }\n  if (value > MAX_INT64) {\n    value += MIN_INT64 + MIN_INT64;\n  }\n  return value;\n}\n\nexport function modernBigIntToBase64(value: bigint): string {\n  if (value < MIN_INT64 || MAX_INT64 < value) {\n    throw new Error(\n      `BigInt ${value} does not fit into a 64-bit signed integer.`,\n    );\n  }\n  const buffer = new ArrayBuffer(8);\n  new DataView(buffer).setBigInt64(0, value, true);\n  return Base64.fromByteArray(new Uint8Array(buffer));\n}\n\nexport function modernBase64ToBigInt(encoded: string): bigint {\n  const integerBytes = Base64.toByteArray(encoded);\n  if (integerBytes.byteLength !== 8) {\n    throw new Error(\n      `Received ${integerBytes.byteLength} bytes, expected 8 for $integer`,\n    );\n  }\n  const intBytesView = new DataView(integerBytes.buffer);\n  return intBytesView.getBigInt64(0, true);\n}\n\n// Fall back to a slower version on Safari 14 which lacks these APIs.\nexport const bigIntToBase64 = (DataView.prototype as any).setBigInt64\n  ? modernBigIntToBase64\n  : slowBigIntToBase64;\nexport const base64ToBigInt = (DataView.prototype as any).getBigInt64\n  ? modernBase64ToBigInt\n  : slowBase64ToBigInt;\n\nconst MAX_IDENTIFIER_LEN = 1024;\n\nfunction validateObjectField(k: string) {\n  if (k.length > MAX_IDENTIFIER_LEN) {\n    throw new Error(\n      `Field name ${k} exceeds maximum field name length ${MAX_IDENTIFIER_LEN}.`,\n    );\n  }\n  if (k.startsWith(\"$\")) {\n    throw new Error(`Field name ${k} starts with a '$', which is reserved.`);\n  }\n  for (let i = 0; i < k.length; i += 1) {\n    const charCode = k.charCodeAt(i);\n    // Non-control ASCII characters\n    if (charCode < 32 || charCode >= 127) {\n      throw new Error(\n        `Field name ${k} has invalid character '${k[i]}': Field names can only contain non-control ASCII characters`,\n      );\n    }\n  }\n}\n\n/**\n * Parse a Convex value from its JSON representation.\n *\n * This function will deserialize serialized Int64s to `BigInt`s, Bytes to `ArrayBuffer`s etc.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - The JSON representation of a Convex value previously created with {@link convexToJson}.\n * @returns The JavaScript representation of the Convex value.\n *\n * @public\n */\nexport function jsonToConvex(value: JSONValue): Value {\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (Array.isArray(value)) {\n    return value.map((value) => jsonToConvex(value));\n  }\n  if (typeof value !== \"object\") {\n    throw new Error(`Unexpected type of ${value as any}`);\n  }\n  const entries = Object.entries(value);\n  if (entries.length === 1) {\n    const key = entries[0][0];\n    if (key === \"$bytes\") {\n      if (typeof value.$bytes !== \"string\") {\n        throw new Error(`Malformed $bytes field on ${value as any}`);\n      }\n      return Base64.toByteArray(value.$bytes).buffer;\n    }\n    if (key === \"$integer\") {\n      if (typeof value.$integer !== \"string\") {\n        throw new Error(`Malformed $integer field on ${value as any}`);\n      }\n      return base64ToBigInt(value.$integer);\n    }\n    if (key === \"$float\") {\n      if (typeof value.$float !== \"string\") {\n        throw new Error(`Malformed $float field on ${value as any}`);\n      }\n      const floatBytes = Base64.toByteArray(value.$float);\n      if (floatBytes.byteLength !== 8) {\n        throw new Error(\n          `Received ${floatBytes.byteLength} bytes, expected 8 for $float`,\n        );\n      }\n      const floatBytesView = new DataView(floatBytes.buffer);\n      const float = floatBytesView.getFloat64(0, LITTLE_ENDIAN);\n      if (!isSpecial(float)) {\n        throw new Error(`Float ${float} should be encoded as a number`);\n      }\n      return float;\n    }\n    if (key === \"$set\") {\n      throw new Error(\n        `Received a Set which is no longer supported as a Convex type.`,\n      );\n    }\n    if (key === \"$map\") {\n      throw new Error(\n        `Received a Map which is no longer supported as a Convex type.`,\n      );\n    }\n  }\n  const out: { [key: string]: Value } = {};\n  for (const [k, v] of Object.entries(value)) {\n    validateObjectField(k);\n    out[k] = jsonToConvex(v);\n  }\n  return out;\n}\n\nexport function stringifyValueForError(value: any) {\n  return JSON.stringify(value, (_key, value) => {\n    if (value === undefined) {\n      // By default `JSON.stringify` converts undefined, functions, symbols,\n      // Infinity, and NaN to null which produces a confusing error message.\n      // We deal with `undefined` specifically because it's the most common.\n      // Ideally we'd use a pretty-printing library that prints `undefined`\n      // (no quotes), but it might not be worth the bundle size cost.\n      return \"undefined\";\n    }\n    if (typeof value === \"bigint\") {\n      // `JSON.stringify` throws on bigints by default.\n      return `${value.toString()}n`;\n    }\n    return value;\n  });\n}\n\nfunction convexToJsonInternal(\n  value: Value,\n  originalValue: Value,\n  context: string,\n  includeTopLevelUndefined: boolean,\n): JSONValue {\n  if (value === undefined) {\n    const contextText =\n      context &&\n      ` (present at path ${context} in original object ${stringifyValueForError(\n        originalValue,\n      )})`;\n    throw new Error(\n      `undefined is not a valid Convex value${contextText}. To learn about Convex's supported types, see https://docs.convex.dev/using/types.`,\n    );\n  }\n  if (value === null) {\n    return value;\n  }\n  if (typeof value === \"bigint\") {\n    if (value < MIN_INT64 || MAX_INT64 < value) {\n      throw new Error(\n        `BigInt ${value} does not fit into a 64-bit signed integer.`,\n      );\n    }\n    return { $integer: bigIntToBase64(value) };\n  }\n  if (typeof value === \"number\") {\n    if (isSpecial(value)) {\n      const buffer = new ArrayBuffer(8);\n      new DataView(buffer).setFloat64(0, value, LITTLE_ENDIAN);\n      return { $float: Base64.fromByteArray(new Uint8Array(buffer)) };\n    } else {\n      return value;\n    }\n  }\n  if (typeof value === \"boolean\") {\n    return value;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  if (value instanceof ArrayBuffer) {\n    return { $bytes: Base64.fromByteArray(new Uint8Array(value)) };\n  }\n  if (Array.isArray(value)) {\n    return value.map((value, i) =>\n      convexToJsonInternal(value, originalValue, context + `[${i}]`, false),\n    );\n  }\n  if (value instanceof Set) {\n    throw new Error(\n      errorMessageForUnsupportedType(context, \"Set\", [...value], originalValue),\n    );\n  }\n  if (value instanceof Map) {\n    throw new Error(\n      errorMessageForUnsupportedType(context, \"Map\", [...value], originalValue),\n    );\n  }\n\n  if (!isSimpleObject(value)) {\n    const theType = value?.constructor?.name;\n    const typeName = theType ? `${theType} ` : \"\";\n    throw new Error(\n      errorMessageForUnsupportedType(context, typeName, value, originalValue),\n    );\n  }\n\n  const out: { [key: string]: JSONValue } = {};\n  const entries = Object.entries(value);\n  entries.sort(([k1, _v1], [k2, _v2]) => (k1 === k2 ? 0 : k1 < k2 ? -1 : 1));\n  for (const [k, v] of entries) {\n    if (v !== undefined) {\n      validateObjectField(k);\n      out[k] = convexToJsonInternal(v, originalValue, context + `.${k}`, false);\n    } else if (includeTopLevelUndefined) {\n      validateObjectField(k);\n      out[k] = convexOrUndefinedToJsonInternal(\n        v,\n        originalValue,\n        context + `.${k}`,\n      );\n    }\n  }\n  return out;\n}\n\nfunction errorMessageForUnsupportedType(\n  context: string,\n  typeName: string,\n  value: any,\n  originalValue: any,\n) {\n  if (context) {\n    return `${typeName}${stringifyValueForError(\n      value,\n    )} is not a supported Convex type (present at path ${context} in original object ${stringifyValueForError(\n      originalValue,\n    )}). To learn about Convex's supported types, see https://docs.convex.dev/using/types.`;\n  } else {\n    return `${typeName}${stringifyValueForError(\n      value,\n    )} is not a supported Convex type.`;\n  }\n}\n\n// convexOrUndefinedToJsonInternal wrapper exists so we can pipe through the\n// `originalValue` and `context` through for better error messaging.\nfunction convexOrUndefinedToJsonInternal(\n  value: Value | undefined,\n  originalValue: Value | undefined,\n  context: string,\n): JSONValue {\n  if (value === undefined) {\n    return { $undefined: null };\n  } else {\n    if (originalValue === undefined) {\n      // This should not happen.\n      throw new Error(\n        `Programming error. Current value is ${stringifyValueForError(\n          value,\n        )} but original value is undefined`,\n      );\n    }\n    return convexToJsonInternal(value, originalValue, context, false);\n  }\n}\n\n/**\n * Convert a Convex value to its JSON representation.\n *\n * Use {@link jsonToConvex} to recreate the original value.\n *\n * To learn more about Convex values, see [Types](https://docs.convex.dev/using/types).\n *\n * @param value - A Convex value to convert into JSON.\n * @returns The JSON representation of `value`.\n *\n * @public\n */\nexport function convexToJson(value: Value): JSONValue {\n  return convexToJsonInternal(value, value, \"\", false);\n}\n\n// Convert a Convex value or `undefined` into its JSON representation.\n// `undefined` is used in filters to represent a missing object field.\nexport function convexOrUndefinedToJson(value: Value | undefined): JSONValue {\n  return convexOrUndefinedToJsonInternal(value, value, \"\");\n}\n\n/**\n * Similar to convexToJson but also serializes top level undefined fields\n * using convexOrUndefinedToJson().\n *\n * @param value - A Convex value to convert into JSON.\n * @returns The JSON representation of `value`.\n */\nexport function patchValueToJson(value: Value): JSONValue {\n  return convexToJsonInternal(value, value, \"\", true);\n}\n", "import { Value, stringifyValueForError } from \"./value.js\";\n\nconst IDENTIFYING_FIELD = Symbol.for(\"ConvexError\");\n\nexport class ConvexError<TData extends Value> extends Error {\n  name = \"ConvexError\";\n  data: TData;\n  [IDENTIFYING_FIELD] = true;\n\n  constructor(data: TData) {\n    super(typeof data === \"string\" ? data : stringifyValueForError(data));\n    this.data = data;\n  }\n}\n", "/**\n * A symbol for accessing the name of a {@link FunctionReference} at runtime.\n */\nexport const functionName = Symbol.for(\"functionName\");\n", "import { functionName } from \"../functionName.js\";\n\nexport const toReferencePath = Symbol.for(\"toReferencePath\");\n\n// Multiple instances of the same Symbol.for() are equal at runtime but not\n// at type-time, so `[toReferencePath]` properties aren't used in types.\n// Use this function to set the property invisibly.\nexport function setReferencePath<T>(obj: T, value: string) {\n  (obj as any)[toReferencePath] = value;\n}\n\nexport function extractReferencePath(reference: any): string | null {\n  return reference[toReferencePath] ?? null;\n}\n\nexport function isFunctionHandle(s: string): boolean {\n  return s.startsWith(\"function://\");\n}\n\nexport function getFunctionAddress(functionReference: any) {\n  // The `run*` syscalls expect either a UDF path at \"name\" or a serialized\n  // reference at \"reference\". Dispatch on `functionReference` to coerce\n  // it to one or the other.\n  let functionAddress;\n\n  // Legacy path for passing in UDF paths directly as function references.\n  if (typeof functionReference === \"string\") {\n    if (isFunctionHandle(functionReference)) {\n      functionAddress = { functionHandle: functionReference };\n    } else {\n      functionAddress = { name: functionReference };\n    }\n  }\n  // Path for passing in a `FunctionReference`, either from `api` or directly\n  // created from a UDF path with `makeFunctionReference`.\n  else if (functionReference[functionName]) {\n    functionAddress = { name: functionReference[functionName] };\n  }\n  // Reference to a component's function derived from `app` or `component`.\n  else {\n    const referencePath = extractReferencePath(functionReference);\n    if (!referencePath) {\n      throw new Error(`${functionReference} is not a functionReference`);\n    }\n    functionAddress = { reference: referencePath };\n  }\n  return functionAddress;\n}\n", "import {\n  EmptyObject,\n  DefaultFunctionArgs,\n  FunctionVisibility,\n  RegisteredAction,\n  RegisteredMutation,\n  RegisteredQuery,\n} from \"./registration.js\";\nimport { Expand, UnionToIntersection } from \"../type_utils.js\";\nimport { PaginationOptions, PaginationResult } from \"./pagination.js\";\nimport { functionName } from \"./functionName.js\";\nimport { getFunctionAddress } from \"./components/paths.js\";\n\n/**\n * The type of a Convex function.\n *\n * @public\n */\nexport type FunctionType = \"query\" | \"mutation\" | \"action\";\n\n/**\n * A reference to a registered Convex function.\n *\n * You can create a {@link FunctionReference} using the generated `api` utility:\n * ```js\n * import { api } from \"../convex/_generated/api\";\n *\n * const reference = api.myModule.myFunction;\n * ```\n *\n * If you aren't using code generation, you can create references using\n * {@link anyApi}:\n * ```js\n * import { anyApi } from \"convex/server\";\n *\n * const reference = anyApi.myModule.myFunction;\n * ```\n *\n * Function references can be used to invoke functions from the client. For\n * example, in React you can pass references to the {@link react.useQuery} hook:\n * ```js\n * const result = useQuery(api.myModule.myFunction);\n * ```\n *\n * @typeParam Type - The type of the function (\"query\", \"mutation\", or \"action\").\n * @typeParam Visibility - The visibility of the function (\"public\" or \"internal\").\n * @typeParam Args - The arguments to this function. This is an object mapping\n * argument names to their types.\n * @typeParam ReturnType - The return type of this function.\n * @public\n */\nexport type FunctionReference<\n  Type extends FunctionType,\n  Visibility extends FunctionVisibility = \"public\",\n  Args extends DefaultFunctionArgs = any,\n  ReturnType = any,\n  ComponentPath = string | undefined,\n> = {\n  _type: Type;\n  _visibility: Visibility;\n  _args: Args;\n  _returnType: ReturnType;\n  _componentPath: ComponentPath;\n};\n\n/**\n * Get the name of a function from a {@link FunctionReference}.\n *\n * The name is a string like \"myDir/myModule:myFunction\". If the exported name\n * of the function is `\"default\"`, the function name is omitted\n * (e.g. \"myDir/myModule\").\n *\n * @param functionReference - A {@link FunctionReference} to get the name of.\n * @returns A string of the function's name.\n *\n * @public\n */\nexport function getFunctionName(\n  functionReference: AnyFunctionReference,\n): string {\n  const address = getFunctionAddress(functionReference);\n\n  if (address.name === undefined) {\n    if (address.functionHandle !== undefined) {\n      throw new Error(\n        `Expected function reference like \"api.file.func\" or \"internal.file.func\", but received function handle ${address.functionHandle}`,\n      );\n    } else if (address.reference !== undefined) {\n      throw new Error(\n        `Expected function reference in the current component like \"api.file.func\" or \"internal.file.func\", but received reference ${address.reference}`,\n      );\n    }\n    throw new Error(\n      `Expected function reference like \"api.file.func\" or \"internal.file.func\", but received ${JSON.stringify(address)}`,\n    );\n  }\n  // Both a legacy thing and also a convenience for interactive use:\n  // the types won't check but a string is always allowed at runtime.\n  if (typeof functionReference === \"string\") return functionReference;\n\n  // Two different runtime values for FunctionReference implement this\n  // interface: api objects returned from `createApi()` and standalone\n  // function reference objects returned from makeFunctionReference.\n  const name = (functionReference as any)[functionName];\n  if (!name) {\n    throw new Error(`${functionReference as any} is not a functionReference`);\n  }\n  return name;\n}\n\n/**\n * FunctionReferences generally come from generated code, but in custom clients\n * it may be useful to be able to build one manually.\n *\n * Real function references are empty objects at runtime, but the same interface\n * can be implemented with an object for tests and clients which don't use\n * code generation.\n *\n * @param name - The identifier of the function. E.g. `path/to/file:functionName`\n * @public\n */\nexport function makeFunctionReference<\n  type extends FunctionType,\n  args extends DefaultFunctionArgs = any,\n  ret = any,\n>(name: string): FunctionReference<type, \"public\", args, ret> {\n  return { [functionName]: name } as unknown as FunctionReference<\n    type,\n    \"public\",\n    args,\n    ret\n  >;\n}\n\n/**\n * Create a runtime API object that implements {@link AnyApi}.\n *\n * This allows accessing any path regardless of what directories, modules,\n * or functions are defined.\n *\n * @param pathParts - The path to the current node in the API.\n * @returns An {@link AnyApi}\n * @public\n */\nfunction createApi(pathParts: string[] = []): AnyApi {\n  const handler: ProxyHandler<object> = {\n    get(_, prop: string | symbol) {\n      if (typeof prop === \"string\") {\n        const newParts = [...pathParts, prop];\n        return createApi(newParts);\n      } else if (prop === functionName) {\n        if (pathParts.length < 2) {\n          const found = [\"api\", ...pathParts].join(\".\");\n          throw new Error(\n            `API path is expected to be of the form \\`api.moduleName.functionName\\`. Found: \\`${found}\\``,\n          );\n        }\n        const path = pathParts.slice(0, -1).join(\"/\");\n        const exportName = pathParts[pathParts.length - 1];\n        if (exportName === \"default\") {\n          return path;\n        } else {\n          return path + \":\" + exportName;\n        }\n      } else if (prop === Symbol.toStringTag) {\n        return \"FunctionReference\";\n      } else {\n        return undefined;\n      }\n    },\n  };\n\n  return new Proxy({}, handler);\n}\n\n/**\n * Given an export from a module, convert it to a {@link FunctionReference}\n * if it is a Convex function.\n */\nexport type FunctionReferenceFromExport<Export> =\n  Export extends RegisteredQuery<\n    infer Visibility,\n    infer Args,\n    infer ReturnValue\n  >\n    ? FunctionReference<\n        \"query\",\n        Visibility,\n        Args,\n        ConvertReturnType<ReturnValue>\n      >\n    : Export extends RegisteredMutation<\n          infer Visibility,\n          infer Args,\n          infer ReturnValue\n        >\n      ? FunctionReference<\n          \"mutation\",\n          Visibility,\n          Args,\n          ConvertReturnType<ReturnValue>\n        >\n      : Export extends RegisteredAction<\n            infer Visibility,\n            infer Args,\n            infer ReturnValue\n          >\n        ? FunctionReference<\n            \"action\",\n            Visibility,\n            Args,\n            ConvertReturnType<ReturnValue>\n          >\n        : never;\n\n/**\n * Given a module, convert all the Convex functions into\n * {@link FunctionReference}s and remove the other exports.\n *\n * BE CAREFUL WHEN EDITING THIS!\n *\n * This is written carefully to preserve jumping to function definitions using\n * cmd+click. If you edit it, please test that cmd+click still works.\n */\ntype FunctionReferencesInModule<Module extends Record<string, any>> = {\n  -readonly [ExportName in keyof Module as Module[ExportName][\"isConvexFunction\"] extends true\n    ? ExportName\n    : never]: FunctionReferenceFromExport<Module[ExportName]>;\n};\n\n/**\n * Given a path to a module and it's type, generate an API type for this module.\n *\n * This is a nested object according to the module's path.\n */\ntype ApiForModule<\n  ModulePath extends string,\n  Module extends object,\n> = ModulePath extends `${infer First}/${infer Second}`\n  ? {\n      [_ in First]: ApiForModule<Second, Module>;\n    }\n  : { [_ in ModulePath]: FunctionReferencesInModule<Module> };\n\n/**\n * Given the types of all modules in the `convex/` directory, construct the type\n * of `api`.\n *\n * `api` is a utility for constructing {@link FunctionReference}s.\n *\n * @typeParam AllModules - A type mapping module paths (like `\"dir/myModule\"`) to\n * the types of the modules.\n * @public\n */\nexport type ApiFromModules<AllModules extends Record<string, object>> =\n  FilterApi<\n    ApiFromModulesAllowEmptyNodes<AllModules>,\n    FunctionReference<any, any, any, any>\n  >;\n\ntype ApiFromModulesAllowEmptyNodes<AllModules extends Record<string, object>> =\n  ExpandModulesAndDirs<\n    UnionToIntersection<\n      {\n        [ModulePath in keyof AllModules]: ApiForModule<\n          ModulePath & string,\n          AllModules[ModulePath]\n        >;\n      }[keyof AllModules]\n    >\n  >;\n\n/**\n * @public\n *\n * Filter a Convex deployment api object for functions which meet criteria,\n * for example all public queries.\n */\nexport type FilterApi<API, Predicate> = Expand<{\n  [mod in keyof API as API[mod] extends Predicate\n    ? mod\n    : API[mod] extends FunctionReference<any, any, any, any>\n      ? never\n      : FilterApi<API[mod], Predicate> extends Record<string, never>\n        ? never\n        : mod]: API[mod] extends Predicate\n    ? API[mod]\n    : FilterApi<API[mod], Predicate>;\n}>;\n\n/**\n * Given an api of type API and a FunctionReference subtype, return an api object\n * containing only the function references that match.\n *\n * ```ts\n * const q = filterApi<typeof api, FunctionReference<\"query\">>(api)\n * ```\n *\n * @public\n */\nexport function filterApi<API, Predicate>(api: API): FilterApi<API, Predicate> {\n  return api as any;\n}\n\n// These just* API filter helpers require no type parameters so are useable from JavaScript.\n/** @public */\nexport function justInternal<API>(\n  api: API,\n): FilterApi<API, FunctionReference<any, \"internal\", any, any>> {\n  return api as any;\n}\n\n/** @public */\nexport function justPublic<API>(\n  api: API,\n): FilterApi<API, FunctionReference<any, \"public\", any, any>> {\n  return api as any;\n}\n\n/** @public */\nexport function justQueries<API>(\n  api: API,\n): FilterApi<API, FunctionReference<\"query\", any, any, any>> {\n  return api as any;\n}\n\n/** @public */\nexport function justMutations<API>(\n  api: API,\n): FilterApi<API, FunctionReference<\"mutation\", any, any, any>> {\n  return api as any;\n}\n\n/** @public */\nexport function justActions<API>(\n  api: API,\n): FilterApi<API, FunctionReference<\"action\", any, any, any>> {\n  return api as any;\n}\n\n/** @public */\nexport function justPaginatedQueries<API>(\n  api: API,\n): FilterApi<\n  API,\n  FunctionReference<\n    \"query\",\n    any,\n    { paginationOpts: PaginationOptions },\n    PaginationResult<any>\n  >\n> {\n  return api as any;\n}\n\n/** @public */\nexport function justSchedulable<API>(\n  api: API,\n): FilterApi<API, FunctionReference<\"mutation\" | \"action\", any, any, any>> {\n  return api as any;\n}\n\n/**\n * Like {@link Expand}, this simplifies how TypeScript displays object types.\n * The differences are:\n * 1. This version is recursive.\n * 2. This stops recursing when it hits a {@link FunctionReference}.\n */\ntype ExpandModulesAndDirs<ObjectType> = ObjectType extends AnyFunctionReference\n  ? ObjectType\n  : {\n      [Key in keyof ObjectType]: ExpandModulesAndDirs<ObjectType[Key]>;\n    };\n\n/**\n * A {@link FunctionReference} of any type and any visibility with any\n * arguments and any return type.\n *\n * @public\n */\nexport type AnyFunctionReference = FunctionReference<any, any>;\n\ntype AnyModuleDirOrFunc = {\n  [key: string]: AnyModuleDirOrFunc;\n} & AnyFunctionReference;\n\n/**\n * The type that Convex api objects extend. If you were writing an api from\n * scratch it should extend this type.\n *\n * @public\n */\nexport type AnyApi = Record<string, Record<string, AnyModuleDirOrFunc>>;\n\n/**\n * Recursive partial API, useful for defining a subset of an API when mocking\n * or building custom api objects.\n *\n * @public\n */\nexport type PartialApi<API> = {\n  [mod in keyof API]?: API[mod] extends FunctionReference<any, any, any, any>\n    ? API[mod]\n    : PartialApi<API[mod]>;\n};\n\n/**\n * A utility for constructing {@link FunctionReference}s in projects that\n * are not using code generation.\n *\n * You can create a reference to a function like:\n * ```js\n * const reference = anyApi.myModule.myFunction;\n * ```\n *\n * This supports accessing any path regardless of what directories and modules\n * are in your project. All function references are typed as\n * {@link AnyFunctionReference}.\n *\n *\n * If you're using code generation, use `api` from `convex/_generated/api`\n * instead. It will be more type-safe and produce better auto-complete\n * in your editor.\n *\n * @public\n */\nexport const anyApi: AnyApi = createApi() as any;\n\n/**\n * Given a {@link FunctionReference}, get the return type of the function.\n *\n * This is represented as an object mapping argument names to values.\n * @public\n */\nexport type FunctionArgs<FuncRef extends AnyFunctionReference> =\n  FuncRef[\"_args\"];\n\n/**\n * A tuple type of the (maybe optional) arguments to `FuncRef`.\n *\n * This type is used to make methods involving arguments type safe while allowing\n * skipping the arguments for functions that don't require arguments.\n *\n * @public\n */\nexport type OptionalRestArgs<FuncRef extends AnyFunctionReference> =\n  FuncRef[\"_args\"] extends EmptyObject\n    ? [args?: EmptyObject]\n    : [args: FuncRef[\"_args\"]];\n\n/**\n * A tuple type of the (maybe optional) arguments to `FuncRef`, followed by an options\n * object of type `Options`.\n *\n * This type is used to make methods like `useQuery` type-safe while allowing\n * 1. Skipping arguments for functions that don't require arguments.\n * 2. Skipping the options object.\n * @public\n */\nexport type ArgsAndOptions<\n  FuncRef extends AnyFunctionReference,\n  Options,\n> = FuncRef[\"_args\"] extends EmptyObject\n  ? [args?: EmptyObject, options?: Options]\n  : [args: FuncRef[\"_args\"], options?: Options];\n\n/**\n * Given a {@link FunctionReference}, get the return type of the function.\n *\n * @public\n */\nexport type FunctionReturnType<FuncRef extends AnyFunctionReference> =\n  FuncRef[\"_returnType\"];\n\ntype UndefinedToNull<T> = T extends void ? null : T;\n\ntype NullToUndefinedOrNull<T> = T extends null ? T | undefined | void : T;\n\n/**\n * Convert the return type of a function to it's client-facing format.\n *\n * This means:\n * - Converting `undefined` and `void` to `null`\n * - Removing all `Promise` wrappers\n */\nexport type ConvertReturnType<T> = UndefinedToNull<Awaited<T>>;\n\nexport type ValidatorTypeToReturnType<T> =\n  | Promise<NullToUndefinedOrNull<T>>\n  | NullToUndefinedOrNull<T>;\n", "// Implements an unsigned long.\n// This is a subset of https://github.com/dcodeIO/Long.js,\n// vendored to decrease bundle size.\n// Copyright Daniel Wirtz <dcode@dcode.io>\n// License: Apache Version 2.0\n/*\n\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2023 Daniel Wirtz <dcode@dcode.io>\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n// This works... but don't try to compare one to a real Long.js Long!\n// For internal use only.\n// `| 0` assures the runtime that we are using integer arithmetic\nexport class Long {\n  low: number;\n  high: number;\n  __isUnsignedLong__: boolean;\n\n  static isLong(obj: Long) {\n    return (obj && obj.__isUnsignedLong__) === true;\n  }\n\n  constructor(low: number, high: number) {\n    this.low = low | 0;\n    this.high = high | 0;\n    this.__isUnsignedLong__ = true;\n  }\n\n  // prettier-ignore\n  static fromBytesLE(bytes: number[]): Long {\n    return new Long(\n      bytes[0] |\n      bytes[1] << 8 |\n      bytes[2] << 16 |\n      bytes[3] << 24,\n      bytes[4] |\n      bytes[5] << 8 |\n      bytes[6] << 16 |\n      bytes[7] << 24,\n    );\n  }\n\n  // prettier-ignore\n  toBytesLE() {\n    const hi = this.high;\n    const lo = this.low;\n    return [\n      lo & 0xff,\n      lo >>> 8 & 0xff,\n      lo >>> 16 & 0xff,\n      lo >>> 24,\n      hi & 0xff,\n      hi >>> 8 & 0xff,\n      hi >>> 16 & 0xff,\n      hi >>> 24\n    ];\n  }\n\n  static fromNumber(value: number) {\n    if (isNaN(value)) return UZERO;\n    if (value < 0) return UZERO;\n    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n    return new Long(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0);\n  }\n\n  toString() {\n    return (\n      BigInt(this.high) * BigInt(TWO_PWR_32_DBL) +\n      BigInt(this.low)\n    ).toString();\n  }\n\n  equals(other: Long) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    if (this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n    return this.high === other.high && this.low === other.low;\n  }\n\n  notEquals(other: Long) {\n    return !this.equals(other);\n  }\n\n  comp(other: Long) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    if (this.equals(other)) return 0;\n    return other.high >>> 0 > this.high >>> 0 ||\n      (other.high === this.high && other.low >>> 0 > this.low >>> 0)\n      ? -1\n      : 1;\n  }\n\n  lessThanOrEqual(other: Long) {\n    return this.comp(/* validates */ other) <= 0;\n  }\n\n  static fromValue(val: any) {\n    if (typeof val === \"number\") return Long.fromNumber(val);\n    // Throws for non-objects, converts non-instanceof Long:\n    return new Long(val.low, val.high);\n  }\n}\n\nconst UZERO = new Long(0, 0);\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst MAX_UNSIGNED_VALUE = new Long(0xffffffff | 0, 0xffffffff | 0);\n", "export class InvalidTokenError extends Error {\n}\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {\n        let code = p.charCodeAt(0).toString(16).toUpperCase();\n        if (code.length < 2) {\n            code = \"0\" + code;\n        }\n        return \"%\" + code;\n    }));\n}\nfunction base64UrlDecode(str) {\n    let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw new Error(\"base64 string is not of the correct length\");\n    }\n    try {\n        return b64DecodeUnicode(output);\n    }\n    catch (err) {\n        return atob(output);\n    }\n}\nexport function jwtDecode(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified: must be a string\");\n    }\n    options || (options = {});\n    const pos = options.header === true ? 0 : 1;\n    const part = token.split(\".\")[pos];\n    if (typeof part !== \"string\") {\n        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);\n    }\n    let decoded;\n    try {\n        decoded = base64UrlDecode(part);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);\n    }\n    try {\n        return JSON.parse(decoded);\n    }\n    catch (e) {\n        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);\n    }\n}\n", "import { Logger } from \"../logging.js\";\nimport { LocalSyncState } from \"./local_state.js\";\nimport { AuthError, IdentityVersion, Transition } from \"./protocol.js\";\nimport { jwtDecode } from \"jwt-decode\";\n\n// setTimout uses 32 bit integer, so it can only\n// schedule about 24 days in the future.\nconst MAXIMUM_REFRESH_DELAY = 20 * 24 * 60 * 60 * 1000; // 20 days\n\nconst MAX_TOKEN_CONFIRMATION_ATTEMPTS = 2;\n\n/**\n * An async function returning the JWT-encoded OpenID Connect Identity Token\n * if available.\n *\n * `forceRefreshToken` is `true` if the server rejected a previously\n * returned token, and the client should try to fetch a new one.\n *\n * See {@link ConvexReactClient.setAuth}.\n *\n * @public\n */\nexport type AuthTokenFetcher = (args: {\n  forceRefreshToken: boolean;\n}) => Promise<string | null | undefined>;\n\n/**\n * What is provided to the client.\n */\ntype AuthConfig = {\n  fetchToken: AuthTokenFetcher;\n  onAuthChange: (isAuthenticated: boolean) => void;\n};\n\n/**\n * In general we take 3 steps:\n *   1. Fetch a possibly cached token\n *   2. Immediately fetch a fresh token without using a cache\n *   3. Repeat step 2 before the end of the fresh token's lifetime\n *\n * When we fetch without using a cache we know when the token\n * will expire, and can schedule refetching it.\n *\n * If we get an error before a scheduled refetch, we go back\n * to step 2.\n */\ntype AuthState =\n  | { state: \"noAuth\" }\n  | {\n      state: \"waitingForServerConfirmationOfCachedToken\";\n      config: AuthConfig;\n      hasRetried: boolean;\n    }\n  | {\n      state: \"initialRefetch\";\n      config: AuthConfig;\n    }\n  | {\n      state: \"waitingForServerConfirmationOfFreshToken\";\n      config: AuthConfig;\n      hadAuth: boolean;\n      token: string;\n    }\n  | {\n      state: \"waitingForScheduledRefetch\";\n      config: AuthConfig;\n      refetchTokenTimeoutId: ReturnType<typeof setTimeout>;\n    }\n  // Special/weird state when we got a valid token\n  // but could not fetch a new one.\n  | {\n      state: \"notRefetching\";\n      config: AuthConfig;\n    };\n\n/**\n * Handles the state transitions for auth. The server is the source\n * of truth.\n */\nexport class AuthenticationManager {\n  private authState: AuthState = { state: \"noAuth\" };\n  // Used to detect races involving `setConfig` calls\n  // while a token is being fetched.\n  private configVersion = 0;\n  // Shared by the BaseClient so that the auth manager can easily inspect it\n  private readonly syncState: LocalSyncState;\n  // Passed down by BaseClient, sends a message to the server\n  private readonly authenticate: (token: string) => IdentityVersion;\n  private readonly stopSocket: () => Promise<void>;\n  private readonly tryRestartSocket: () => void;\n  private readonly pauseSocket: () => void;\n  private readonly resumeSocket: () => void;\n  // Passed down by BaseClient, sends a message to the server\n  private readonly clearAuth: () => void;\n  private readonly logger: Logger;\n  private readonly refreshTokenLeewaySeconds: number;\n  // Number of times we have attempted to confirm the latest token. We retry up\n  // to `MAX_TOKEN_CONFIRMATION_ATTEMPTS` times.\n  private tokenConfirmationAttempts = 0;\n  constructor(\n    syncState: LocalSyncState,\n    callbacks: {\n      authenticate: (token: string) => IdentityVersion;\n      stopSocket: () => Promise<void>;\n      tryRestartSocket: () => void;\n      pauseSocket: () => void;\n      resumeSocket: () => void;\n      clearAuth: () => void;\n    },\n    config: {\n      refreshTokenLeewaySeconds: number;\n      logger: Logger;\n    },\n  ) {\n    this.syncState = syncState;\n    this.authenticate = callbacks.authenticate;\n    this.stopSocket = callbacks.stopSocket;\n    this.tryRestartSocket = callbacks.tryRestartSocket;\n    this.pauseSocket = callbacks.pauseSocket;\n    this.resumeSocket = callbacks.resumeSocket;\n    this.clearAuth = callbacks.clearAuth;\n    this.logger = config.logger;\n    this.refreshTokenLeewaySeconds = config.refreshTokenLeewaySeconds;\n  }\n\n  async setConfig(\n    fetchToken: AuthTokenFetcher,\n    onChange: (isAuthenticated: boolean) => void,\n  ) {\n    this.resetAuthState();\n    this._logVerbose(\"pausing WS for auth token fetch\");\n    this.pauseSocket();\n    const token = await this.fetchTokenAndGuardAgainstRace(fetchToken, {\n      forceRefreshToken: false,\n    });\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n    if (token.value) {\n      this.setAuthState({\n        state: \"waitingForServerConfirmationOfCachedToken\",\n        config: { fetchToken, onAuthChange: onChange },\n        hasRetried: false,\n      });\n      this.authenticate(token.value);\n    } else {\n      this.setAuthState({\n        state: \"initialRefetch\",\n        config: { fetchToken, onAuthChange: onChange },\n      });\n      // Try again with `forceRefreshToken: true`\n      await this.refetchToken();\n    }\n    this._logVerbose(\"resuming WS after auth token fetch\");\n    this.resumeSocket();\n  }\n\n  onTransition(serverMessage: Transition) {\n    if (\n      !this.syncState.isCurrentOrNewerAuthVersion(\n        serverMessage.endVersion.identity,\n      )\n    ) {\n      // This is a stale transition - client has moved on to\n      // a newer auth version.\n      return;\n    }\n    if (\n      serverMessage.endVersion.identity <= serverMessage.startVersion.identity\n    ) {\n      // This transition did not change auth - it is not a response to Authenticate.\n      return;\n    }\n\n    if (this.authState.state === \"waitingForServerConfirmationOfCachedToken\") {\n      this._logVerbose(\"server confirmed auth token is valid\");\n      void this.refetchToken();\n      this.authState.config.onAuthChange(true);\n      return;\n    }\n    if (this.authState.state === \"waitingForServerConfirmationOfFreshToken\") {\n      this._logVerbose(\"server confirmed new auth token is valid\");\n      this.scheduleTokenRefetch(this.authState.token);\n      this.tokenConfirmationAttempts = 0;\n      if (!this.authState.hadAuth) {\n        this.authState.config.onAuthChange(true);\n      }\n    }\n  }\n\n  onAuthError(serverMessage: AuthError) {\n    // If the AuthError is not due to updating the token, and we're currently\n    // waiting on the result of a token update, ignore.\n    if (\n      serverMessage.authUpdateAttempted === false &&\n      (this.authState.state === \"waitingForServerConfirmationOfFreshToken\" ||\n        this.authState.state === \"waitingForServerConfirmationOfCachedToken\")\n    ) {\n      this._logVerbose(\"ignoring non-auth token expired error\");\n      return;\n    }\n    const { baseVersion } = serverMessage;\n    // Versioned AuthErrors are ignored if the client advanced to\n    // a newer auth identity\n    // Error are reporting the previous version, since the server\n    // didn't advance, hence `+ 1`.\n    if (!this.syncState.isCurrentOrNewerAuthVersion(baseVersion + 1)) {\n      this._logVerbose(\"ignoring auth error for previous auth attempt\");\n      return;\n    }\n    void this.tryToReauthenticate(serverMessage);\n    return;\n  }\n\n  // This is similar to `refetchToken` defined below, in fact we\n  // don't represent them as different states, but it is different\n  // in that we pause the WebSocket so that mutations\n  // don't retry with bad auth.\n  private async tryToReauthenticate(serverMessage: AuthError) {\n    this._logVerbose(`attempting to reauthenticate: ${serverMessage.error}`);\n    if (\n      // No way to fetch another token, kaboom\n      this.authState.state === \"noAuth\" ||\n      // We failed on a fresh token. After a small number of retries, we give up\n      // and clear the auth state to avoid infinite retries.\n      (this.authState.state === \"waitingForServerConfirmationOfFreshToken\" &&\n        this.tokenConfirmationAttempts >= MAX_TOKEN_CONFIRMATION_ATTEMPTS)\n    ) {\n      this.logger.error(\n        `Failed to authenticate: \"${serverMessage.error}\", check your server auth config`,\n      );\n      if (this.syncState.hasAuth()) {\n        this.syncState.clearAuth();\n      }\n      if (this.authState.state !== \"noAuth\") {\n        this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n      }\n      return;\n    }\n    if (this.authState.state === \"waitingForServerConfirmationOfFreshToken\") {\n      this.tokenConfirmationAttempts++;\n      this._logVerbose(\n        `retrying reauthentication, ${MAX_TOKEN_CONFIRMATION_ATTEMPTS - this.tokenConfirmationAttempts} attempts remaining`,\n      );\n    }\n\n    await this.stopSocket();\n    const token = await this.fetchTokenAndGuardAgainstRace(\n      this.authState.config.fetchToken,\n      {\n        forceRefreshToken: true,\n      },\n    );\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n\n    if (token.value && this.syncState.isNewAuth(token.value)) {\n      this.authenticate(token.value);\n      this.setAuthState({\n        state: \"waitingForServerConfirmationOfFreshToken\",\n        config: this.authState.config,\n        token: token.value,\n        hadAuth:\n          this.authState.state === \"notRefetching\" ||\n          this.authState.state === \"waitingForScheduledRefetch\",\n      });\n    } else {\n      this._logVerbose(\"reauthentication failed, could not fetch a new token\");\n      if (this.syncState.hasAuth()) {\n        this.syncState.clearAuth();\n      }\n      this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n    }\n    this.tryRestartSocket();\n  }\n\n  // Force refetch the token and schedule another refetch\n  // before the token expires - an active client should never\n  // need to reauthenticate.\n  private async refetchToken() {\n    if (this.authState.state === \"noAuth\") {\n      return;\n    }\n    this._logVerbose(\"refetching auth token\");\n    const token = await this.fetchTokenAndGuardAgainstRace(\n      this.authState.config.fetchToken,\n      {\n        forceRefreshToken: true,\n      },\n    );\n    if (token.isFromOutdatedConfig) {\n      return;\n    }\n\n    if (token.value) {\n      if (this.syncState.isNewAuth(token.value)) {\n        this.setAuthState({\n          state: \"waitingForServerConfirmationOfFreshToken\",\n          hadAuth: this.syncState.hasAuth(),\n          token: token.value,\n          config: this.authState.config,\n        });\n        this.authenticate(token.value);\n      } else {\n        this.setAuthState({\n          state: \"notRefetching\",\n          config: this.authState.config,\n        });\n      }\n    } else {\n      this._logVerbose(\"refetching token failed\");\n      if (this.syncState.hasAuth()) {\n        this.clearAuth();\n      }\n      this.setAndReportAuthFailed(this.authState.config.onAuthChange);\n    }\n    // Restart in case this refetch was triggered via schedule during\n    // a reauthentication attempt.\n    this._logVerbose(\n      \"restarting WS after auth token fetch (if currently stopped)\",\n    );\n    this.tryRestartSocket();\n  }\n\n  private scheduleTokenRefetch(token: string) {\n    if (this.authState.state === \"noAuth\") {\n      return;\n    }\n    const decodedToken = this.decodeToken(token);\n    if (!decodedToken) {\n      // This is no longer really possible, because\n      // we wait on server response before scheduling token refetch,\n      // and the server currently requires JWT tokens.\n      this.logger.error(\n        \"Auth token is not a valid JWT, cannot refetch the token\",\n      );\n      return;\n    }\n    // iat: issued at time, UTC seconds timestamp at which the JWT was issued\n    // exp: expiration time, UTC seconds timestamp at which the JWT will expire\n    const { iat, exp } = decodedToken as { iat?: number; exp?: number };\n    if (!iat || !exp) {\n      this.logger.error(\n        \"Auth token does not have required fields, cannot refetch the token\",\n      );\n      return;\n    }\n    // Because the client and server clocks may be out of sync,\n    // we only know that the token will expire after `exp - iat`,\n    // and since we just fetched a fresh one we know when that\n    // will happen.\n    const tokenValiditySeconds = exp - iat;\n    if (tokenValiditySeconds <= 2) {\n      this.logger.error(\n        \"Auth token does not live long enough, cannot refetch the token\",\n      );\n      return;\n    }\n    // Attempt to refresh the token `refreshTokenLeewaySeconds` before it expires,\n    // or immediately if the token is already expiring soon.\n    let delay = Math.min(\n      MAXIMUM_REFRESH_DELAY,\n      (tokenValiditySeconds - this.refreshTokenLeewaySeconds) * 1000,\n    );\n    if (delay <= 0) {\n      // Refetch immediately, but this might be due to configuring a `refreshTokenLeewaySeconds`\n      // that is too large compared to the token's actual lifetime.\n      this.logger.warn(\n        `Refetching auth token immediately, configured leeway ${this.refreshTokenLeewaySeconds}s is larger than the token's lifetime ${tokenValiditySeconds}s`,\n      );\n      delay = 0;\n    }\n    const refetchTokenTimeoutId = setTimeout(() => {\n      this._logVerbose(\"running scheduled token refetch\");\n      void this.refetchToken();\n    }, delay);\n    this.setAuthState({\n      state: \"waitingForScheduledRefetch\",\n      refetchTokenTimeoutId,\n      config: this.authState.config,\n    });\n    this._logVerbose(\n      `scheduled preemptive auth token refetching in ${delay}ms`,\n    );\n  }\n\n  // Protects against simultaneous calls to `setConfig`\n  // while we're fetching a token\n  private async fetchTokenAndGuardAgainstRace(\n    fetchToken: AuthTokenFetcher,\n    fetchArgs: {\n      forceRefreshToken: boolean;\n    },\n  ) {\n    const originalConfigVersion = ++this.configVersion;\n    this._logVerbose(\n      `fetching token with config version ${originalConfigVersion}`,\n    );\n    const token = await fetchToken(fetchArgs);\n    if (this.configVersion !== originalConfigVersion) {\n      // This is a stale config\n      this._logVerbose(\n        `stale config version, expected ${originalConfigVersion}, got ${this.configVersion}`,\n      );\n      return { isFromOutdatedConfig: true };\n    }\n    return { isFromOutdatedConfig: false, value: token };\n  }\n\n  stop() {\n    this.resetAuthState();\n    // Bump this in case we are mid-token-fetch when we get stopped\n    this.configVersion++;\n    this._logVerbose(`config version bumped to ${this.configVersion}`);\n  }\n\n  private setAndReportAuthFailed(\n    onAuthChange: (authenticated: boolean) => void,\n  ) {\n    onAuthChange(false);\n    this.resetAuthState();\n  }\n\n  private resetAuthState() {\n    this.setAuthState({ state: \"noAuth\" });\n  }\n\n  private setAuthState(newAuth: AuthState) {\n    const authStateForLog =\n      newAuth.state === \"waitingForServerConfirmationOfFreshToken\"\n        ? {\n            hadAuth: newAuth.hadAuth,\n            state: newAuth.state,\n            token: `...${newAuth.token.slice(-7)}`,\n          }\n        : { state: newAuth.state };\n    this._logVerbose(\n      `setting auth state to ${JSON.stringify(authStateForLog)}`,\n    );\n    switch (newAuth.state) {\n      case \"waitingForScheduledRefetch\":\n      case \"notRefetching\":\n      case \"noAuth\":\n        this.tokenConfirmationAttempts = 0;\n        break;\n      case \"waitingForServerConfirmationOfFreshToken\":\n      case \"waitingForServerConfirmationOfCachedToken\":\n      case \"initialRefetch\":\n        break;\n      default: {\n        const _typeCheck: never = newAuth;\n      }\n    }\n    if (this.authState.state === \"waitingForScheduledRefetch\") {\n      clearTimeout(this.authState.refetchTokenTimeoutId);\n\n      // The waitingForScheduledRefetch state is the most quiesced authed state.\n      // Let the syncState know that auth is in a good state, so it can reset failure backoffs\n      this.syncState.markAuthCompletion();\n    }\n    this.authState = newAuth;\n  }\n\n  private decodeToken(token: string) {\n    try {\n      return jwtDecode(token);\n    } catch (e) {\n      this._logVerbose(\n        `Error decoding token: ${e instanceof Error ? e.message : \"Unknown error\"}`,\n      );\n      return null;\n    }\n  }\n\n  private _logVerbose(message: string) {\n    this.logger.logVerbose(`${message} [v${this.configVersion}]`);\n  }\n}\n", "import { BaseConvexClient } from \"../browser/index.js\";\nimport type { OptimisticUpdate, QueryToken } from \"../browser/index.js\";\nimport React, { useContext, useMemo } from \"react\";\nimport { convexToJson, Value } from \"../values/index.js\";\nimport ReactDOM from \"react-dom\";\nimport { QueryJournal } from \"../browser/sync/protocol.js\";\nimport {\n  AuthTokenFetcher,\n  BaseConvexClientOptions,\n  ConnectionState,\n} from \"../browser/sync/client.js\";\nimport type { UserIdentityAttributes } from \"../browser/sync/protocol.js\";\nimport { RequestForQueries, useQueries } from \"./use_queries.js\";\nimport { parseArgs } from \"../common/index.js\";\nimport {\n  ArgsAndOptions,\n  FunctionArgs,\n  FunctionReference,\n  FunctionReturnType,\n  OptionalRestArgs,\n  getFunctionName,\n  makeFunctionReference,\n} from \"../server/api.js\";\nimport { EmptyObject } from \"../server/registration.js\";\nimport { instantiateDefaultLogger, Logger } from \"../browser/logging.js\";\n\nif (typeof React === \"undefined\") {\n  throw new Error(\"Required dependency 'react' not found\");\n}\nif (typeof ReactDOM === \"undefined\") {\n  throw new Error(\"Required dependency 'react-dom' not found\");\n}\n\n// TODO Typedoc doesn't generate documentation for the comment below perhaps\n// because it's a callable interface.\n/**\n * An interface to execute a Convex mutation function on the server.\n *\n * @public\n */\nexport interface ReactMutation<Mutation extends FunctionReference<\"mutation\">> {\n  /**\n   * Execute the mutation on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the mutation to pass up to the server.\n   * @returns The return value of the server-side function call.\n   */\n  (...args: OptionalRestArgs<Mutation>): Promise<FunctionReturnType<Mutation>>;\n\n  /**\n   * Define an optimistic update to apply as part of this mutation.\n   *\n   * This is a temporary update to the local query results to facilitate a\n   * fast, interactive UI. It enables query results to update before a mutation\n   * executed on the server.\n   *\n   * When the mutation is invoked, the optimistic update will be applied.\n   *\n   * Optimistic updates can also be used to temporarily remove queries from the\n   * client and create loading experiences until a mutation completes and the\n   * new query results are synced.\n   *\n   * The update will be automatically rolled back when the mutation is fully\n   * completed and queries have been updated.\n   *\n   * @param optimisticUpdate - The optimistic update to apply.\n   * @returns A new `ReactMutation` with the update configured.\n   *\n   * @public\n   */\n  withOptimisticUpdate(\n    optimisticUpdate: OptimisticUpdate<FunctionArgs<Mutation>>,\n  ): ReactMutation<Mutation>;\n}\n\n// Exported only for testing.\nexport function createMutation(\n  mutationReference: FunctionReference<\"mutation\">,\n  client: ConvexReactClient,\n  update?: OptimisticUpdate<any>,\n): ReactMutation<any> {\n  function mutation(args?: Record<string, Value>): Promise<unknown> {\n    assertNotAccidentalArgument(args);\n\n    return client.mutation(mutationReference, args, {\n      optimisticUpdate: update,\n    });\n  }\n  mutation.withOptimisticUpdate = function withOptimisticUpdate(\n    optimisticUpdate: OptimisticUpdate<any>,\n  ): ReactMutation<any> {\n    if (update !== undefined) {\n      throw new Error(\n        `Already specified optimistic update for mutation ${getFunctionName(\n          mutationReference,\n        )}`,\n      );\n    }\n    return createMutation(mutationReference, client, optimisticUpdate);\n  };\n  return mutation as ReactMutation<any>;\n}\n\n/**\n * An interface to execute a Convex action on the server.\n *\n * @public\n */\nexport interface ReactAction<Action extends FunctionReference<\"action\">> {\n  /**\n   * Execute the function on the server, returning a `Promise` of its return value.\n   *\n   * @param args - Arguments for the function to pass up to the server.\n   * @returns The return value of the server-side function call.\n   * @public\n   */\n  (...args: OptionalRestArgs<Action>): Promise<FunctionReturnType<Action>>;\n}\n\nfunction createAction(\n  actionReference: FunctionReference<\"action\">,\n  client: ConvexReactClient,\n): ReactAction<any> {\n  return function (args?: Record<string, Value>): Promise<unknown> {\n    return client.action(actionReference, args);\n  } as ReactAction<any>;\n}\n\n/**\n * A watch on the output of a Convex query function.\n *\n * @public\n */\nexport interface Watch<T> {\n  /**\n   * Initiate a watch on the output of a query.\n   *\n   * This will subscribe to this query and call\n   * the callback whenever the query result changes.\n   *\n   * **Important: If the client is already subscribed to this query with the\n   * same arguments this callback will not be invoked until the query result is\n   * updated.** To get the current, local result call\n   * {@link react.Watch.localQueryResult}.\n   *\n   * @param callback - Function that is called whenever the query result changes.\n   * @returns - A function that disposes of the subscription.\n   */\n  onUpdate(callback: () => void): () => void;\n\n  /**\n   * Get the current result of a query.\n   *\n   * This will only return a result if we're already subscribed to the query\n   * and have received a result from the server or the query value has been set\n   * optimistically.\n   *\n   * @returns The result of the query or `undefined` if it isn't known.\n   * @throws An error if the query encountered an error on the server.\n   */\n  localQueryResult(): T | undefined;\n\n  /**\n   * @internal\n   */\n  localQueryLogs(): string[] | undefined;\n\n  /**\n   * Get the current {@link browser.QueryJournal} for this query.\n   *\n   * If we have not yet received a result for this query, this will be `undefined`.\n   */\n  journal(): QueryJournal | undefined;\n}\n\n/**\n * Options for {@link ConvexReactClient.watchQuery}.\n *\n * @public\n */\nexport interface WatchQueryOptions {\n  /**\n   * An (optional) journal produced from a previous execution of this query\n   * function.\n   *\n   * If there is an existing subscription to a query function with the same\n   * name and arguments, this journal will have no effect.\n   */\n  journal?: QueryJournal;\n\n  /**\n   * @internal\n   */\n  componentPath?: string;\n}\n\n/**\n * Options for {@link ConvexReactClient.mutation}.\n *\n * @public\n */\nexport interface MutationOptions<Args extends Record<string, Value>> {\n  /**\n   * An optimistic update to apply along with this mutation.\n   *\n   * An optimistic update locally updates queries while a mutation is pending.\n   * Once the mutation completes, the update will be rolled back.\n   */\n  optimisticUpdate?: OptimisticUpdate<Args>;\n}\n\n/**\n * Options for {@link ConvexReactClient}.\n *\n * @public\n */\nexport interface ConvexReactClientOptions extends BaseConvexClientOptions {}\n\n/**\n * A Convex client for use within React.\n *\n * This loads reactive queries and executes mutations over a WebSocket.\n *\n * @public\n */\nexport class ConvexReactClient {\n  private address: string;\n  private cachedSync?: BaseConvexClient;\n  private listeners: Map<QueryToken, Set<() => void>>;\n  private options: ConvexReactClientOptions;\n  private closed = false;\n  private _logger: Logger;\n\n  private adminAuth?: string;\n  private fakeUserIdentity?: UserIdentityAttributes;\n\n  /**\n   * @param address - The url of your Convex deployment, often provided\n   * by an environment variable. E.g. `https://small-mouse-123.convex.cloud`.\n   * @param options - See {@link ConvexReactClientOptions} for a full description.\n   */\n  constructor(address: string, options?: ConvexReactClientOptions) {\n    // Validate address immediately since validation by the lazily-instantiated\n    // internal client does not occur synchronously.\n    if (address === undefined) {\n      throw new Error(\n        \"No address provided to ConvexReactClient.\\n\" +\n          \"If trying to deploy to production, make sure to follow all the instructions found at https://docs.convex.dev/production/hosting/\\n\" +\n          \"If running locally, make sure to run `convex dev` and ensure the .env.local file is populated.\",\n      );\n    }\n    if (typeof address !== \"string\") {\n      throw new Error(\n        `ConvexReactClient requires a URL like 'https://happy-otter-123.convex.cloud', received something of type ${typeof address} instead.`,\n      );\n    }\n    if (!address.includes(\"://\")) {\n      throw new Error(\"Provided address was not an absolute URL.\");\n    }\n    this.address = address;\n    this.listeners = new Map();\n    this._logger =\n      options?.logger ??\n      instantiateDefaultLogger({ verbose: options?.verbose ?? false });\n    this.options = { ...options, logger: this._logger };\n  }\n\n  /**\n   * Lazily instantiate the `BaseConvexClient` so we don't create the WebSocket\n   * when server-side rendering.\n   *\n   * @internal\n   */\n  get sync() {\n    if (this.closed) {\n      throw new Error(\"ConvexReactClient has already been closed.\");\n    }\n    if (this.cachedSync) {\n      return this.cachedSync;\n    }\n    this.cachedSync = new BaseConvexClient(\n      this.address,\n      (updatedQueries) => this.transition(updatedQueries),\n      this.options,\n    );\n    if (this.adminAuth) {\n      this.cachedSync.setAdminAuth(this.adminAuth, this.fakeUserIdentity);\n    }\n    return this.cachedSync;\n  }\n\n  /**\n   * Set the authentication token to be used for subsequent queries and mutations.\n   * `fetchToken` will be called automatically again if a token expires.\n   * `fetchToken` should return `null` if the token cannot be retrieved, for example\n   * when the user's rights were permanently revoked.\n   * @param fetchToken - an async function returning the JWT-encoded OpenID Connect Identity Token\n   * @param onChange - a callback that will be called when the authentication status changes\n   */\n  setAuth(\n    fetchToken: AuthTokenFetcher,\n    onChange?: (isAuthenticated: boolean) => void,\n  ) {\n    if (typeof fetchToken === \"string\") {\n      throw new Error(\n        \"Passing a string to ConvexReactClient.setAuth is no longer supported, \" +\n          \"please upgrade to passing in an async function to handle reauthentication.\",\n      );\n    }\n    this.sync.setAuth(\n      fetchToken,\n      onChange ??\n        (() => {\n          // Do nothing\n        }),\n    );\n  }\n\n  /**\n   * Clear the current authentication token if set.\n   */\n  clearAuth() {\n    this.sync.clearAuth();\n  }\n\n  /**\n   * @internal\n   */\n  setAdminAuth(token: string, identity?: UserIdentityAttributes) {\n    this.adminAuth = token;\n    this.fakeUserIdentity = identity;\n    if (this.closed) {\n      throw new Error(\"ConvexReactClient has already been closed.\");\n    }\n    if (this.cachedSync) {\n      this.sync.setAdminAuth(token, identity);\n    }\n  }\n\n  /**\n   * Construct a new {@link Watch} on a Convex query function.\n   *\n   * **Most application code should not call this method directly. Instead use\n   * the {@link useQuery} hook.**\n   *\n   * @param query - A {@link server.FunctionReference} for the public query to run.\n   * @param args - An arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @param options - A {@link WatchQueryOptions} options object for this query.\n   *\n   * @returns The {@link Watch} object.\n   */\n  watchQuery<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    ...argsAndOptions: ArgsAndOptions<Query, WatchQueryOptions>\n  ): Watch<FunctionReturnType<Query>> {\n    const [args, options] = argsAndOptions;\n    const name = getFunctionName(query);\n    return {\n      onUpdate: (callback) => {\n        const { queryToken, unsubscribe } = this.sync.subscribe(\n          name as string,\n          args,\n          options,\n        );\n\n        const currentListeners = this.listeners.get(queryToken);\n        if (currentListeners !== undefined) {\n          currentListeners.add(callback);\n        } else {\n          this.listeners.set(queryToken, new Set([callback]));\n        }\n\n        return () => {\n          if (this.closed) {\n            return;\n          }\n\n          const currentListeners = this.listeners.get(queryToken)!;\n          currentListeners.delete(callback);\n          if (currentListeners.size === 0) {\n            this.listeners.delete(queryToken);\n          }\n          unsubscribe();\n        };\n      },\n\n      localQueryResult: () => {\n        // Use the cached client because we can't have a query result if we don't\n        // even have a client yet!\n        if (this.cachedSync) {\n          return this.cachedSync.localQueryResult(name, args);\n        }\n        return undefined;\n      },\n\n      localQueryLogs: () => {\n        if (this.cachedSync) {\n          return this.cachedSync.localQueryLogs(name, args);\n        }\n        return undefined;\n      },\n\n      journal: () => {\n        if (this.cachedSync) {\n          return this.cachedSync.queryJournal(name, args);\n        }\n        return undefined;\n      },\n    };\n  }\n\n  /**\n   * Execute a mutation function.\n   *\n   * @param mutation - A {@link server.FunctionReference} for the public mutation\n   * to run.\n   * @param args - An arguments object for the mutation. If this is omitted,\n   * the arguments will be `{}`.\n   * @param options - A {@link MutationOptions} options object for the mutation.\n   * @returns A promise of the mutation's result.\n   */\n  mutation<Mutation extends FunctionReference<\"mutation\">>(\n    mutation: Mutation,\n    ...argsAndOptions: ArgsAndOptions<\n      Mutation,\n      MutationOptions<FunctionArgs<Mutation>>\n    >\n  ): Promise<FunctionReturnType<Mutation>> {\n    const [args, options] = argsAndOptions;\n    const name = getFunctionName(mutation);\n    return this.sync.mutation(name, args, options);\n  }\n\n  /**\n   * Execute an action function.\n   *\n   * @param action - A {@link server.FunctionReference} for the public action\n   * to run.\n   * @param args - An arguments object for the action. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the action's result.\n   */\n  action<Action extends FunctionReference<\"action\">>(\n    action: Action,\n    ...args: OptionalRestArgs<Action>\n  ): Promise<FunctionReturnType<Action>> {\n    const name = getFunctionName(action);\n    return this.sync.action(name, ...args);\n  }\n\n  /**\n   * Fetch a query result once.\n   *\n   * **Most application code should subscribe to queries instead, using\n   * the {@link useQuery} hook.**\n   *\n   * @param query - A {@link server.FunctionReference} for the public query\n   * to run.\n   * @param args - An arguments object for the query. If this is omitted,\n   * the arguments will be `{}`.\n   * @returns A promise of the query's result.\n   */\n  query<Query extends FunctionReference<\"query\">>(\n    query: Query,\n    ...args: OptionalRestArgs<Query>\n  ): Promise<FunctionReturnType<Query>> {\n    const watch = this.watchQuery(query, ...args);\n    const existingResult = watch.localQueryResult();\n    if (existingResult !== undefined) {\n      return Promise.resolve(existingResult);\n    }\n    return new Promise((resolve, reject) => {\n      const unsubscribe = watch.onUpdate(() => {\n        unsubscribe();\n        try {\n          resolve(watch.localQueryResult());\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  }\n\n  /**\n   * Get the current {@link ConnectionState} between the client and the Convex\n   * backend.\n   *\n   * @returns The {@link ConnectionState} with the Convex backend.\n   */\n  connectionState(): ConnectionState {\n    return this.sync.connectionState();\n  }\n\n  /**\n   * Get the logger for this client.\n   *\n   * @returns The {@link Logger} for this client.\n   */\n  get logger(): Logger {\n    return this._logger;\n  }\n\n  /**\n   * Close any network handles associated with this client and stop all subscriptions.\n   *\n   * Call this method when you're done with a {@link ConvexReactClient} to\n   * dispose of its sockets and resources.\n   *\n   * @returns A `Promise` fulfilled when the connection has been completely closed.\n   */\n  async close(): Promise<void> {\n    this.closed = true;\n    // Prevent outstanding React batched updates from invoking listeners.\n    this.listeners = new Map();\n    if (this.cachedSync) {\n      const sync = this.cachedSync;\n      this.cachedSync = undefined;\n      await sync.close();\n    }\n  }\n\n  private transition(updatedQueries: QueryToken[]) {\n    ReactDOM.unstable_batchedUpdates(() => {\n      for (const queryToken of updatedQueries) {\n        const callbacks = this.listeners.get(queryToken);\n        if (callbacks) {\n          for (const callback of callbacks) {\n            callback();\n          }\n        }\n      }\n    });\n  }\n}\n\nconst ConvexContext = React.createContext<ConvexReactClient>(\n  undefined as unknown as ConvexReactClient, // in the future this will be a mocked client for testing\n);\n\n/**\n * Get the {@link ConvexReactClient} within a React component.\n *\n * This relies on the {@link ConvexProvider} being above in the React component tree.\n *\n * @returns The active {@link ConvexReactClient} object, or `undefined`.\n *\n * @public\n */\nexport function useConvex(): ConvexReactClient {\n  return useContext(ConvexContext);\n}\n\n/**\n * Provides an active Convex {@link ConvexReactClient} to descendants of this component.\n *\n * Wrap your app in this component to use Convex hooks `useQuery`,\n * `useMutation`, and `useConvex`.\n *\n * @param props - an object with a `client` property that refers to a {@link ConvexReactClient}.\n *\n * @public\n */\nexport const ConvexProvider: React.FC<{\n  client: ConvexReactClient;\n  children?: React.ReactNode;\n}> = ({ client, children }) => {\n  return React.createElement(\n    ConvexContext.Provider,\n    { value: client },\n    children,\n  );\n};\n\nexport type OptionalRestArgsOrSkip<FuncRef extends FunctionReference<any>> =\n  FuncRef[\"_args\"] extends EmptyObject\n    ? [args?: EmptyObject | \"skip\"]\n    : [args: FuncRef[\"_args\"] | \"skip\"];\n\n/**\n * Load a reactive query within a React component.\n *\n * This React hook contains internal state that will cause a rerender\n * whenever the query result changes.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * @param query - a {@link server.FunctionReference} for the public query to run\n * like `api.dir1.dir2.filename.func`.\n * @param args - The arguments to the query function or the string \"skip\" if the\n * query should not be loaded.\n * @returns the result of the query. If the query is loading returns `undefined`.\n *\n * @public\n */\nexport function useQuery<Query extends FunctionReference<\"query\">>(\n  query: Query,\n  ...args: OptionalRestArgsOrSkip<Query>\n): Query[\"_returnType\"] | undefined {\n  const skip = args[0] === \"skip\";\n  const argsObject = args[0] === \"skip\" ? {} : parseArgs(args[0]);\n\n  const queryReference =\n    typeof query === \"string\"\n      ? makeFunctionReference<\"query\", any, any>(query)\n      : query;\n\n  const queryName = getFunctionName(queryReference);\n\n  const queries = useMemo(\n    () =>\n      skip\n        ? ({} as RequestForQueries)\n        : { query: { query: queryReference, args: argsObject } },\n    // Stringify args so args that are semantically the same don't trigger a\n    // rerender. Saves developers from adding `useMemo` on every args usage.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [JSON.stringify(convexToJson(argsObject)), queryName, skip],\n  );\n\n  const results = useQueries(queries);\n  const result = results[\"query\"];\n  if (result instanceof Error) {\n    throw result;\n  }\n  return result;\n}\n\n/**\n * Construct a new {@link ReactMutation}.\n *\n * Mutation objects can be called like functions to request execution of the\n * corresponding Convex function, or further configured with\n * [optimistic updates](https://docs.convex.dev/using/optimistic-updates).\n *\n * The value returned by this hook is stable across renders, so it can be used\n * by React dependency arrays and memoization logic relying on object identity\n * without causing rerenders.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * @param mutation - A {@link server.FunctionReference} for the public mutation\n * to run like `api.dir1.dir2.filename.func`.\n * @returns The {@link ReactMutation} object with that name.\n *\n * @public\n */\nexport function useMutation<Mutation extends FunctionReference<\"mutation\">>(\n  mutation: Mutation,\n): ReactMutation<Mutation> {\n  const mutationReference =\n    typeof mutation === \"string\"\n      ? makeFunctionReference<\"mutation\", any, any>(mutation)\n      : mutation;\n\n  const convex = useContext(ConvexContext);\n  if (convex === undefined) {\n    throw new Error(\n      \"Could not find Convex client! `useMutation` must be used in the React component \" +\n        \"tree under `ConvexProvider`. Did you forget it? \" +\n        \"See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\",\n    );\n  }\n  return useMemo(\n    () => createMutation(mutationReference, convex),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [convex, getFunctionName(mutationReference)],\n  );\n}\n\n/**\n * Construct a new {@link ReactAction}.\n *\n * Action objects can be called like functions to request execution of the\n * corresponding Convex function.\n *\n * The value returned by this hook is stable across renders, so it can be used\n * by React dependency arrays and memoization logic relying on object identity\n * without causing rerenders.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * @param action - A {@link server.FunctionReference} for the public action\n * to run like `api.dir1.dir2.filename.func`.\n * @returns The {@link ReactAction} object with that name.\n *\n * @public\n */\nexport function useAction<Action extends FunctionReference<\"action\">>(\n  action: Action,\n): ReactAction<Action> {\n  const convex = useContext(ConvexContext);\n  const actionReference =\n    typeof action === \"string\"\n      ? makeFunctionReference<\"action\", any, any>(action)\n      : action;\n\n  if (convex === undefined) {\n    throw new Error(\n      \"Could not find Convex client! `useAction` must be used in the React component \" +\n        \"tree under `ConvexProvider`. Did you forget it? \" +\n        \"See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\",\n    );\n  }\n  return useMemo(\n    () => createAction(actionReference, convex),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [convex, getFunctionName(actionReference)],\n  );\n}\n\n// When a function is called with a single argument that looks like a\n// React SyntheticEvent it was likely called as an event handler.\nfunction assertNotAccidentalArgument(value: any) {\n  // these are properties of a React.SyntheticEvent\n  // https://reactjs.org/docs/events.html\n  if (\n    typeof value === \"object\" &&\n    value !== null &&\n    \"bubbles\" in value &&\n    \"persist\" in value &&\n    \"isDefaultPrevented\" in value\n  ) {\n    throw new Error(\n      `Convex function called with SyntheticEvent object. Did you use a Convex function as an event handler directly? Event handlers like onClick receive an event object as their first argument. These SyntheticEvent objects are not valid Convex values. Try wrapping the function like \\`const handler = () => myMutation();\\` and using \\`handler\\` in the event handler.`,\n    );\n  }\n}\n", "import { Value } from \"../values/index.js\";\nimport { useEffect, useMemo, useState } from \"react\";\nimport { useConvex } from \"./client.js\";\nimport { CreateWatch, QueriesObserver } from \"./queries_observer.js\";\nimport { useSubscription } from \"./use_subscription.js\";\nimport { QueryJournal } from \"../browser/index.js\";\nimport { FunctionReference } from \"../server/api.js\";\n\n/**\n * Load a variable number of reactive Convex queries.\n *\n * `useQueries` is similar to {@link useQuery} but it allows\n * loading multiple queries which can be useful for loading a dynamic number\n * of queries without violating the rules of React hooks.\n *\n * This hook accepts an object whose keys are identifiers for each query and the\n * values are objects of `{ query: FunctionReference, args: Record<string, Value> }`. The\n * `query` is a FunctionReference for the Convex query function to load, and the `args` are\n * the arguments to that function.\n *\n * The hook returns an object that maps each identifier to the result of the query,\n * `undefined` if the query is still loading, or an instance of `Error` if the query\n * threw an exception.\n *\n * For example if you loaded a query like:\n * ```typescript\n * const results = useQueries({\n *   messagesInGeneral: {\n *     query: \"listMessages\",\n *     args: { channel: \"#general\" }\n *   }\n * });\n * ```\n * then the result would look like:\n * ```typescript\n * {\n *   messagesInGeneral: [{\n *     channel: \"#general\",\n *     body: \"hello\"\n *     _id: ...,\n *     _creationTime: ...\n *   }]\n * }\n * ```\n *\n * This React hook contains internal state that will cause a rerender\n * whenever any of the query results change.\n *\n * Throws an error if not used under {@link ConvexProvider}.\n *\n * @param queries - An object mapping identifiers to objects of\n * `{query: string, args: Record<string, Value> }` describing which query\n * functions to fetch.\n * @returns An object with the same keys as the input. The values are the result\n * of the query function, `undefined` if it's still loading, or an `Error` if\n * it threw an exception.\n *\n * @public\n */\nexport function useQueries(\n  queries: RequestForQueries,\n): Record<string, any | undefined | Error> {\n  const convex = useConvex();\n  if (convex === undefined) {\n    // Error message includes `useQuery` because this hook is called by `useQuery`\n    // more often than it's called directly.\n    throw new Error(\n      \"Could not find Convex client! `useQuery` must be used in the React component \" +\n        \"tree under `ConvexProvider`. Did you forget it? \" +\n        \"See https://docs.convex.dev/quick-start#set-up-convex-in-your-react-app\",\n    );\n  }\n  const createWatch = useMemo(() => {\n    return (\n      query: FunctionReference<\"query\">,\n      args: Record<string, Value>,\n      journal?: QueryJournal,\n    ) => {\n      return convex.watchQuery(query, args, { journal });\n    };\n  }, [convex]);\n  return useQueriesHelper(queries, createWatch);\n}\n\n/**\n * Internal version of `useQueries` that is exported for testing.\n */\nexport function useQueriesHelper(\n  queries: RequestForQueries,\n  createWatch: CreateWatch,\n): Record<string, any | undefined | Error> {\n  const [observer] = useState(() => new QueriesObserver(createWatch));\n\n  if (observer.createWatch !== createWatch) {\n    observer.setCreateWatch(createWatch);\n  }\n\n  // Unsubscribe from all queries on unmount.\n  useEffect(() => () => observer.destroy(), [observer]);\n\n  const subscription = useMemo(\n    () => ({\n      getCurrentValue: () => {\n        return observer.getLocalResults(queries);\n      },\n      subscribe: (callback: () => void) => {\n        observer.setQueries(queries);\n        return observer.subscribe(callback);\n      },\n    }),\n    [observer, queries],\n  );\n\n  return useSubscription(subscription);\n}\n\n/**\n * An object representing a request to load multiple queries.\n *\n * The keys of this object are identifiers and the values are objects containing\n * the query function and the arguments to pass to it.\n *\n * This is used as an argument to {@link useQueries}.\n * @public\n */\nexport type RequestForQueries = Record<\n  string,\n  {\n    query: FunctionReference<\"query\">;\n    args: Record<string, Value>;\n  }\n>;\n", "import { useEffect, useState } from \"react\";\n\n/*\nThis code is taken from https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\nbecause correct subscriptions in async React is complex!\n\nIt could probably be replaced with `useSyncExternalStore()`.\n\nThe MIT License (MIT)\nCopyright \u00A9 2023 Brian Vaughn\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \u201CSoftware\u201D), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \u201CAS IS\u201D, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n/**\n * Hook used for safely managing subscriptions in concurrent mode.\n *\n * In order to avoid removing and re-adding subscriptions each time this hook is called,\n * the parameters passed to this hook should be memoized in some way\u2013\n * either by wrapping the entire params object with useMemo()\n * or by wrapping the individual callbacks with useCallback().\n *\n * @internal\n */\nexport function useSubscription<Value>({\n  // (Synchronously) returns the current value of our subscription.\n  getCurrentValue,\n\n  // This function is passed an event handler to attach to the subscription.\n  // It should return an unsubscribe function that removes the handler.\n  subscribe,\n}: {\n  getCurrentValue: () => Value;\n  subscribe: (callback: () => void) => () => void;\n}): Value {\n  // Read the current value from our subscription.\n  // When this value changes, we'll schedule an update with React.\n  // It's important to also store the hook params so that we can check for staleness.\n  // (See the comment in checkForUpdates() below for more info.)\n  const [state, setState] = useState(() => ({\n    getCurrentValue,\n    subscribe,\n    value: getCurrentValue(),\n  }));\n\n  let valueToReturn = state.value;\n\n  // If parameters have changed since our last render, schedule an update with its current value.\n  if (\n    state.getCurrentValue !== getCurrentValue ||\n    state.subscribe !== subscribe\n  ) {\n    // If the subscription has been updated, we'll schedule another update with React.\n    // React will process this update immediately, so the old subscription value won't be committed.\n    // It is still nice to avoid returning a mismatched value though, so let's override the return value.\n    valueToReturn = getCurrentValue();\n\n    setState({\n      getCurrentValue,\n      subscribe,\n      value: valueToReturn,\n    });\n  }\n\n  // It is important not to subscribe while rendering because this can lead to memory leaks.\n  // (Learn more at reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects)\n  // Instead, we wait until the commit phase to attach our handler.\n  //\n  // We intentionally use a passive effect (useEffect) rather than a synchronous one (useLayoutEffect)\n  // so that we don't stretch the commit phase.\n  // This also has an added benefit when multiple components are subscribed to the same source:\n  // It allows each of the event handlers to safely schedule work without potentially removing an another handler.\n  // (Learn more at https://codesandbox.io/s/k0yvr5970o)\n  useEffect(() => {\n    let didUnsubscribe = false;\n\n    const checkForUpdates = () => {\n      // It's possible that this callback will be invoked even after being unsubscribed,\n      // if it's removed as a result of a subscription event/update.\n      // In this case, React will log a DEV warning about an update from an unmounted component.\n      // We can avoid triggering that warning with this check.\n      if (didUnsubscribe) {\n        return;\n      }\n\n      setState((prevState) => {\n        // Ignore values from stale sources!\n        // Since we subscribe an unsubscribe in a passive effect,\n        // it's possible that this callback will be invoked for a stale (previous) subscription.\n        // This check avoids scheduling an update for that stale subscription.\n        if (\n          prevState.getCurrentValue !== getCurrentValue ||\n          prevState.subscribe !== subscribe\n        ) {\n          return prevState;\n        }\n\n        // Some subscriptions will auto-invoke the handler, even if the value hasn't changed.\n        // If the value hasn't changed, no update is needed.\n        // Return state as-is so React can bail out and avoid an unnecessary render.\n        const value = getCurrentValue();\n        if (prevState.value === value) {\n          return prevState;\n        }\n\n        return { ...prevState, value };\n      });\n    };\n    const unsubscribe = subscribe(checkForUpdates);\n\n    // Because we're subscribing in a passive effect,\n    // it's possible that an update has occurred between render and our effect handler.\n    // Check for this and schedule an update if work has occurred.\n    checkForUpdates();\n\n    return () => {\n      didUnsubscribe = true;\n      unsubscribe();\n    };\n  }, [getCurrentValue, subscribe]);\n\n  // Return the current value for our caller to use while rendering.\n  return valueToReturn;\n}\n"],
  "mappings": "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",
  "names": ["import_react", "import_react", "value", "__publicField", "import_react", "import_react", "React", "ReactDOM", "React", "React", "React", "React"]
}
