{
  "version": 3,
  "sources": ["../../../../@convex-dev/react-query/src/index.ts"],
  "sourcesContent": ["import {\n  QueryCache,\n  QueryClient,\n  QueryFunction,\n  QueryFunctionContext,\n  QueryKey,\n  UseQueryOptions,\n  UseSuspenseQueryOptions,\n  hashKey,\n  notifyManager,\n} from \"@tanstack/react-query\";\nimport { ConvexHttpClient } from \"convex/browser\";\nimport {\n  ConvexReactClient,\n  ConvexReactClientOptions,\n  Watch,\n} from \"convex/react\";\nimport {\n  FunctionArgs,\n  FunctionReference,\n  FunctionReturnType,\n  getFunctionName,\n} from \"convex/server\";\nimport { convexToJson } from \"convex/values\";\n\n// Re-export React Query-friendly names for Convex hooks.\n// Never importing \"convex/react\" from application code should\n// prevent import completion of the Convex `useQuery`.\nexport {\n  useQuery as useConvexQuery,\n  useQueries as useConvexQueries,\n  usePaginatedQuery as useConvexPaginatedQuery,\n  useMutation as useConvexMutation,\n  useAction as useConvexAction,\n  useConvex,\n  useConvexAuth,\n  optimisticallyUpdateValueInPaginatedQuery,\n} from \"convex/react\";\n\nconst isServer = typeof window === \"undefined\";\n\nfunction isConvexSkipped(\n  queryKey: readonly any[],\n): queryKey is [\"convexQuery\" | \"convexAction\", unknown, \"skip\"] {\n  return (\n    queryKey.length >= 2 &&\n    [\"convexQuery\", \"convexAction\"].includes(queryKey[0]) &&\n    queryKey[2] === \"skip\"\n  );\n}\n\nfunction isConvexQuery(\n  queryKey: readonly any[],\n): queryKey is [\n  \"convexQuery\",\n  FunctionReference<\"query\">,\n  Record<string, any>,\n  {},\n] {\n  return queryKey.length >= 2 && queryKey[0] === \"convexQuery\";\n}\n\nfunction isConvexAction(\n  queryKey: readonly any[],\n): queryKey is [\n  \"convexAction\",\n  FunctionReference<\"action\">,\n  Record<string, any>,\n  {},\n] {\n  return queryKey.length >= 2 && queryKey[0] === \"convexAction\";\n}\n\nfunction hash(\n  queryKey: [\n    \"convexQuery\",\n    FunctionReference<\"query\">,\n    Record<string, any>,\n    {},\n  ],\n): string {\n  return `convexQuery|${getFunctionName(queryKey[1])}|${JSON.stringify(\n    convexToJson(queryKey[2]),\n  )}`;\n}\n\nexport interface ConvexQueryClientOptions extends ConvexReactClientOptions {\n  /** queryClient can also be set later by calling .connect(ReactqueryClient) */\n  queryClient?: QueryClient;\n}\n\n/**\n * Subscribes to events from a TanStack Query QueryClient and populates query\n * results in it for all Convex query function subscriptions.\n */\nexport class ConvexQueryClient {\n  convexClient: ConvexReactClient;\n  subscriptions: Record<\n    string, // queryKey hash\n    {\n      watch: Watch<any>;\n      unsubscribe: () => void;\n      queryKey: [\n        convexKey: \"convexQuery\",\n        func: FunctionReference<\"query\">,\n        args: Record<string, any>,\n        options?: {},\n      ];\n    }\n  >;\n  unsubscribe: (() => void) | undefined;\n  // Only exists during SSR\n  serverHttpClient?: ConvexHttpClient;\n  _queryClient: QueryClient | undefined;\n  get queryClient() {\n    if (!this._queryClient) {\n      throw new Error(\n        \"ConvexQueryClient not connected to TanStack QueryClient.\",\n      );\n    }\n    return this._queryClient;\n  }\n  constructor(\n    /** A ConvexReactClient instance or a URL to use to instantiate one. */\n    client: ConvexReactClient | string,\n    /** Options mostly for the ConvexReactClient to be constructed. */\n    options: ConvexQueryClientOptions = {},\n  ) {\n    if (typeof client === \"string\") {\n      this.convexClient = new ConvexReactClient(client, options);\n    } else {\n      this.convexClient = client as ConvexReactClient;\n    }\n    this.subscriptions = {};\n    if (options.queryClient) {\n      this._queryClient = options.queryClient;\n      this.unsubscribe = this.subscribeInner(\n        options.queryClient.getQueryCache(),\n      );\n    }\n    if (isServer) {\n      this.serverHttpClient = new ConvexHttpClient(\n        // TODO use .url once convex@1.14 is released\n        (this.convexClient as any).address as string,\n      );\n    }\n  }\n  /** Complete initialization of ConvexQueryClient by connecting a TanStack QueryClient */\n  connect(queryClient: QueryClient) {\n    if (this.unsubscribe) {\n      throw new Error(\"already subscribed!\");\n    }\n    this._queryClient = queryClient;\n    this.unsubscribe = this.subscribeInner(queryClient.getQueryCache());\n  }\n\n  /** Update every query key. Probably not useful, don't use this. */\n  onUpdate = () => {\n    // Fortunately this does not reset the gc time.\n    notifyManager.batch(() => {\n      for (const key of Object.keys(this.subscriptions)) {\n        this.onUpdateQueryKeyHash(key);\n      }\n    });\n  };\n  onUpdateQueryKeyHash(queryHash: string) {\n    const subscription = this.subscriptions[queryHash];\n    if (!subscription) {\n      // If we have no record of this subscription that should be a logic error.\n      throw new Error(\n        `Internal ConvexQueryClient error: onUpdateQueryKeyHash called for ${queryHash}`,\n      );\n    }\n\n    const queryCache = this.queryClient.getQueryCache();\n    const query = queryCache.get(queryHash);\n    if (!query) return;\n\n    const { queryKey, watch } = subscription;\n    let result: { ok: true; value: any } | { ok: false; error: unknown };\n    try {\n      result = { ok: true, value: watch.localQueryResult() };\n    } catch (error) {\n      result = { ok: false, error };\n    }\n\n    if (result.ok) {\n      const value = result.value;\n      this.queryClient.setQueryData(queryKey, (prev) => {\n        if (prev === undefined) {\n          // If `prev` is undefined there is no react-query entry for this query key.\n          // Return `undefined` to signal not to create one.\n          return undefined;\n        }\n        return value;\n      });\n    } else {\n      const { error } = result;\n      // TODO This may not be a stable API. Devtools work this way so it's at\n      // least used elsewhere. Either trigger a query by invalidating this query\n      // (only feasible if guaranteed to update before the next tick) or\n      // look into a `QueryClient.setQueryError` API.\n      query?.setState(\n        {\n          error: error as Error,\n          errorUpdateCount: query.state.errorUpdateCount + 1,\n          errorUpdatedAt: Date.now(),\n          fetchFailureCount: query.state.fetchFailureCount + 1,\n          fetchFailureReason: error as Error,\n          fetchStatus: \"idle\",\n          status: \"error\",\n        },\n        { meta: \"set by ConvexQueryClient\" },\n      );\n    }\n  }\n\n  subscribeInner(queryCache: QueryCache): () => void {\n    if (isServer) return () => {};\n    return queryCache.subscribe((event) => {\n      if (!isConvexQuery(event.query.queryKey)) {\n        return;\n      }\n      if (isConvexSkipped(event.query.queryKey)) {\n        return;\n      }\n\n      switch (event.type) {\n        // A query has been GC'd so no stale value will be available.\n        // In Convex this means we should unsubscribe.\n        case \"removed\": {\n          this.subscriptions[event.query.queryHash].unsubscribe();\n          delete this.subscriptions[event.query.queryHash];\n          break;\n        }\n        // A query has been requested for the first time.\n        // Subscribe to the query so we hold on to it.\n        case \"added\": {\n          // There exists only one watch per subscription; but\n          // watches are stateless anyway, they're just util code.\n          const [_, func, args, _opts] = event.query.queryKey as [\n            \"convexQuery\",\n            FunctionReference<\"query\">,\n            any,\n            {},\n          ];\n          const watch = this.convexClient.watchQuery(\n            func,\n            args,\n            // TODO pass journals through\n            {},\n          );\n          const unsubscribe = watch.onUpdate(() => {\n            this.onUpdateQueryKeyHash(event.query.queryHash);\n          });\n\n          this.subscriptions[event.query.queryHash] = {\n            queryKey: event.query.queryKey,\n            watch,\n            unsubscribe,\n          };\n          break;\n        }\n        // Runs when a useQuery mounts\n        case \"observerAdded\": {\n          break;\n        }\n        // Runs when a useQuery unmounts\n        case \"observerRemoved\": {\n          if (event.query.getObserversCount() === 0) {\n            // The last useQuery subscribed to this query has unmounted.\n            // But don't clean up yet, after gcTime a \"removed\" event\n            // will notify that it's time to drop the subscription to\n            // the Convex backend.\n          }\n          break;\n        }\n        // Fires once per useQuery hook\n        case \"observerResultsUpdated\": {\n          break;\n        }\n        case \"updated\": {\n          if (\n            event.action.type === \"setState\" &&\n            event.action.setStateOptions?.meta === \"set by ConvexQueryClient\"\n          ) {\n            // This one was caused by us. This may be important to know for\n            // breaking infinite loops in the future.\n            break;\n          }\n          break;\n        }\n        case \"observerOptionsUpdated\": {\n          // observerOptionsUpdated, often because of an unmemoized query key\n          break;\n        }\n      }\n    });\n  }\n\n  /**\n   * Returns a promise for the query result of a query key containing\n   * `['convexQuery', FunctionReference, args]` and subscribes via WebSocket\n   * to future updates.\n   *\n   * You can provide a custom fetch function for queries that are not\n   * Convex queries.\n   */\n  queryFn(\n    otherFetch: QueryFunction<unknown, QueryKey> = throwBecauseNotConvexQuery,\n  ) {\n    return async <\n      ConvexQueryReference extends FunctionReference<\"query\", \"public\">,\n    >(\n      context: QueryFunctionContext<ReadonlyArray<unknown>>,\n    ): Promise<FunctionReturnType<ConvexQueryReference>> => {\n      if (isConvexSkipped(context.queryKey)) {\n        throw new Error(\n          \"Skipped query should not actually be run, should { enabled: false }\",\n        );\n      }\n      // Only queries can be requested consistently (at a previous timestamp),\n      // actions and mutations run at the latest timestamp.\n      if (isConvexQuery(context.queryKey)) {\n        const [_, func, args] = context.queryKey;\n        if (isServer) {\n          return await this.serverHttpClient!.consistentQuery(func, args);\n        } else {\n          return await this.convexClient.query(func, args);\n        }\n      }\n      if (isConvexAction(context.queryKey)) {\n        const [_, func, args] = context.queryKey;\n        if (isServer) {\n          const client = new ConvexHttpClient(\n            // TODO expose this private property\n            (this.convexClient as any).address as string,\n          );\n          const data = await client.action(func, args);\n          return data;\n        } else {\n          const data = await this.convexClient.action(func, args);\n          return data;\n        }\n      }\n      return otherFetch(context);\n    };\n  }\n\n  /**\n   * Set this globally to use Convex query functions.\n   *\n   * ```ts\n   * const queryClient = new QueryClient({\n   *   defaultOptions: {\n   *    queries: {\n   *       queryKeyHashFn: convexQueryClient.hashFn(),\n   *     },\n   *   },\n   * });\n   *\n   * You can provide a custom hash function for keys that are not for Convex\n   * queries.\n   */\n  hashFn(otherHashKey: (queryKey: ReadonlyArray<unknown>) => string = hashKey) {\n    return (queryKey: ReadonlyArray<unknown>) => {\n      if (isConvexQuery(queryKey)) {\n        return hash(queryKey);\n      }\n      return otherHashKey(queryKey);\n    };\n  }\n\n  /**\n   * Query options factory for Convex query function subscriptions.\n   *\n   * ```\n   * useQuery(client.queryOptions(api.foo.bar, args))\n   * ```\n   *\n   * If you need to specify other options spread it:\n   * ```\n   * useQuery({\n   *   ...convexQueryClient.queryOptions(api.foo.bar, args),\n   *   placeholderData: { name: \"me\" }\n   * });\n   * ```\n   */\n  queryOptions = <ConvexQueryReference extends FunctionReference<\"query\">>(\n    funcRef: ConvexQueryReference,\n    queryArgs: FunctionArgs<ConvexQueryReference>,\n  ): Pick<\n    UseQueryOptions<\n      FunctionReturnType<ConvexQueryReference>,\n      Error,\n      FunctionReturnType<ConvexQueryReference>,\n      [\"convexQuery\", ConvexQueryReference, FunctionArgs<ConvexQueryReference>]\n    >,\n    \"queryKey\" | \"queryFn\" | \"staleTime\"\n  > => {\n    return {\n      queryKey: [\n        \"convexQuery\",\n        // Make query key serializable\n        getFunctionName(funcRef) as unknown as typeof funcRef,\n        // TODO bigints are not serializable\n        queryArgs,\n      ],\n      queryFn: this.queryFn(),\n      staleTime: Infinity,\n      // We cannot set hashFn here, see\n      // https://github.com/TanStack/query/issues/4052#issuecomment-1296174282\n      // so the developer must set it globally.\n    };\n  };\n}\n\n/**\n * Query options factory for Convex query function subscriptions.\n * This options factory requires the `convexQueryClient.queryFn()` has been set\n * as the default `queryFn` globally.\n *\n * ```\n * useQuery(convexQuery(api.foo.bar, args))\n * ```\n *\n * If you need to specify other options spread it:\n * ```\n * useQuery({\n *   ...convexQuery(api.messages.list, { channel: 'dogs' }),\n *   placeholderData: [{ name: \"Snowy\" }]\n * });\n * ```\n */\nexport const convexQuery = <\n  ConvexQueryReference extends FunctionReference<\"query\">,\n  Args extends FunctionArgs<ConvexQueryReference> | \"skip\",\n>(\n  funcRef: ConvexQueryReference,\n  queryArgs: Args,\n): Args extends \"skip\"\n  ? Pick<\n      UseQueryOptions<\n        FunctionReturnType<ConvexQueryReference>,\n        Error,\n        FunctionReturnType<ConvexQueryReference>,\n        [\n          \"convexQuery\",\n          ConvexQueryReference,\n          FunctionArgs<ConvexQueryReference>,\n        ]\n      >,\n      \"queryKey\" | \"queryFn\" | \"staleTime\" | \"enabled\"\n    >\n  : Pick<\n      UseSuspenseQueryOptions<\n        FunctionReturnType<ConvexQueryReference>,\n        Error,\n        FunctionReturnType<ConvexQueryReference>,\n        [\n          \"convexQuery\",\n          ConvexQueryReference,\n          FunctionArgs<ConvexQueryReference>,\n        ]\n      >,\n      \"queryKey\" | \"queryFn\" | \"staleTime\"\n    > => {\n  return {\n    queryKey: [\n      \"convexQuery\",\n      // Make query key serializable\n      getFunctionName(funcRef) as unknown as typeof funcRef,\n      // TODO bigints are not serializable\n      queryArgs === \"skip\" ? \"skip\" : queryArgs,\n    ],\n    staleTime: Infinity,\n    ...(queryArgs === \"skip\" ? { enabled: false } : {}),\n  };\n};\n\n/**\n * Query options factory for Convex action function.\n * Not that Convex actions are live updating: they follow the normal react-query\n * semantics of refreshing on\n *\n * ```\n * useQuery(convexQuery(api.weather.now, { location: \"SF\" }))\n * ```\n *\n * If you need to specify other options spread it:\n * ```\n * useQuery({\n *   ...convexAction(api.weather.now, { location: \"SF\" }),\n *   placeholderData: { status: \"foggy and cool\" }\n * });\n * ```\n */\nexport const convexAction = <\n  ConvexActionReference extends FunctionReference<\"action\">,\n  Args extends FunctionArgs<ConvexActionReference> | \"skip\",\n>(\n  funcRef: ConvexActionReference,\n  args: Args,\n): Args extends \"skip\"\n  ? Pick<\n      UseQueryOptions<\n        FunctionReturnType<ConvexActionReference>,\n        Error,\n        FunctionReturnType<ConvexActionReference>,\n        [\n          \"convexAction\",\n          ConvexActionReference,\n          FunctionArgs<ConvexActionReference>,\n        ]\n      >,\n      \"queryKey\" | \"queryFn\" | \"staleTime\" | \"enabled\"\n    >\n  : Pick<\n      UseSuspenseQueryOptions<\n        FunctionReturnType<ConvexActionReference>,\n        Error,\n        FunctionReturnType<ConvexActionReference>,\n        [\n          \"convexAction\",\n          ConvexActionReference,\n          FunctionArgs<ConvexActionReference>,\n        ]\n      >,\n      \"queryKey\" | \"queryFn\" | \"staleTime\"\n    > => {\n  return {\n    queryKey: [\n      \"convexAction\",\n      // Make query key serializable\n      getFunctionName(funcRef) as unknown as typeof funcRef,\n      // TODO bigints are not serializable\n      args === \"skip\" ? {} : args,\n    ],\n    ...(args === \"skip\" ? { enabled: false } : {}),\n  };\n};\n\nfunction throwBecauseNotConvexQuery(\n  context: QueryFunctionContext<ReadonlyArray<unknown>>,\n) {\n  throw new Error(\"Query key is not for a Convex Query: \" + context.queryKey);\n}\n"],
  "mappings": "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",
  "names": []
}
