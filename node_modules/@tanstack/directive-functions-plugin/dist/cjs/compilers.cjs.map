{"version":3,"file":"compilers.cjs","sources":["../../src/compilers.ts"],"sourcesContent":["import * as babel from '@babel/core'\nimport { isIdentifier, isVariableDeclarator } from '@babel/types'\nimport { codeFrameColumns } from '@babel/code-frame'\nimport {\n  deadCodeElimination,\n  findReferencedIdentifiers,\n} from 'babel-dead-code-elimination'\nimport { generateFromAst, parseAst } from '@tanstack/router-utils'\nimport type { GeneratorResult, ParseAstOptions } from '@tanstack/router-utils'\n\nexport interface DirectiveFn {\n  nodePath: SupportedFunctionPath\n  functionName: string\n  functionId: string\n  extractedFilename: string\n  filename: string\n  chunkName: string\n}\n\nexport type SupportedFunctionPath =\n  | babel.NodePath<babel.types.FunctionDeclaration>\n  | babel.NodePath<babel.types.FunctionExpression>\n  | babel.NodePath<babel.types.ArrowFunctionExpression>\n\nexport type ReplacerFn = (opts: {\n  fn: string\n  extractedFilename: string\n  filename: string\n  functionId: string\n  isSourceFn: boolean\n}) => string\n\n// const debug = process.env.TSR_VITE_DEBUG === 'true'\n\nexport type CompileDirectivesOpts = ParseAstOptions & {\n  directive: string\n  directiveLabel: string\n  getRuntimeCode?: (opts: {\n    directiveFnsById: Record<string, DirectiveFn>\n  }) => string\n  replacer: ReplacerFn\n  // devSplitImporter: string\n}\n\nfunction buildDirectiveSplitParam(opts: CompileDirectivesOpts) {\n  return `tsr-directive-${opts.directive.replace(/[^a-zA-Z0-9]/g, '-')}`\n}\n\nexport function compileDirectives(opts: CompileDirectivesOpts): {\n  compiledResult: GeneratorResult\n  directiveFnsById: Record<string, DirectiveFn>\n} {\n  const directiveSplitParam = buildDirectiveSplitParam(opts)\n  const isDirectiveSplitParam = opts.filename.includes(directiveSplitParam)\n\n  const ast = parseAst(opts)\n  const refIdents = findReferencedIdentifiers(ast)\n  const directiveFnsById = findDirectives(ast, {\n    ...opts,\n    directiveSplitParam,\n  })\n\n  const directiveFnsByFunctionName = Object.fromEntries(\n    Object.entries(directiveFnsById).map(([, fn]) => [fn.functionName, fn]),\n  )\n\n  // Add runtime code if there are directives\n  if (Object.keys(directiveFnsById).length > 0) {\n    // // Add a vite import to the top of the file\n    // ast.program.body.unshift(\n    //   babel.types.importDeclaration(\n    //     [babel.types.importDefaultSpecifier(babel.types.identifier('vite'))],\n    //     babel.types.stringLiteral('vite'),\n    //   ),\n    // )\n\n    if (opts.getRuntimeCode) {\n      const runtimeImport = babel.template.statement(\n        opts.getRuntimeCode({ directiveFnsById }),\n      )()\n      ast.program.body.unshift(runtimeImport)\n    }\n  }\n\n  // If we are in the source file, we need to remove all exports\n  // then make sure that all of our functions are exported under their\n  // directive name\n  if (isDirectiveSplitParam) {\n    safeRemoveExports(ast)\n\n    // Export a single object with all of the functions\n    // e.g. export { directiveFn1, directiveFn2 }\n    ast.program.body.push(\n      babel.types.exportNamedDeclaration(\n        undefined,\n        Object.values(directiveFnsByFunctionName).map((fn) =>\n          babel.types.exportSpecifier(\n            babel.types.identifier(fn.functionName),\n            babel.types.identifier(fn.functionName),\n          ),\n        ),\n      ),\n    )\n  }\n\n  deadCodeElimination(ast, refIdents)\n\n  const compiledResult = generateFromAst(ast, {\n    sourceMaps: true,\n    sourceFileName: opts.filename,\n    filename: opts.filename,\n  })\n\n  return {\n    compiledResult,\n    directiveFnsById,\n  }\n}\n\nfunction findNearestVariableName(\n  path: babel.NodePath,\n  directiveLabel: string,\n): string {\n  let currentPath: babel.NodePath | null = path\n  const nameParts: Array<string> = []\n\n  while (currentPath) {\n    const name = (() => {\n      // Check for named function expression\n      if (\n        babel.types.isFunctionExpression(currentPath.node) &&\n        currentPath.node.id\n      ) {\n        return currentPath.node.id.name\n      }\n\n      // Handle method chains\n      if (babel.types.isCallExpression(currentPath.node)) {\n        const current = currentPath.node.callee\n        const chainParts: Array<string> = []\n\n        // Get the nearest method name (if it's a method call)\n        if (babel.types.isMemberExpression(current)) {\n          if (babel.types.isIdentifier(current.property)) {\n            chainParts.unshift(current.property.name)\n          }\n\n          // Get the base callee\n          let base = current.object\n          while (!babel.types.isIdentifier(base)) {\n            if (babel.types.isCallExpression(base)) {\n              base = base.callee as babel.types.Expression\n            } else if (babel.types.isMemberExpression(base)) {\n              base = base.object\n            } else {\n              break\n            }\n          }\n          if (babel.types.isIdentifier(base)) {\n            chainParts.unshift(base.name)\n          }\n        } else if (babel.types.isIdentifier(current)) {\n          chainParts.unshift(current.name)\n        }\n\n        if (chainParts.length > 0) {\n          return chainParts.join('_')\n        }\n      }\n\n      // Rest of the existing checks...\n      if (babel.types.isFunctionDeclaration(currentPath.node)) {\n        return currentPath.node.id?.name\n      }\n\n      if (babel.types.isIdentifier(currentPath.node)) {\n        return currentPath.node.name\n      }\n\n      if (\n        isVariableDeclarator(currentPath.node) &&\n        isIdentifier(currentPath.node.id)\n      ) {\n        return currentPath.node.id.name\n      }\n\n      if (\n        babel.types.isClassMethod(currentPath.node) ||\n        babel.types.isObjectMethod(currentPath.node)\n      ) {\n        throw new Error(\n          `${directiveLabel} in ClassMethod or ObjectMethod not supported`,\n        )\n      }\n\n      return ''\n    })()\n\n    if (name) {\n      nameParts.unshift(name)\n    }\n\n    currentPath = currentPath.parentPath\n  }\n\n  return nameParts.length > 0 ? nameParts.join('_') : 'anonymous'\n}\n\nfunction makeFileLocationUrlSafe(location: string): string {\n  return location\n    .replace(/[^a-zA-Z0-9-_]/g, '_') // Replace unsafe chars with underscore\n    .replace(/_{2,}/g, '_') // Collapse multiple underscores\n    .replace(/^_|_$/g, '') // Trim leading/trailing underscores\n    .replace(/_--/g, '--') // Clean up the joiner\n}\n\nfunction makeIdentifierSafe(identifier: string): string {\n  return identifier\n    .replace(/[^a-zA-Z0-9_$]/g, '_') // Replace unsafe chars with underscore\n    .replace(/^[0-9]/, '_$&') // Prefix leading number with underscore\n    .replace(/^\\$/, '_$') // Prefix leading $ with underscore\n    .replace(/_{2,}/g, '_') // Collapse multiple underscores\n    .replace(/^_|_$/g, '') // Trim leading/trailing underscores\n}\n\nexport function findDirectives(\n  ast: babel.types.File,\n  opts: ParseAstOptions & {\n    directive: string\n    directiveLabel: string\n    replacer?: ReplacerFn\n    directiveSplitParam: string\n  },\n): Record<string, DirectiveFn> {\n  const directiveFnsById: Record<string, DirectiveFn> = {}\n  const functionNameSet: Set<string> = new Set()\n\n  let programPath: babel.NodePath<babel.types.Program>\n\n  babel.traverse(ast, {\n    Program(path) {\n      programPath = path\n    },\n  })\n\n  // Does the file have the directive in the program body?\n  const hasFileDirective = ast.program.directives.some(\n    (directive) => directive.value.value === opts.directive,\n  )\n\n  // If the entire file has a directive, we need to compile all of the functions that are\n  // exported by the file.\n  if (hasFileDirective) {\n    // Find all of the exported functions\n    // They must be either function declarations or const function/anonymous function declarations\n    babel.traverse(ast, {\n      ExportDefaultDeclaration(path) {\n        if (babel.types.isFunctionDeclaration(path.node.declaration)) {\n          compileDirective(path.get('declaration') as SupportedFunctionPath)\n        }\n      },\n      ExportNamedDeclaration(path) {\n        if (babel.types.isFunctionDeclaration(path.node.declaration)) {\n          compileDirective(path.get('declaration') as SupportedFunctionPath)\n        }\n      },\n      ExportDeclaration(path) {\n        if (\n          babel.types.isExportNamedDeclaration(path.node) &&\n          babel.types.isVariableDeclaration(path.node.declaration) &&\n          (babel.types.isFunctionExpression(\n            path.node.declaration.declarations[0]?.init,\n          ) ||\n            babel.types.isArrowFunctionExpression(\n              path.node.declaration.declarations[0]?.init,\n            ))\n        ) {\n          compileDirective(\n            path.get(\n              'declaration.declarations.0.init',\n            ) as SupportedFunctionPath,\n          )\n        }\n      },\n    })\n  } else {\n    // Find all directives\n    babel.traverse(ast, {\n      DirectiveLiteral(nodePath) {\n        if (nodePath.node.value === opts.directive) {\n          const directiveFn = nodePath.findParent((p) => p.isFunction()) as\n            | SupportedFunctionPath\n            | undefined\n\n          if (!directiveFn) return\n\n          // Handle class and object methods which are not supported\n          const isGenerator =\n            directiveFn.isFunction() && directiveFn.node.generator\n\n          const isClassMethod = directiveFn.isClassMethod()\n          const isObjectMethod = directiveFn.isObjectMethod()\n\n          if (isClassMethod || isObjectMethod || isGenerator) {\n            throw codeFrameError(\n              opts.code,\n              directiveFn.node.loc,\n              `\"${opts.directive}\" in ${isClassMethod ? 'class' : isObjectMethod ? 'object method' : 'generator function'} not supported`,\n            )\n          }\n\n          // If the function is inside another block that isn't the program,\n          // Error out. This is not supported.\n          const nearestBlock = directiveFn.findParent(\n            (p) => (p.isBlockStatement() || p.isScopable()) && !p.isProgram(),\n          )\n\n          if (nearestBlock) {\n            throw codeFrameError(\n              opts.code,\n              nearestBlock.node.loc,\n              `${opts.directiveLabel}s cannot be nested in other blocks or functions`,\n            )\n          }\n\n          if (\n            !directiveFn.isFunctionDeclaration() &&\n            !directiveFn.isFunctionExpression() &&\n            !(\n              directiveFn.isArrowFunctionExpression() &&\n              babel.types.isBlockStatement(directiveFn.node.body)\n            )\n          ) {\n            throw codeFrameError(\n              opts.code,\n              directiveFn.node.loc,\n              `${opts.directiveLabel}s must be function declarations or function expressions`,\n            )\n          }\n\n          compileDirective(directiveFn)\n        }\n      },\n    })\n  }\n\n  return directiveFnsById\n\n  function compileDirective(directiveFn: SupportedFunctionPath) {\n    // Move the function to program level while preserving its position\n    // in the program body\n    const programBody = programPath.node.body\n\n    // Remove the directive directive from the function body\n    if (\n      babel.types.isFunction(directiveFn.node) &&\n      babel.types.isBlockStatement(directiveFn.node.body)\n    ) {\n      directiveFn.node.body.directives =\n        directiveFn.node.body.directives.filter(\n          (directive) => directive.value.value !== opts.directive,\n        )\n    }\n\n    // if the directive function is a top-level function, we need to create a const declaration\n    // using the same name as the function and replace the function with the variable declaration\n    // that points to the function\n    if (directiveFn.parentPath.isProgram()) {\n      if (!babel.types.isFunctionDeclaration(directiveFn.node)) {\n        throw new Error('Top level functions must be function declarations')\n      }\n\n      const index = programBody.indexOf(directiveFn.node)\n\n      // First get the name of the function\n      const originalFunctionName = directiveFn.node.id!.name\n\n      // Now turn the function into an anonymous function\n      directiveFn.node.id = null\n\n      const variableDeclaration = babel.types.variableDeclaration('const', [\n        babel.types.variableDeclarator(\n          babel.types.identifier(originalFunctionName),\n          babel.types.toExpression(directiveFn.node as any),\n        ),\n      ])\n\n      directiveFn.replaceWith(variableDeclaration)\n\n      directiveFn = programPath.get(\n        `body.${index}.declarations.0.init`,\n      ) as SupportedFunctionPath\n    }\n\n    // Find the nearest variable name\n    let functionName = findNearestVariableName(directiveFn, opts.directiveLabel)\n\n    const incrementFunctionNameVersion = (functionName: string) => {\n      const [realReferenceName, count] = functionName.split(/_(\\d+)$/)\n      const resolvedCount = Number(count || '0')\n      const suffix = `_${resolvedCount + 1}`\n      return makeIdentifierSafe(realReferenceName!) + suffix\n    }\n\n    while (functionNameSet.has(functionName)) {\n      functionName = incrementFunctionNameVersion(functionName)\n    }\n\n    functionNameSet.add(functionName)\n\n    while (programPath.scope.hasBinding(functionName)) {\n      functionName = incrementFunctionNameVersion(functionName)\n      programPath.scope.crawl()\n    }\n\n    functionNameSet.add(functionName)\n\n    const topParent =\n      directiveFn.findParent((p) => !!p.parentPath?.isProgram()) || directiveFn\n\n    const topParentIndex = programBody.indexOf(topParent.node as any)\n\n    // If the function has a parent that isn't the program,\n    // we need to replace it with an identifier and\n    // hoist the function to the top level as a const declaration\n    if (directiveFn.parentPath.isProgram()) {\n      throw new Error(\n        'Top level functions should have already been compiled to variable declarations by this point',\n      )\n    }\n    // Then place the function at the top level\n    programBody.splice(\n      topParentIndex,\n      0,\n      babel.types.variableDeclaration('const', [\n        babel.types.variableDeclarator(\n          babel.types.identifier(functionName),\n          babel.types.toExpression(directiveFn.node as any),\n        ),\n      ]),\n    )\n\n    // If it's an exported named function, we need to swap it with an\n    // export const originalFunctionName = functionName\n    if (\n      babel.types.isExportNamedDeclaration(directiveFn.parentPath.node) &&\n      (babel.types.isFunctionDeclaration(directiveFn.node) ||\n        babel.types.isFunctionExpression(directiveFn.node)) &&\n      babel.types.isIdentifier(directiveFn.node.id)\n    ) {\n      const originalFunctionName = directiveFn.node.id.name\n      programBody.splice(\n        topParentIndex + 1,\n        0,\n        babel.types.exportNamedDeclaration(\n          babel.types.variableDeclaration('const', [\n            babel.types.variableDeclarator(\n              babel.types.identifier(originalFunctionName),\n              babel.types.identifier(functionName),\n            ),\n          ]),\n        ),\n      )\n\n      directiveFn.remove()\n    } else {\n      directiveFn.replaceWith(babel.types.identifier(functionName))\n    }\n\n    directiveFn = programPath.get(\n      `body.${topParentIndex}.declarations.0.init`,\n    ) as SupportedFunctionPath\n\n    const [baseFilename, ..._searchParams] = opts.filename.split('?')\n    const searchParams = new URLSearchParams(_searchParams.join('&'))\n    searchParams.set(opts.directiveSplitParam, '')\n\n    const extractedFilename = `${baseFilename}?${searchParams.toString()}`\n\n    const functionId = makeFileLocationUrlSafe(\n      `${baseFilename}--${functionName}`.replace(opts.root, ''),\n    )\n\n    // If a replacer is provided, replace the function with the replacer\n    if (opts.replacer) {\n      const replacer = opts.replacer({\n        fn: '$$fn$$',\n        extractedFilename,\n        filename: opts.filename,\n        functionId,\n        isSourceFn: !!opts.directiveSplitParam,\n      })\n\n      const replacement = babel.template.expression(replacer, {\n        placeholderPattern: false,\n        placeholderWhitelist: new Set(['$$fn$$']),\n      })({\n        ...(replacer.includes('$$fn$$')\n          ? { $$fn$$: babel.types.toExpression(directiveFn.node) }\n          : {}),\n      })\n\n      directiveFn.replaceWith(replacement)\n    }\n\n    // Finally register the directive to\n    // our map of directives\n    directiveFnsById[functionId] = {\n      nodePath: directiveFn,\n      functionName,\n      functionId,\n      extractedFilename,\n      filename: opts.filename,\n      chunkName: fileNameToChunkName(opts.root, extractedFilename),\n    }\n  }\n}\n\nfunction codeFrameError(\n  code: string,\n  loc:\n    | {\n        start: { line: number; column: number }\n        end: { line: number; column: number }\n      }\n    | undefined\n    | null,\n  message: string,\n) {\n  if (!loc) {\n    return new Error(`${message} at unknown location`)\n  }\n\n  const frame = codeFrameColumns(\n    code,\n    {\n      start: loc.start,\n      end: loc.end,\n    },\n    {\n      highlightCode: true,\n      message,\n    },\n  )\n\n  return new Error(frame)\n}\n\nconst safeRemoveExports = (ast: babel.types.File) => {\n  const programBody = ast.program.body\n\n  const removeExport = (\n    path:\n      | babel.NodePath<babel.types.ExportDefaultDeclaration>\n      | babel.NodePath<babel.types.ExportNamedDeclaration>,\n  ) => {\n    // If the value is a function declaration, class declaration, or variable declaration,\n    // That means it has a name and can remain in the file, just unexported.\n    if (\n      babel.types.isFunctionDeclaration(path.node.declaration) ||\n      babel.types.isClassDeclaration(path.node.declaration) ||\n      babel.types.isVariableDeclaration(path.node.declaration)\n    ) {\n      // If the value is a function declaration, class declaration, or variable declaration,\n      // That means it has a name and can remain in the file, just unexported.\n      if (\n        babel.types.isFunctionDeclaration(path.node.declaration) ||\n        babel.types.isClassDeclaration(path.node.declaration) ||\n        babel.types.isVariableDeclaration(path.node.declaration)\n      ) {\n        // Move the declaration to the top level at the same index\n        const insertIndex = programBody.findIndex(\n          (node) => node === path.node.declaration,\n        )\n        // do not remove export if it is an anonymous function / class, otherwise this would produce a syntax error\n        if (\n          babel.types.isFunctionDeclaration(path.node.declaration) ||\n          babel.types.isClassDeclaration(path.node.declaration)\n        ) {\n          if (!path.node.declaration.id) {\n            return\n          }\n        }\n        programBody.splice(insertIndex, 0, path.node.declaration as any)\n      }\n    }\n\n    // Otherwise, remove the export declaration\n    path.remove()\n  }\n\n  // Before we add our export, remove any other exports.\n  // Don't remove the thing they export, just the export declaration\n  babel.traverse(ast, {\n    ExportDefaultDeclaration(path) {\n      removeExport(path)\n    },\n    ExportNamedDeclaration(path) {\n      removeExport(path)\n    },\n  })\n}\n\nfunction fileNameToChunkName(root: string, fileName: string) {\n  // Replace anything that can't go into an import statement\n  return fileName.replace(root, '').replace(/[^a-zA-Z0-9_]/g, '_')\n}\n"],"names":["parseAst","findReferencedIdentifiers","babel","deadCodeElimination","generateFromAst","isVariableDeclarator","isIdentifier","functionName","codeFrameColumns"],"mappings":"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"}