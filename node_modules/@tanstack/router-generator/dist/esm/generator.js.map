{"version":3,"file":"generator.js","sources":["../../src/generator.ts"],"sourcesContent":["import path from 'node:path'\nimport * as fs from 'node:fs'\nimport * as fsp from 'node:fs/promises'\nimport {\n  determineInitialRoutePath,\n  format,\n  logging,\n  multiSortBy,\n  removeExt,\n  removeTrailingSlash,\n  removeUnderscores,\n  replaceBackslash,\n  resetRegex,\n  routePathToVariable,\n  trimPathLeft,\n  writeIfDifferent,\n} from './utils'\nimport { getRouteNodes as physicalGetRouteNodes } from './filesystem/physical/getRouteNodes'\nimport { getRouteNodes as virtualGetRouteNodes } from './filesystem/virtual/getRouteNodes'\nimport { rootPathId } from './filesystem/physical/rootPathId'\nimport {\n  defaultAPIRouteTemplate,\n  fillTemplate,\n  getTargetTemplate,\n} from './template'\nimport type { FsRouteType, GetRouteNodesResult, RouteNode } from './types'\nimport type { Config } from './config'\n\nexport const CONSTANTS = {\n  // When changing this, you'll want to update the import in `start-api-routes/src/index.ts#defaultAPIFileRouteHandler`\n  APIRouteExportVariable: 'APIRoute',\n}\n\nlet latestTask = 0\nconst routeGroupPatternRegex = /\\(.+\\)/g\nconst possiblyNestedRouteGroupPatternRegex = /\\([^/]+\\)\\/?/g\n\nlet isFirst = false\nlet skipMessage = false\n\ntype RouteSubNode = {\n  component?: RouteNode\n  errorComponent?: RouteNode\n  pendingComponent?: RouteNode\n  loader?: RouteNode\n  lazy?: RouteNode\n}\n\nexport async function generator(config: Config, root: string) {\n  const ROUTE_TEMPLATE = getTargetTemplate(config.target)\n  const logger = logging({ disabled: config.disableLogging })\n  logger.log('')\n\n  if (!isFirst) {\n    logger.log('♻️  Generating routes...')\n    isFirst = true\n  } else if (skipMessage) {\n    skipMessage = false\n  } else {\n    logger.log('♻️  Regenerating routes...')\n  }\n\n  const taskId = latestTask + 1\n  latestTask = taskId\n\n  const checkLatest = () => {\n    if (latestTask !== taskId) {\n      skipMessage = true\n      return false\n    }\n\n    return true\n  }\n\n  const start = Date.now()\n\n  const TYPES_DISABLED = config.disableTypes\n\n  // Controls whether API Routes are generated for TanStack Start\n  const ENABLED_API_ROUTES_GENERATION =\n    config.__enableAPIRoutesGeneration ?? false\n\n  let getRouteNodesResult: GetRouteNodesResult\n\n  if (config.virtualRouteConfig) {\n    getRouteNodesResult = await virtualGetRouteNodes(config, root)\n  } else {\n    getRouteNodesResult = await physicalGetRouteNodes(config, root)\n  }\n\n  const { rootRouteNode, routeNodes: beforeRouteNodes } = getRouteNodesResult\n  if (rootRouteNode === undefined) {\n    let errorMessage = `rootRouteNode must not be undefined. Make sure you've added your root route into the route-tree.`\n    if (!config.virtualRouteConfig) {\n      errorMessage += `\\nMake sure that you add a \"${rootPathId}.${config.disableTypes ? 'js' : 'tsx'}\" file to your routes directory.\\nAdd the file in: \"${config.routesDirectory}/${rootPathId}.${config.disableTypes ? 'js' : 'tsx'}\"`\n    }\n    throw new Error(errorMessage)\n  }\n\n  const preRouteNodes = multiSortBy(beforeRouteNodes, [\n    (d) => (d.routePath === '/' ? -1 : 1),\n    (d) => d.routePath?.split('/').length,\n    (d) =>\n      d.filePath.match(new RegExp(`[./]${config.indexToken}[.]`)) ? 1 : -1,\n    (d) =>\n      d.filePath.match(\n        /[./](component|errorComponent|pendingComponent|loader|lazy)[.]/,\n      )\n        ? 1\n        : -1,\n    (d) =>\n      d.filePath.match(new RegExp(`[./]${config.routeToken}[.]`)) ? -1 : 1,\n    (d) => (d.routePath?.endsWith('/') ? -1 : 1),\n    (d) => d.routePath,\n  ]).filter((d) => ![`/${rootPathId}`].includes(d.routePath || ''))\n\n  const routeTree: Array<RouteNode> = []\n  const routePiecesByPath: Record<string, RouteSubNode> = {}\n\n  // Filtered API Route nodes\n  const onlyAPIRouteNodes = preRouteNodes.filter((d) => {\n    if (!ENABLED_API_ROUTES_GENERATION) {\n      return false\n    }\n\n    if (d._fsRouteType !== 'api') {\n      return false\n    }\n\n    return true\n  })\n\n  // Filtered Generator Route nodes\n  const onlyGeneratorRouteNodes = preRouteNodes.filter((d) => {\n    if (ENABLED_API_ROUTES_GENERATION) {\n      if (d._fsRouteType === 'api') {\n        return false\n      }\n    }\n\n    return true\n  })\n\n  // Loop over the flat list of routeNodes and\n  // build up a tree based on the routeNodes' routePath\n  const routeNodes: Array<RouteNode> = []\n\n  // the handleRootNode function is not being collapsed into the handleNode function\n  // because it requires only a subset of the logic that the handleNode function requires\n  // and it's easier to read and maintain this way\n  const handleRootNode = async (node?: RouteNode) => {\n    if (!node) {\n      // currently this is not being handled, but it could be in the future\n      // for example to handle a virtual root route\n      return\n    }\n\n    // from here on, we are only handling the root node that's present in the file system\n    const routeCode = fs.readFileSync(node.fullPath, 'utf-8')\n\n    if (!routeCode) {\n      const _rootTemplate = ROUTE_TEMPLATE.rootRoute\n      const replaced = await fillTemplate(config, _rootTemplate.template(), {\n        tsrImports: _rootTemplate.imports.tsrImports(),\n        tsrPath: rootPathId,\n        tsrExportStart: _rootTemplate.imports.tsrExportStart(),\n        tsrExportEnd: _rootTemplate.imports.tsrExportEnd(),\n      })\n\n      await writeIfDifferent(\n        node.fullPath,\n        '', // Empty string because the file doesn't exist yet\n        replaced,\n        {\n          beforeWrite: () => {\n            logger.log(`🟡 Creating ${node.fullPath}`)\n          },\n        },\n      )\n    }\n  }\n\n  await handleRootNode(rootRouteNode)\n\n  const handleNode = async (node: RouteNode) => {\n    // Do not remove this as we need to set the lastIndex to 0 as it\n    // is necessary to reset the regex's index when using the global flag\n    // otherwise it might not match the next time it's used\n    resetRegex(routeGroupPatternRegex)\n\n    let parentRoute = hasParentRoute(routeNodes, node, node.routePath)\n\n    // if the parent route is a virtual parent route, we need to find the real parent route\n    if (parentRoute?.isVirtualParentRoute && parentRoute.children?.length) {\n      // only if this sub-parent route returns a valid parent route, we use it, if not leave it as it\n      const possibleParentRoute = hasParentRoute(\n        parentRoute.children,\n        node,\n        node.routePath,\n      )\n      if (possibleParentRoute) {\n        parentRoute = possibleParentRoute\n      }\n    }\n\n    if (parentRoute) node.parent = parentRoute\n\n    node.path = determineNodePath(node)\n\n    const trimmedPath = trimPathLeft(node.path ?? '')\n\n    const split = trimmedPath.split('/')\n    const lastRouteSegment = split[split.length - 1] ?? trimmedPath\n\n    node.isNonPath =\n      lastRouteSegment.startsWith('_') ||\n      routeGroupPatternRegex.test(lastRouteSegment)\n\n    node.cleanedPath = removeGroups(\n      removeUnderscores(removeLayoutSegments(node.path)) ?? '',\n    )\n\n    // Ensure the boilerplate for the route exists, which can be skipped for virtual parent routes and virtual routes\n    if (!node.isVirtualParentRoute && !node.isVirtual) {\n      const routeCode = fs.readFileSync(node.fullPath, 'utf-8')\n\n      const escapedRoutePath = node.routePath?.replaceAll('$', '$$') ?? ''\n\n      let replaced = routeCode\n\n      const tRouteTemplate = ROUTE_TEMPLATE.route\n      const tLazyRouteTemplate = ROUTE_TEMPLATE.lazyRoute\n\n      if (!routeCode) {\n        // Creating a new lazy route file\n        if (node._fsRouteType === 'lazy') {\n          // Check by default check if the user has a specific lazy route template\n          // If not, check if the user has a route template and use that instead\n          replaced = await fillTemplate(\n            config,\n            (config.customScaffolding?.lazyRouteTemplate ||\n              config.customScaffolding?.routeTemplate) ??\n              tLazyRouteTemplate.template(),\n            {\n              tsrImports: tLazyRouteTemplate.imports.tsrImports(),\n              tsrPath: escapedRoutePath,\n              tsrExportStart:\n                tLazyRouteTemplate.imports.tsrExportStart(escapedRoutePath),\n              tsrExportEnd: tLazyRouteTemplate.imports.tsrExportEnd(),\n            },\n          )\n        } else if (\n          // Creating a new normal route file\n          (['layout', 'static'] satisfies Array<FsRouteType>).some(\n            (d) => d === node._fsRouteType,\n          ) ||\n          (\n            [\n              'component',\n              'pendingComponent',\n              'errorComponent',\n              'loader',\n            ] satisfies Array<FsRouteType>\n          ).every((d) => d !== node._fsRouteType)\n        ) {\n          replaced = await fillTemplate(\n            config,\n            config.customScaffolding?.routeTemplate ??\n              tRouteTemplate.template(),\n            {\n              tsrImports: tRouteTemplate.imports.tsrImports(),\n              tsrPath: escapedRoutePath,\n              tsrExportStart:\n                tRouteTemplate.imports.tsrExportStart(escapedRoutePath),\n              tsrExportEnd: tRouteTemplate.imports.tsrExportEnd(),\n            },\n          )\n        }\n      } else {\n        // Update the existing route file\n        replaced = routeCode\n          .replace(\n            /(FileRoute\\(\\s*['\"])([^\\s]*)(['\"],?\\s*\\))/g,\n            (_, p1, __, p3) => `${p1}${escapedRoutePath}${p3}`,\n          )\n          .replace(\n            new RegExp(\n              `(import\\\\s*\\\\{.*)(create(Lazy)?FileRoute)(.*\\\\}\\\\s*from\\\\s*['\"]@tanstack\\\\/${ROUTE_TEMPLATE.subPkg}['\"])`,\n              'gs',\n            ),\n            (_, p1, __, ___, p4) =>\n              `${p1}${node._fsRouteType === 'lazy' ? 'createLazyFileRoute' : 'createFileRoute'}${p4}`,\n          )\n          .replace(\n            /create(Lazy)?FileRoute(\\(\\s*['\"])([^\\s]*)(['\"],?\\s*\\))/g,\n            (_, __, p2, ___, p4) =>\n              `${node._fsRouteType === 'lazy' ? 'createLazyFileRoute' : 'createFileRoute'}${p2}${escapedRoutePath}${p4}`,\n          )\n      }\n\n      await writeIfDifferent(node.fullPath, routeCode, replaced, {\n        beforeWrite: () => {\n          logger.log(`🟡 Updating ${node.fullPath}`)\n        },\n      })\n    }\n\n    if (\n      !node.isVirtual &&\n      (\n        [\n          'lazy',\n          'loader',\n          'component',\n          'pendingComponent',\n          'errorComponent',\n        ] satisfies Array<FsRouteType>\n      ).some((d) => d === node._fsRouteType)\n    ) {\n      routePiecesByPath[node.routePath!] =\n        routePiecesByPath[node.routePath!] || {}\n\n      routePiecesByPath[node.routePath!]![\n        node._fsRouteType === 'lazy'\n          ? 'lazy'\n          : node._fsRouteType === 'loader'\n            ? 'loader'\n            : node._fsRouteType === 'errorComponent'\n              ? 'errorComponent'\n              : node._fsRouteType === 'pendingComponent'\n                ? 'pendingComponent'\n                : 'component'\n      ] = node\n\n      const anchorRoute = routeNodes.find((d) => d.routePath === node.routePath)\n\n      if (!anchorRoute) {\n        await handleNode({\n          ...node,\n          isVirtual: true,\n          _fsRouteType: 'static',\n        })\n      }\n      return\n    }\n\n    const cleanedPathIsEmpty = (node.cleanedPath || '').length === 0\n    const nonPathRoute =\n      node._fsRouteType === 'pathless_layout' && node.isNonPath\n\n    node.isVirtualParentRequired =\n      node._fsRouteType === 'pathless_layout' || nonPathRoute\n        ? !cleanedPathIsEmpty\n        : false\n\n    if (!node.isVirtual && node.isVirtualParentRequired) {\n      const parentRoutePath = removeLastSegmentFromPath(node.routePath) || '/'\n      const parentVariableName = routePathToVariable(parentRoutePath)\n\n      const anchorRoute = routeNodes.find(\n        (d) => d.routePath === parentRoutePath,\n      )\n\n      if (!anchorRoute) {\n        const parentNode: RouteNode = {\n          ...node,\n          path: removeLastSegmentFromPath(node.path) || '/',\n          filePath: removeLastSegmentFromPath(node.filePath) || '/',\n          fullPath: removeLastSegmentFromPath(node.fullPath) || '/',\n          routePath: parentRoutePath,\n          variableName: parentVariableName,\n          isVirtual: true,\n          _fsRouteType: 'layout', // layout since this route will wrap other routes\n          isVirtualParentRoute: true,\n          isVirtualParentRequired: false,\n        }\n\n        parentNode.children = parentNode.children ?? []\n        parentNode.children.push(node)\n\n        node.parent = parentNode\n\n        if (node._fsRouteType === 'pathless_layout') {\n          // since `node.path` is used as the `id` on the route definition, we need to update it\n          node.path = determineNodePath(node)\n        }\n\n        await handleNode(parentNode)\n      } else {\n        anchorRoute.children = anchorRoute.children ?? []\n        anchorRoute.children.push(node)\n\n        node.parent = anchorRoute\n      }\n    }\n\n    if (node.parent) {\n      if (!node.isVirtualParentRequired) {\n        node.parent.children = node.parent.children ?? []\n        node.parent.children.push(node)\n      }\n    } else {\n      routeTree.push(node)\n    }\n\n    routeNodes.push(node)\n  }\n\n  for (const node of onlyGeneratorRouteNodes) {\n    await handleNode(node)\n  }\n  checkRouteFullPathUniqueness(\n    preRouteNodes.filter(\n      (d) =>\n        d.children === undefined &&\n        (['api', 'lazy'] satisfies Array<FsRouteType>).every(\n          (type) => type !== d._fsRouteType,\n        ),\n    ),\n    config,\n  )\n\n  const startAPIRouteNodes: Array<RouteNode> = checkStartAPIRoutes(\n    onlyAPIRouteNodes,\n    config,\n  )\n\n  const handleAPINode = async (node: RouteNode) => {\n    const routeCode = fs.readFileSync(node.fullPath, 'utf-8')\n\n    const escapedRoutePath = node.routePath?.replaceAll('$', '$$') ?? ''\n\n    if (!routeCode) {\n      const replaced = await fillTemplate(\n        config,\n        config.customScaffolding?.apiTemplate ?? defaultAPIRouteTemplate,\n        {\n          tsrImports:\n            \"import { createAPIFileRoute } from '@tanstack/react-start/api';\",\n          tsrPath: escapedRoutePath,\n          tsrExportStart: `export const ${CONSTANTS.APIRouteExportVariable} = createAPIFileRoute('${escapedRoutePath}')(`,\n          tsrExportEnd: ');',\n        },\n      )\n\n      await writeIfDifferent(\n        node.fullPath,\n        '', // Empty string because the file doesn't exist yet\n        replaced,\n        {\n          beforeWrite: () => {\n            logger.log(`🟡 Creating ${node.fullPath}`)\n          },\n        },\n      )\n    } else {\n      await writeIfDifferent(\n        node.fullPath,\n        routeCode,\n        routeCode.replace(\n          /(createAPIFileRoute\\(\\s*['\"])([^\\s]*)(['\"],?\\s*\\))/g,\n          (_, p1, __, p3) => `${p1}${escapedRoutePath}${p3}`,\n        ),\n        {\n          beforeWrite: () => {\n            logger.log(`🟡 Updating ${node.fullPath}`)\n          },\n        },\n      )\n    }\n  }\n\n  // Handle the API routes for TanStack Start\n  if (ENABLED_API_ROUTES_GENERATION) {\n    for (const node of startAPIRouteNodes) {\n      await handleAPINode(node)\n    }\n  }\n\n  function buildRouteTreeConfig(nodes: Array<RouteNode>, depth = 1): string {\n    const children = nodes.map((node) => {\n      if (node._fsRouteType === '__root') {\n        return\n      }\n\n      if (node._fsRouteType === 'pathless_layout' && !node.children?.length) {\n        return\n      }\n\n      const route = `${node.variableName}Route`\n\n      if (node.children?.length) {\n        const childConfigs = buildRouteTreeConfig(node.children, depth + 1)\n\n        const childrenDeclaration = TYPES_DISABLED\n          ? ''\n          : `interface ${route}Children {\n  ${node.children.map((child) => `${child.variableName}Route: typeof ${getResolvedRouteNodeVariableName(child)}`).join(',')}\n}`\n\n        const children = `const ${route}Children${TYPES_DISABLED ? '' : `: ${route}Children`} = {\n  ${node.children.map((child) => `${child.variableName}Route: ${getResolvedRouteNodeVariableName(child)}`).join(',')}\n}`\n\n        const routeWithChildren = `const ${route}WithChildren = ${route}._addFileChildren(${route}Children)`\n\n        return [\n          childConfigs,\n          childrenDeclaration,\n          children,\n          routeWithChildren,\n        ].join('\\n\\n')\n      }\n\n      return undefined\n    })\n\n    return children.filter(Boolean).join('\\n\\n')\n  }\n\n  const routeConfigChildrenText = buildRouteTreeConfig(routeTree)\n\n  const sortedRouteNodes = multiSortBy(routeNodes, [\n    (d) => (d.routePath?.includes(`/${rootPathId}`) ? -1 : 1),\n    (d) => d.routePath?.split('/').length,\n    (d) => (d.routePath?.endsWith(config.indexToken) ? -1 : 1),\n    (d) => d,\n  ])\n\n  const imports = Object.entries({\n    createFileRoute: sortedRouteNodes.some((d) => d.isVirtual),\n    lazyFn: sortedRouteNodes.some(\n      (node) => routePiecesByPath[node.routePath!]?.loader,\n    ),\n    lazyRouteComponent: sortedRouteNodes.some(\n      (node) =>\n        routePiecesByPath[node.routePath!]?.component ||\n        routePiecesByPath[node.routePath!]?.errorComponent ||\n        routePiecesByPath[node.routePath!]?.pendingComponent,\n    ),\n  })\n    .filter((d) => d[1])\n    .map((d) => d[0])\n\n  const virtualRouteNodes = sortedRouteNodes.filter((d) => d.isVirtual)\n\n  function getImportPath(node: RouteNode) {\n    return replaceBackslash(\n      removeExt(\n        path.relative(\n          path.dirname(config.generatedRouteTree),\n          path.resolve(config.routesDirectory, node.filePath),\n        ),\n        config.addExtensions,\n      ),\n    )\n  }\n  const routeImports = [\n    ...config.routeTreeFileHeader,\n    `// This file was automatically generated by TanStack Router.\n// You should NOT make any changes in this file as it will be overwritten.\n// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.`,\n    imports.length\n      ? `import { ${imports.join(', ')} } from '${ROUTE_TEMPLATE.fullPkg}'\\n`\n      : '',\n    '// Import Routes',\n    [\n      `import { Route as rootRoute } from './${getImportPath(rootRouteNode)}'`,\n      ...sortedRouteNodes\n        .filter((d) => !d.isVirtual)\n        .map((node) => {\n          return `import { Route as ${\n            node.variableName\n          }Import } from './${getImportPath(node)}'`\n        }),\n    ].join('\\n'),\n    virtualRouteNodes.length ? '// Create Virtual Routes' : '',\n    virtualRouteNodes\n      .map((node) => {\n        return `const ${\n          node.variableName\n        }Import = createFileRoute('${node.routePath}')()`\n      })\n      .join('\\n'),\n    '// Create/Update Routes',\n    sortedRouteNodes\n      .map((node) => {\n        const loaderNode = routePiecesByPath[node.routePath!]?.loader\n        const componentNode = routePiecesByPath[node.routePath!]?.component\n        const errorComponentNode =\n          routePiecesByPath[node.routePath!]?.errorComponent\n        const pendingComponentNode =\n          routePiecesByPath[node.routePath!]?.pendingComponent\n        const lazyComponentNode = routePiecesByPath[node.routePath!]?.lazy\n\n        return [\n          `const ${node.variableName}Route = ${node.variableName}Import.update({\n          ${[\n            `id: '${node.path}'`,\n            !node.isNonPath ? `path: '${node.cleanedPath}'` : undefined,\n            `getParentRoute: () => ${node.parent?.variableName ?? 'root'}Route`,\n          ]\n            .filter(Boolean)\n            .join(',')}\n        }${TYPES_DISABLED ? '' : 'as any'})`,\n          loaderNode\n            ? `.updateLoader({ loader: lazyFn(() => import('./${replaceBackslash(\n                removeExt(\n                  path.relative(\n                    path.dirname(config.generatedRouteTree),\n                    path.resolve(config.routesDirectory, loaderNode.filePath),\n                  ),\n                  config.addExtensions,\n                ),\n              )}'), 'loader') })`\n            : '',\n          componentNode || errorComponentNode || pendingComponentNode\n            ? `.update({\n              ${(\n                [\n                  ['component', componentNode],\n                  ['errorComponent', errorComponentNode],\n                  ['pendingComponent', pendingComponentNode],\n                ] as const\n              )\n                .filter((d) => d[1])\n                .map((d) => {\n                  return `${\n                    d[0]\n                  }: lazyRouteComponent(() => import('./${replaceBackslash(\n                    removeExt(\n                      path.relative(\n                        path.dirname(config.generatedRouteTree),\n                        path.resolve(config.routesDirectory, d[1]!.filePath),\n                      ),\n                      config.addExtensions,\n                    ),\n                  )}'), '${d[0]}')`\n                })\n                .join('\\n,')}\n            })`\n            : '',\n          lazyComponentNode\n            ? `.lazy(() => import('./${replaceBackslash(\n                removeExt(\n                  path.relative(\n                    path.dirname(config.generatedRouteTree),\n                    path.resolve(\n                      config.routesDirectory,\n                      lazyComponentNode.filePath,\n                    ),\n                  ),\n                  config.addExtensions,\n                ),\n              )}').then((d) => d.Route))`\n            : '',\n        ].join('')\n      })\n      .join('\\n\\n'),\n    ...(TYPES_DISABLED\n      ? []\n      : [\n          '// Populate the FileRoutesByPath interface',\n          `declare module '${ROUTE_TEMPLATE.fullPkg}' {\n  interface FileRoutesByPath {\n    ${routeNodes\n      .map((routeNode) => {\n        const filePathId = routeNode.routePath\n\n        return `'${filePathId}': {\n          id: '${filePathId}'\n          path: '${inferPath(routeNode)}'\n          fullPath: '${inferFullPath(routeNode)}'\n          preLoaderRoute: typeof ${routeNode.variableName}Import\n          parentRoute: typeof ${\n            routeNode.isVirtualParentRequired\n              ? `${routeNode.parent?.variableName}Route`\n              : routeNode.parent?.variableName\n                ? `${routeNode.parent.variableName}Import`\n                : 'rootRoute'\n          }\n        }`\n      })\n      .join('\\n')}\n  }\n}`,\n        ]),\n    '// Create and export the route tree',\n    routeConfigChildrenText,\n    ...(TYPES_DISABLED\n      ? []\n      : [\n          `export interface FileRoutesByFullPath {\n  ${[...createRouteNodesByFullPath(routeNodes).entries()].map(\n    ([fullPath, routeNode]) => {\n      return `'${fullPath}': typeof ${getResolvedRouteNodeVariableName(routeNode)}`\n    },\n  )}\n}`,\n          `export interface FileRoutesByTo {\n  ${[...createRouteNodesByTo(routeNodes).entries()].map(([to, routeNode]) => {\n    return `'${to}': typeof ${getResolvedRouteNodeVariableName(routeNode)}`\n  })}\n}`,\n          `export interface FileRoutesById {\n  '__root__': typeof rootRoute,\n  ${[...createRouteNodesById(routeNodes).entries()].map(([id, routeNode]) => {\n    return `'${id}': typeof ${getResolvedRouteNodeVariableName(routeNode)}`\n  })}\n}`,\n          `export interface FileRouteTypes {\n  fileRoutesByFullPath: FileRoutesByFullPath\n  fullPaths: ${routeNodes.length > 0 ? [...createRouteNodesByFullPath(routeNodes).keys()].map((fullPath) => `'${fullPath}'`).join('|') : 'never'}\n  fileRoutesByTo: FileRoutesByTo\n  to: ${routeNodes.length > 0 ? [...createRouteNodesByTo(routeNodes).keys()].map((to) => `'${to}'`).join('|') : 'never'}\n  id: ${[`'__root__'`, ...[...createRouteNodesById(routeNodes).keys()].map((id) => `'${id}'`)].join('|')}\n  fileRoutesById: FileRoutesById\n}`,\n          `export interface RootRouteChildren {\n  ${routeTree.map((child) => `${child.variableName}Route: typeof ${getResolvedRouteNodeVariableName(child)}`).join(',')}\n}`,\n        ]),\n    `const rootRouteChildren${TYPES_DISABLED ? '' : ': RootRouteChildren'} = {\n  ${routeTree.map((child) => `${child.variableName}Route: ${getResolvedRouteNodeVariableName(child)}`).join(',')}\n}`,\n    `export const routeTree = rootRoute._addFileChildren(rootRouteChildren)${TYPES_DISABLED ? '' : '._addFileTypes<FileRouteTypes>()'}`,\n    ...config.routeTreeFileFooter,\n  ]\n    .filter(Boolean)\n    .join('\\n\\n')\n\n  const createRouteManifest = () => {\n    const routesManifest = {\n      __root__: {\n        filePath: rootRouteNode.filePath,\n        children: routeTree.map((d) => d.routePath),\n      },\n      ...Object.fromEntries(\n        routeNodes.map((d) => {\n          const filePathId = d.routePath\n\n          return [\n            filePathId,\n            {\n              filePath: d.filePath,\n              parent: d.parent?.routePath ? d.parent.routePath : undefined,\n              children: d.children?.map((childRoute) => childRoute.routePath),\n            },\n          ]\n        }),\n      ),\n    }\n\n    return JSON.stringify(\n      {\n        routes: routesManifest,\n      },\n      null,\n      2,\n    )\n  }\n\n  const includeManifest = ['react', 'solid']\n  const routeConfigFileContent =\n    config.disableManifestGeneration || !includeManifest.includes(config.target)\n      ? routeImports\n      : [\n          routeImports,\n          '\\n',\n          '/* ROUTE_MANIFEST_START',\n          createRouteManifest(),\n          'ROUTE_MANIFEST_END */',\n        ].join('\\n')\n\n  if (!checkLatest()) return\n\n  const existingRouteTreeContent = await fsp\n    .readFile(path.resolve(config.generatedRouteTree), 'utf-8')\n    .catch((err) => {\n      if (err.code === 'ENOENT') {\n        return ''\n      }\n\n      throw err\n    })\n\n  if (!checkLatest()) return\n\n  // Ensure the directory exists\n  await fsp.mkdir(path.dirname(path.resolve(config.generatedRouteTree)), {\n    recursive: true,\n  })\n\n  if (!checkLatest()) return\n\n  // Write the route tree file, if it has changed\n  const routeTreeWriteResult = await writeIfDifferent(\n    path.resolve(config.generatedRouteTree),\n    config.enableRouteTreeFormatting\n      ? await format(existingRouteTreeContent, config)\n      : existingRouteTreeContent,\n    config.enableRouteTreeFormatting\n      ? await format(routeConfigFileContent, config)\n      : routeConfigFileContent,\n    {\n      beforeWrite: () => {\n        logger.log(`🟡 Updating ${config.generatedRouteTree}`)\n      },\n    },\n  )\n  if (routeTreeWriteResult && !checkLatest()) {\n    return\n  }\n\n  logger.log(\n    `✅ Processed ${routeNodes.length === 1 ? 'route' : 'routes'} in ${\n      Date.now() - start\n    }ms`,\n  )\n}\n\n// function removeTrailingUnderscores(s?: string) {\n//   return s?.replaceAll(/(_$)/gi, '').replaceAll(/(_\\/)/gi, '/')\n// }\n\nfunction removeGroups(s: string) {\n  return s.replace(possiblyNestedRouteGroupPatternRegex, '')\n}\n\n/**\n * The `node.path` is used as the `id` in the route definition.\n * This function checks if the given node has a parent and if so, it determines the correct path for the given node.\n * @param node - The node to determine the path for.\n * @returns The correct path for the given node.\n */\nfunction determineNodePath(node: RouteNode) {\n  return (node.path = node.parent\n    ? node.routePath?.replace(node.parent.routePath ?? '', '') || '/'\n    : node.routePath)\n}\n\n/**\n * Removes the last segment from a given path. Segments are considered to be separated by a '/'.\n *\n * @param {string} routePath - The path from which to remove the last segment. Defaults to '/'.\n * @returns {string} The path with the last segment removed.\n * @example\n * removeLastSegmentFromPath('/workspace/_auth/foo') // '/workspace/_auth'\n */\nexport function removeLastSegmentFromPath(routePath: string = '/'): string {\n  const segments = routePath.split('/')\n  segments.pop() // Remove the last segment\n  return segments.join('/')\n}\n\n/**\n * Removes all segments from a given path that start with an underscore ('_').\n *\n * @param {string} routePath - The path from which to remove segments. Defaults to '/'.\n * @returns {string} The path with all underscore-prefixed segments removed.\n * @example\n * removeLayoutSegments('/workspace/_auth/foo') // '/workspace/foo'\n */\nfunction removeLayoutSegments(routePath: string = '/'): string {\n  const segments = routePath.split('/')\n  const newSegments = segments.filter((segment) => !segment.startsWith('_'))\n  return newSegments.join('/')\n}\n\nexport function hasParentRoute(\n  routes: Array<RouteNode>,\n  node: RouteNode,\n  routePathToCheck: string | undefined,\n): RouteNode | null {\n  if (!routePathToCheck || routePathToCheck === '/') {\n    return null\n  }\n\n  const sortedNodes = multiSortBy(routes, [\n    (d) => d.routePath!.length * -1,\n    (d) => d.variableName,\n  ]).filter((d) => d.routePath !== `/${rootPathId}`)\n\n  for (const route of sortedNodes) {\n    if (route.routePath === '/') continue\n\n    if (\n      routePathToCheck.startsWith(`${route.routePath}/`) &&\n      route.routePath !== routePathToCheck\n    ) {\n      return route\n    }\n  }\n\n  const segments = routePathToCheck.split('/')\n  segments.pop() // Remove the last segment\n  const parentRoutePath = segments.join('/')\n\n  return hasParentRoute(routes, node, parentRoutePath)\n}\n\n/**\n * Gets the final variable name for a route\n */\nexport const getResolvedRouteNodeVariableName = (\n  routeNode: RouteNode,\n): string => {\n  return routeNode.children?.length\n    ? `${routeNode.variableName}RouteWithChildren`\n    : `${routeNode.variableName}Route`\n}\n\n/**\n * Creates a map from fullPath to routeNode\n */\nexport const createRouteNodesByFullPath = (\n  routeNodes: Array<RouteNode>,\n): Map<string, RouteNode> => {\n  return new Map(\n    routeNodes.map((routeNode) => [inferFullPath(routeNode), routeNode]),\n  )\n}\n\n/**\n * Create a map from 'to' to a routeNode\n */\nexport const createRouteNodesByTo = (\n  routeNodes: Array<RouteNode>,\n): Map<string, RouteNode> => {\n  return new Map(\n    dedupeBranchesAndIndexRoutes(routeNodes).map((routeNode) => [\n      inferTo(routeNode),\n      routeNode,\n    ]),\n  )\n}\n\n/**\n * Create a map from 'id' to a routeNode\n */\nexport const createRouteNodesById = (\n  routeNodes: Array<RouteNode>,\n): Map<string, RouteNode> => {\n  return new Map(\n    routeNodes.map((routeNode) => {\n      const id = routeNode.routePath ?? ''\n      return [id, routeNode]\n    }),\n  )\n}\n\n/**\n * Infers the full path for use by TS\n */\nexport const inferFullPath = (routeNode: RouteNode): string => {\n  const fullPath = removeGroups(\n    removeUnderscores(removeLayoutSegments(routeNode.routePath)) ?? '',\n  )\n\n  return routeNode.cleanedPath === '/' ? fullPath : fullPath.replace(/\\/$/, '')\n}\n\n/**\n * Infers the path for use by TS\n */\nexport const inferPath = (routeNode: RouteNode): string => {\n  return routeNode.cleanedPath === '/'\n    ? routeNode.cleanedPath\n    : (routeNode.cleanedPath?.replace(/\\/$/, '') ?? '')\n}\n\n/**\n * Infers to path\n */\nexport const inferTo = (routeNode: RouteNode): string => {\n  const fullPath = inferFullPath(routeNode)\n\n  if (fullPath === '/') return fullPath\n\n  return fullPath.replace(/\\/$/, '')\n}\n\n/**\n * Dedupes branches and index routes\n */\nexport const dedupeBranchesAndIndexRoutes = (\n  routes: Array<RouteNode>,\n): Array<RouteNode> => {\n  return routes.filter((route) => {\n    if (route.children?.find((child) => child.cleanedPath === '/')) return false\n    return true\n  })\n}\n\nfunction checkUnique<TElement>(routes: Array<TElement>, key: keyof TElement) {\n  // Check no two routes have the same `key`\n  // if they do, throw an error with the conflicting filePaths\n  const keys = routes.map((d) => d[key])\n  const uniqueKeys = new Set(keys)\n  if (keys.length !== uniqueKeys.size) {\n    const duplicateKeys = keys.filter((d, i) => keys.indexOf(d) !== i)\n    const conflictingFiles = routes.filter((d) =>\n      duplicateKeys.includes(d[key]),\n    )\n    return conflictingFiles\n  }\n  return undefined\n}\n\nfunction checkRouteFullPathUniqueness(\n  _routes: Array<RouteNode>,\n  config: Config,\n) {\n  const routes = _routes.map((d) => {\n    const inferredFullPath = inferFullPath(d)\n    return { ...d, inferredFullPath }\n  })\n\n  const conflictingFiles = checkUnique(routes, 'inferredFullPath')\n\n  if (conflictingFiles !== undefined) {\n    const errorMessage = `Conflicting configuration paths were found for the following route${conflictingFiles.length > 1 ? 's' : ''}: ${conflictingFiles\n      .map((p) => `\"${p.inferredFullPath}\"`)\n      .join(', ')}.\nPlease ensure each route has a unique full path.\nConflicting files: \\n ${conflictingFiles.map((d) => path.resolve(config.routesDirectory, d.filePath)).join('\\n ')}\\n`\n    throw new Error(errorMessage)\n  }\n}\n\nfunction checkStartAPIRoutes(_routes: Array<RouteNode>, config: Config) {\n  if (_routes.length === 0) {\n    return []\n  }\n\n  // Make sure these are valid URLs\n  // Route Groups and Layout Routes aren't being removed since\n  // you may want to have an API route that starts with an underscore\n  // or be wrapped in parentheses\n  const routes = _routes.map((d) => {\n    const routePath = removeTrailingSlash(d.routePath ?? '')\n    return { ...d, routePath }\n  })\n\n  const conflictingFiles = checkUnique(routes, 'routePath')\n\n  if (conflictingFiles !== undefined) {\n    const errorMessage = `Conflicting configuration paths were found for the following API route${conflictingFiles.length > 1 ? 's' : ''}: ${conflictingFiles\n      .map((p) => `\"${p}\"`)\n      .join(', ')}.\n  Please ensure each API route has a unique route path.\nConflicting files: \\n ${conflictingFiles.map((d) => path.resolve(config.routesDirectory, d.filePath)).join('\\n ')}\\n`\n    throw new Error(errorMessage)\n  }\n\n  return routes\n}\n\nexport type StartAPIRoutePathSegment = {\n  value: string\n  type: 'path' | 'param' | 'splat'\n}\n\n/**\n * This function takes in a path in the format accepted by TanStack Router\n * and returns an array of path segments that can be used to generate\n * the pathname of the TanStack Start API route.\n *\n * @param src\n * @returns\n */\nexport function startAPIRouteSegmentsFromTSRFilePath(\n  src: string,\n  config: Config,\n): Array<StartAPIRoutePathSegment> {\n  const routePath = determineInitialRoutePath(src)\n\n  const parts = routePath\n    .replaceAll('.', '/')\n    .split('/')\n    .filter((p) => !!p && p !== config.indexToken)\n  const segments: Array<StartAPIRoutePathSegment> = parts.map((part) => {\n    if (part.startsWith('$')) {\n      if (part === '$') {\n        return { value: part, type: 'splat' }\n      }\n\n      part.replaceAll('$', '')\n      return { value: part, type: 'param' }\n    }\n\n    return { value: part, type: 'path' }\n  })\n\n  return segments\n}\n"],"names":["virtualGetRouteNodes","physicalGetRouteNodes","children"],"mappings":"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"}