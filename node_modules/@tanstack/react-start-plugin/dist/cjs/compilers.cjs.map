{"version":3,"file":"compilers.cjs","sources":["../../src/compilers.ts"],"sourcesContent":["import * as babel from '@babel/core'\nimport * as t from '@babel/types'\nimport { codeFrameColumns } from '@babel/code-frame'\nimport {\n  deadCodeElimination,\n  findReferencedIdentifiers,\n} from 'babel-dead-code-elimination'\nimport { generateFromAst, parseAst } from '@tanstack/router-utils'\nimport type { GeneratorResult, ParseAstOptions } from '@tanstack/router-utils'\n\n// build these once and reuse them\nconst handleServerOnlyCallExpression =\n  buildEnvOnlyCallExpressionHandler('server')\nconst handleClientOnlyCallExpression =\n  buildEnvOnlyCallExpressionHandler('client')\n\ntype CompileOptions = ParseAstOptions & {\n  env: 'server' | 'client' | 'ssr'\n  dce?: boolean\n}\n\ntype IdentifierConfig = {\n  name: string\n  type: 'ImportSpecifier' | 'ImportNamespaceSpecifier'\n  namespaceId: string\n  handleCallExpression: (\n    path: babel.NodePath<t.CallExpression>,\n    opts: CompileOptions,\n  ) => void\n  paths: Array<babel.NodePath>\n}\n\nexport function compileStartOutput(opts: CompileOptions): GeneratorResult {\n  const ast = parseAst(opts)\n\n  const doDce = opts.dce ?? true\n  // find referenced identifiers *before* we transform anything\n  const refIdents = doDce ? findReferencedIdentifiers(ast) : undefined\n\n  babel.traverse(ast, {\n    Program: {\n      enter(programPath) {\n        const identifiers: {\n          createServerFn: IdentifierConfig\n          createMiddleware: IdentifierConfig\n          serverOnly: IdentifierConfig\n          clientOnly: IdentifierConfig\n          createIsomorphicFn: IdentifierConfig\n        } = {\n          createServerFn: {\n            name: 'createServerFn',\n            type: 'ImportSpecifier',\n            namespaceId: '',\n            handleCallExpression: handleCreateServerFnCallExpression,\n            paths: [],\n          },\n          createMiddleware: {\n            name: 'createMiddleware',\n            type: 'ImportSpecifier',\n            namespaceId: '',\n            handleCallExpression: handleCreateMiddlewareCallExpression,\n            paths: [],\n          },\n          serverOnly: {\n            name: 'serverOnly',\n            type: 'ImportSpecifier',\n            namespaceId: '',\n            handleCallExpression: handleServerOnlyCallExpression,\n            paths: [],\n          },\n          clientOnly: {\n            name: 'clientOnly',\n            type: 'ImportSpecifier',\n            namespaceId: '',\n            handleCallExpression: handleClientOnlyCallExpression,\n            paths: [],\n          },\n          createIsomorphicFn: {\n            name: 'createIsomorphicFn',\n            type: 'ImportSpecifier',\n            namespaceId: '',\n            handleCallExpression: handleCreateIsomorphicFnCallExpression,\n            paths: [],\n          },\n        }\n\n        const identifierKeys = Object.keys(identifiers) as Array<\n          keyof typeof identifiers\n        >\n\n        programPath.traverse({\n          ImportDeclaration: (path) => {\n            if (path.node.source.value !== '@tanstack/react-start') {\n              return\n            }\n\n            // handle a destructured imports being renamed like \"import { createServerFn as myCreateServerFn } from '@tanstack/react-start';\"\n            path.node.specifiers.forEach((specifier) => {\n              identifierKeys.forEach((identifierKey) => {\n                const identifier = identifiers[identifierKey]\n\n                if (\n                  specifier.type === 'ImportSpecifier' &&\n                  specifier.imported.type === 'Identifier'\n                ) {\n                  if (specifier.imported.name === identifierKey) {\n                    identifier.name = specifier.local.name\n                    identifier.type = 'ImportSpecifier'\n                  }\n                }\n\n                // handle namespace imports like \"import * as TanStackStart from '@tanstack/react-start';\"\n                if (specifier.type === 'ImportNamespaceSpecifier') {\n                  identifier.type = 'ImportNamespaceSpecifier'\n                  identifier.namespaceId = specifier.local.name\n                  identifier.name = `${identifier.namespaceId}.${identifierKey}`\n                }\n              })\n            })\n          },\n          CallExpression: (path) => {\n            identifierKeys.forEach((identifierKey) => {\n              // Check to see if the call expression is a call to the\n              // identifiers[identifierKey].name\n              if (\n                t.isIdentifier(path.node.callee) &&\n                path.node.callee.name === identifiers[identifierKey].name\n              ) {\n                // The identifier could be a call to the original function\n                // in the source code. If this is case, we need to ignore it.\n                // Check the scope to see if the identifier is a function declaration.\n                // if it is, then we can ignore it.\n\n                if (\n                  path.scope.getBinding(identifiers[identifierKey].name)?.path\n                    .node.type === 'FunctionDeclaration'\n                ) {\n                  return\n                }\n\n                return identifiers[identifierKey].paths.push(path)\n              }\n\n              if (t.isMemberExpression(path.node.callee)) {\n                if (\n                  t.isIdentifier(path.node.callee.object) &&\n                  t.isIdentifier(path.node.callee.property)\n                ) {\n                  const callname = [\n                    path.node.callee.object.name,\n                    path.node.callee.property.name,\n                  ].join('.')\n\n                  if (callname === identifiers[identifierKey].name) {\n                    identifiers[identifierKey].paths.push(path)\n                  }\n                }\n              }\n\n              return\n            })\n          },\n        })\n\n        identifierKeys.forEach((identifierKey) => {\n          identifiers[identifierKey].paths.forEach((path) => {\n            identifiers[identifierKey].handleCallExpression(\n              path as babel.NodePath<t.CallExpression>,\n              opts,\n            )\n          })\n        })\n      },\n    },\n  })\n\n  if (doDce) {\n    deadCodeElimination(ast, refIdents)\n  }\n\n  return generateFromAst(ast, {\n    sourceMaps: true,\n    sourceFileName: opts.filename,\n    filename: opts.filename,\n  })\n}\n\nfunction handleCreateServerFnCallExpression(\n  path: babel.NodePath<t.CallExpression>,\n  opts: ParseAstOptions,\n) {\n  // The function is the 'fn' property of the object passed to createServerFn\n\n  // const firstArg = path.node.arguments[0]\n  // if (t.isObjectExpression(firstArg)) {\n  //   // Was called with some options\n  // }\n\n  // Traverse the member expression and find the call expressions for\n  // the validator, handler, and middleware methods. Check to make sure they\n  // are children of the createServerFn call expression.\n\n  const calledOptions = path.node.arguments[0]\n    ? (path.get('arguments.0') as babel.NodePath<t.ObjectExpression>)\n    : null\n\n  const shouldValidateClient = !!calledOptions?.node.properties.find((prop) => {\n    return (\n      t.isObjectProperty(prop) &&\n      t.isIdentifier(prop.key) &&\n      prop.key.name === 'validateClient' &&\n      t.isBooleanLiteral(prop.value) &&\n      prop.value.value === true\n    )\n  })\n\n  const callExpressionPaths = {\n    middleware: null as babel.NodePath<t.CallExpression> | null,\n    validator: null as babel.NodePath<t.CallExpression> | null,\n    handler: null as babel.NodePath<t.CallExpression> | null,\n  }\n\n  const validMethods = Object.keys(callExpressionPaths)\n\n  const rootCallExpression = getRootCallExpression(path)\n\n  // if (debug)\n  //   console.info(\n  //     'Handling createServerFn call expression:',\n  //     rootCallExpression.toString(),\n  //   )\n\n  // Check if the call is assigned to a variable\n  if (!rootCallExpression.parentPath.isVariableDeclarator()) {\n    throw new Error('createServerFn must be assigned to a variable!')\n  }\n\n  // Get the identifier name of the variable\n  const variableDeclarator = rootCallExpression.parentPath.node\n  const existingVariableName = (variableDeclarator.id as t.Identifier).name\n\n  rootCallExpression.traverse({\n    MemberExpression(memberExpressionPath) {\n      if (t.isIdentifier(memberExpressionPath.node.property)) {\n        const name = memberExpressionPath.node.property\n          .name as keyof typeof callExpressionPaths\n\n        if (\n          validMethods.includes(name) &&\n          memberExpressionPath.parentPath.isCallExpression()\n        ) {\n          callExpressionPaths[name] = memberExpressionPath.parentPath\n        }\n      }\n    },\n  })\n\n  if (callExpressionPaths.validator) {\n    const innerInputExpression = callExpressionPaths.validator.node.arguments[0]\n\n    if (!innerInputExpression) {\n      throw new Error(\n        'createServerFn().validator() must be called with a validator!',\n      )\n    }\n\n    // If we're on the client, and we're not validating the client, remove the validator call expression\n    if (\n      opts.env === 'client' &&\n      !shouldValidateClient &&\n      t.isMemberExpression(callExpressionPaths.validator.node.callee)\n    ) {\n      callExpressionPaths.validator.replaceWith(\n        callExpressionPaths.validator.node.callee.object,\n      )\n    }\n  }\n\n  // First, we need to move the handler function to a nested function call\n  // that is applied to the arguments passed to the server function.\n\n  const handlerFnPath = callExpressionPaths.handler?.get(\n    'arguments.0',\n  ) as babel.NodePath<any>\n\n  if (!callExpressionPaths.handler || !handlerFnPath.node) {\n    throw codeFrameError(\n      opts.code,\n      path.node.callee.loc!,\n      `createServerFn must be called with a \"handler\" property!`,\n    )\n  }\n\n  const handlerFn = handlerFnPath.node\n\n  // So, the way we do this is we give the handler function a way\n  // to access the serverFn ctx on the server via function scope.\n  // The 'use server' extracted function will be called with the\n  // payload from the client, then use the scoped serverFn ctx\n  // to execute the handler function.\n  // This way, we can do things like data and middleware validation\n  // in the __execute function without having to AST transform the\n  // handler function too much itself.\n\n  // .handler((optsOut, ctx) => {\n  //   return ((optsIn) => {\n  //     'use server'\n  //     ctx.__execute(handlerFn, optsIn)\n  //   })(optsOut)\n  // })\n\n  // If the handler function is an identifier and we're on the client, we need to\n  // remove the bound function from the file.\n  // If we're on the server, you can leave it, since it will get referenced\n  // as a second argument.\n\n  if (t.isIdentifier(handlerFn)) {\n    if (opts.env === 'client' || opts.env === 'ssr') {\n      // Find the binding for the handler function\n      const binding = handlerFnPath.scope.getBinding(handlerFn.name)\n      // Remove it\n      if (binding) {\n        binding.path.remove()\n      }\n    }\n    // If the env is server, just leave it alone\n  }\n\n  handlerFnPath.replaceWith(\n    t.arrowFunctionExpression(\n      [t.identifier('opts'), t.identifier('signal')],\n      t.blockStatement(\n        // Everything in here is server-only, since the client\n        // will strip out anything in the 'use server' directive.\n        [\n          t.returnStatement(\n            t.callExpression(\n              t.identifier(`${existingVariableName}.__executeServer`),\n              [t.identifier('opts'), t.identifier('signal')],\n            ),\n          ),\n        ],\n        [t.directive(t.directiveLiteral('use server'))],\n      ),\n    ),\n  )\n\n  if (opts.env === 'server') {\n    callExpressionPaths.handler.node.arguments.push(handlerFn)\n  }\n}\n\nfunction handleCreateMiddlewareCallExpression(\n  path: babel.NodePath<t.CallExpression>,\n  opts: ParseAstOptions,\n) {\n  const rootCallExpression = getRootCallExpression(path)\n\n  // if (debug)\n  //   console.info(\n  //     'Handling createMiddleware call expression:',\n  //     rootCallExpression.toString(),\n  //   )\n\n  const callExpressionPaths = {\n    middleware: null as babel.NodePath<t.CallExpression> | null,\n    validator: null as babel.NodePath<t.CallExpression> | null,\n    client: null as babel.NodePath<t.CallExpression> | null,\n    server: null as babel.NodePath<t.CallExpression> | null,\n  }\n\n  const validMethods = Object.keys(callExpressionPaths)\n\n  rootCallExpression.traverse({\n    MemberExpression(memberExpressionPath) {\n      if (t.isIdentifier(memberExpressionPath.node.property)) {\n        const name = memberExpressionPath.node.property\n          .name as keyof typeof callExpressionPaths\n\n        if (\n          validMethods.includes(name) &&\n          memberExpressionPath.parentPath.isCallExpression()\n        ) {\n          callExpressionPaths[name] = memberExpressionPath.parentPath\n        }\n      }\n    },\n  })\n\n  if (callExpressionPaths.validator) {\n    const innerInputExpression = callExpressionPaths.validator.node.arguments[0]\n\n    if (!innerInputExpression) {\n      throw new Error(\n        'createMiddleware().validator() must be called with a validator!',\n      )\n    }\n\n    // If we're on the client or ssr, remove the validator call expression\n    if (opts.env === 'client' || opts.env === 'ssr') {\n      if (t.isMemberExpression(callExpressionPaths.validator.node.callee)) {\n        callExpressionPaths.validator.replaceWith(\n          callExpressionPaths.validator.node.callee.object,\n        )\n      }\n    }\n  }\n\n  const serverFnPath = callExpressionPaths.server?.get(\n    'arguments.0',\n  ) as babel.NodePath<any>\n\n  if (\n    callExpressionPaths.server &&\n    serverFnPath.node &&\n    (opts.env === 'client' || opts.env === 'ssr')\n  ) {\n    // If we're on the client, remove the server call expression\n    if (t.isMemberExpression(callExpressionPaths.server.node.callee)) {\n      callExpressionPaths.server.replaceWith(\n        callExpressionPaths.server.node.callee.object,\n      )\n    }\n  }\n}\n\nfunction buildEnvOnlyCallExpressionHandler(env: 'client' | 'server') {\n  return function envOnlyCallExpressionHandler(\n    path: babel.NodePath<t.CallExpression>,\n    opts: ParseAstOptions,\n  ) {\n    // if (debug)\n    //   console.info(`Handling ${env}Only call expression:`, path.toString())\n\n    const isEnvMatch =\n      env === 'client'\n        ? opts.env === 'client'\n        : opts.env === 'server' || opts.env === 'ssr'\n\n    if (isEnvMatch) {\n      // extract the inner function from the call expression\n      const innerInputExpression = path.node.arguments[0]\n\n      if (!t.isExpression(innerInputExpression)) {\n        throw new Error(\n          `${env}Only() functions must be called with a function!`,\n        )\n      }\n\n      path.replaceWith(innerInputExpression)\n      return\n    }\n\n    // If we're on the wrong environment, replace the call expression\n    // with a function that always throws an error.\n    path.replaceWith(\n      t.arrowFunctionExpression(\n        [],\n        t.blockStatement([\n          t.throwStatement(\n            t.newExpression(t.identifier('Error'), [\n              t.stringLiteral(\n                `${env}Only() functions can only be called on the ${env}!`,\n              ),\n            ]),\n          ),\n        ]),\n      ),\n    )\n  }\n}\n\nfunction handleCreateIsomorphicFnCallExpression(\n  path: babel.NodePath<t.CallExpression>,\n  opts: CompileOptions,\n) {\n  const rootCallExpression = getRootCallExpression(path)\n\n  // if (debug)\n  //   console.info(\n  //     'Handling createIsomorphicFn call expression:',\n  //     rootCallExpression.toString(),\n  //   )\n\n  const callExpressionPaths = {\n    client: null as babel.NodePath<t.CallExpression> | null,\n    server: null as babel.NodePath<t.CallExpression> | null,\n  }\n\n  const validMethods = Object.keys(callExpressionPaths)\n\n  rootCallExpression.traverse({\n    MemberExpression(memberExpressionPath) {\n      if (t.isIdentifier(memberExpressionPath.node.property)) {\n        const name = memberExpressionPath.node.property\n          .name as keyof typeof callExpressionPaths\n\n        if (\n          validMethods.includes(name) &&\n          memberExpressionPath.parentPath.isCallExpression()\n        ) {\n          callExpressionPaths[name] = memberExpressionPath.parentPath\n        }\n      }\n    },\n  })\n\n  if (\n    validMethods.every(\n      (method) =>\n        !callExpressionPaths[method as keyof typeof callExpressionPaths],\n    )\n  ) {\n    const variableId = rootCallExpression.parentPath.isVariableDeclarator()\n      ? rootCallExpression.parentPath.node.id\n      : null\n    console.warn(\n      'createIsomorphicFn called without a client or server implementation!',\n      'This will result in a no-op function.',\n      'Variable name:',\n      t.isIdentifier(variableId) ? variableId.name : 'unknown',\n    )\n  }\n\n  const resolvedEnv = opts.env === 'ssr' ? 'server' : opts.env\n\n  const envCallExpression = callExpressionPaths[resolvedEnv]\n\n  if (!envCallExpression) {\n    // if we don't have an implementation for this environment, default to a no-op\n    rootCallExpression.replaceWith(\n      t.arrowFunctionExpression([], t.blockStatement([])),\n    )\n    return\n  }\n\n  const innerInputExpression = envCallExpression.node.arguments[0]\n\n  if (!t.isExpression(innerInputExpression)) {\n    throw new Error(\n      `createIsomorphicFn().${resolvedEnv}(func) must be called with a function!`,\n    )\n  }\n\n  rootCallExpression.replaceWith(innerInputExpression)\n}\n\nfunction getRootCallExpression(path: babel.NodePath<t.CallExpression>) {\n  // Find the highest callExpression parent\n  let rootCallExpression: babel.NodePath<t.CallExpression> = path\n\n  // Traverse up the chain of CallExpressions\n  while (rootCallExpression.parentPath.isMemberExpression()) {\n    const parent = rootCallExpression.parentPath\n    if (parent.parentPath.isCallExpression()) {\n      rootCallExpression = parent.parentPath\n    }\n  }\n\n  return rootCallExpression\n}\n\nfunction codeFrameError(\n  code: string,\n  loc: {\n    start: { line: number; column: number }\n    end: { line: number; column: number }\n  },\n  message: string,\n) {\n  const frame = codeFrameColumns(\n    code,\n    {\n      start: loc.start,\n      end: loc.end,\n    },\n    {\n      highlightCode: true,\n      message,\n    },\n  )\n\n  return new Error(frame)\n}\n"],"names":["parseAst","findReferencedIdentifiers","babel","t","deadCodeElimination","generateFromAst","codeFrameColumns"],"mappings":"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"}