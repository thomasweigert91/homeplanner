{"version":3,"file":"h3.js","sources":["../../src/h3.ts"],"sourcesContent":["import { AsyncLocalStorage } from 'node:async_hooks'\nimport {\n  H3Event,\n  appendCorsHeaders as _appendCorsHeaders,\n  appendCorsPreflightHeaders as _appendCorsPreflightHeaders,\n  appendHeader as _appendHeader,\n  appendHeaders as _appendHeaders,\n  appendResponseHeader as _appendResponseHeader,\n  appendResponseHeaders as _appendResponseHeaders,\n  assertMethod as _assertMethod,\n  clearResponseHeaders as _clearResponseHeaders,\n  clearSession as _clearSession,\n  defaultContentType as _defaultContentType,\n  deleteCookie as _deleteCookie,\n  fetchWithEvent as _fetchWithEvent,\n  getCookie as _getCookie,\n  getHeader as _getHeader,\n  getHeaders as _getHeaders,\n  getProxyRequestHeaders as _getProxyRequestHeaders,\n  getQuery as _getQuery,\n  getRequestFingerprint as _getRequestFingerprint,\n  getRequestHeader as _getRequestHeader,\n  getRequestHeaders as _getRequestHeaders,\n  getRequestHost as _getRequestHost,\n  getRequestIP as _getRequestIP,\n  getRequestProtocol as _getRequestProtocol,\n  getRequestURL as _getRequestURL,\n  getRequestWebStream as _getRequestWebStream,\n  getResponseHeader as _getResponseHeader,\n  getResponseHeaders as _getResponseHeaders,\n  getResponseStatus as _getResponseStatus,\n  getResponseStatusText as _getResponseStatusText,\n  getRouterParam as _getRouterParam,\n  getRouterParams as _getRouterParams,\n  getSession as _getSession,\n  getValidatedQuery as _getValidatedQuery,\n  getValidatedRouterParams as _getValidatedRouterParams,\n  handleCacheHeaders as _handleCacheHeaders,\n  handleCors as _handleCors,\n  isMethod as _isMethod,\n  isPreflightRequest as _isPreflightRequest,\n  parseCookies as _parseCookies,\n  proxyRequest as _proxyRequest,\n  readBody as _readBody,\n  readFormData as _readFormData,\n  readMultipartFormData as _readMultipartFormData,\n  readRawBody as _readRawBody,\n  readValidatedBody as _readValidatedBody,\n  removeResponseHeader as _removeResponseHeader,\n  sealSession as _sealSession,\n  send as _send,\n  sendError as _sendError,\n  sendNoContent as _sendNoContent,\n  sendProxy as _sendProxy,\n  sendRedirect as _sendRedirect,\n  sendStream as _sendStream,\n  sendWebResponse as _sendWebResponse,\n  setCookie as _setCookie,\n  setHeader as _setHeader,\n  setHeaders as _setHeaders,\n  setResponseHeader as _setResponseHeader,\n  setResponseHeaders as _setResponseHeaders,\n  setResponseStatus as _setResponseStatus,\n  unsealSession as _unsealSession,\n  updateSession as _updateSession,\n  useSession as _useSession,\n  writeEarlyHints as _writeEarlyHints,\n} from 'h3'\nimport { getContext as getUnctxContext } from 'unctx'\nimport type {\n  Encoding,\n  HTTPHeaderName,\n  InferEventInput,\n  _RequestMiddleware,\n  _ResponseMiddleware,\n} from 'h3'\n\nfunction _setContext(event: H3Event, key: string, value: any) {\n  event.context[key] = value\n}\n\nfunction _getContext(event: H3Event, key: string) {\n  return event.context[key]\n}\n\nexport function defineMiddleware(options: {\n  onRequest?: _RequestMiddleware | Array<_RequestMiddleware>\n  onBeforeResponse?: _ResponseMiddleware | Array<_ResponseMiddleware>\n}) {\n  return options\n}\n\nfunction toWebRequestH3(event: H3Event) {\n  /**\n   * @type {ReadableStream | undefined}\n   */\n  let readableStream: ReadableStream | undefined\n\n  const url = getRequestURL(event)\n  const base = {\n    // @ts-ignore Undici option\n    duplex: 'half',\n    method: event.method,\n    headers: event.headers,\n  }\n\n  if ((event.node.req as any).body instanceof ArrayBuffer) {\n    return new Request(url, {\n      ...base,\n      body: (event.node.req as any).body,\n    })\n  }\n\n  return new Request(url, {\n    ...base,\n    get body() {\n      if (readableStream) {\n        return readableStream\n      }\n      readableStream = getRequestWebStream(event)\n      return readableStream\n    },\n  })\n}\n\nexport function toWebRequest(event: H3Event) {\n  event.web ??= {\n    request: toWebRequestH3(event),\n    url: getRequestURL(event),\n  }\n  return event.web.request\n}\n\nexport {\n  H3Error,\n  H3Event,\n  MIMES,\n  callNodeListener,\n  createApp,\n  createAppEventHandler,\n  createEvent,\n  createRouter,\n  defineEventHandler,\n  defineLazyEventHandler,\n  defineNodeListener,\n  defineNodeMiddleware,\n  defineRequestMiddleware,\n  defineResponseMiddleware,\n  dynamicEventHandler,\n  defineWebSocket,\n  eventHandler,\n  splitCookiesString,\n  fromNodeMiddleware,\n  fromPlainHandler,\n  fromWebHandler,\n  isError,\n  isEventHandler,\n  isWebResponse,\n  lazyEventHandler,\n  promisifyNodeListener,\n  serveStatic,\n  toEventHandler,\n  toNodeListener,\n  toPlainHandler,\n  toWebHandler,\n  isCorsOriginAllowed,\n  isStream,\n  createError,\n  sanitizeStatusCode,\n  sanitizeStatusMessage,\n  useBase,\n  type AddRouteShortcuts,\n  type App,\n  type AppOptions,\n  type AppUse,\n  type CacheConditions,\n  type CreateRouterOptions,\n  type Duplex,\n  type DynamicEventHandler,\n  type Encoding,\n  type EventHandler,\n  type EventHandlerObject,\n  type EventHandlerRequest,\n  type EventHandlerResponse,\n  type H3CorsOptions,\n  type H3EventContext,\n  type HTTPHeaderName,\n  type HTTPMethod,\n  type InferEventInput,\n  type InputLayer,\n  type InputStack,\n  type Layer,\n  type LazyEventHandler,\n  type Matcher,\n  type MultiPartData,\n  type NodeEventContext,\n  type NodeListener,\n  type NodeMiddleware,\n  type NodePromisifiedHandler,\n  type PlainHandler,\n  type PlainRequest,\n  type PlainResponse,\n  type ProxyOptions,\n  type RequestFingerprintOptions,\n  type RequestHeaders,\n  type RouteNode,\n  type Router,\n  type RouterMethod,\n  type RouterUse,\n  type ServeStaticOptions,\n  type Session,\n  type SessionConfig,\n  type SessionData,\n  type Stack,\n  type StaticAssetMeta,\n  type ValidateFunction,\n  type ValidateResult,\n  type WebEventContext,\n  type WebHandler,\n  type _RequestMiddleware,\n  type _ResponseMiddleware,\n} from 'h3'\n\nfunction getHTTPEvent() {\n  return getEvent()\n}\n\nexport const HTTPEventSymbol = Symbol('$HTTPEvent')\n\nexport function isEvent(\n  obj: any,\n): obj is H3Event | { [HTTPEventSymbol]: H3Event } {\n  return (\n    typeof obj === 'object' &&\n    (obj instanceof H3Event ||\n      obj?.[HTTPEventSymbol] instanceof H3Event ||\n      obj?.__is_event__ === true)\n  )\n  // Implement logic to check if obj is an H3Event\n}\n\ntype Tail<T> = T extends [any, ...infer U] ? U : never\n\ntype PrependOverload<\n  TOriginal extends (...args: Array<any>) => any,\n  TOverload extends (...args: Array<any>) => any,\n> = TOverload & TOriginal\n\n// add an overload to the function without the event argument\ntype WrapFunction<TFn extends (...args: Array<any>) => any> = PrependOverload<\n  TFn,\n  (\n    ...args: Parameters<TFn> extends [H3Event, ...infer TArgs]\n      ? TArgs\n      : Parameters<TFn>\n  ) => ReturnType<TFn>\n>\n\nfunction createWrapperFunction<TFn extends (...args: Array<any>) => any>(\n  h3Function: TFn,\n): WrapFunction<TFn> {\n  return function (...args: Array<any>) {\n    const event = args[0]\n    if (!isEvent(event)) {\n      if (!(globalThis as any).app.config.server.experimental?.asyncContext) {\n        throw new Error(\n          'AsyncLocalStorage was not enabled. Use the `server.experimental.asyncContext: true` option in your app configuration to enable it. Or, pass the instance of HTTPEvent that you have as the first argument to the function.',\n        )\n      }\n      args.unshift(getHTTPEvent())\n    } else {\n      args[0] =\n        event instanceof H3Event || (event as any).__is_event__\n          ? event\n          : event[HTTPEventSymbol]\n    }\n\n    return (h3Function as any)(...args)\n  } as any\n}\n\n// Creating wrappers for each utility and exporting them with their original names\ntype WrappedReadRawBody = <TEncoding extends Encoding = 'utf8'>(\n  ...args: Tail<Parameters<typeof _readRawBody<TEncoding>>>\n) => ReturnType<typeof _readRawBody<TEncoding>>\nexport const readRawBody: PrependOverload<\n  typeof _readRawBody,\n  WrappedReadRawBody\n> = createWrapperFunction(_readRawBody)\ntype WrappedReadBody = <T, TEventInput = InferEventInput<'body', H3Event, T>>(\n  ...args: Tail<Parameters<typeof _readBody<T, H3Event, TEventInput>>>\n) => ReturnType<typeof _readBody<T, H3Event, TEventInput>>\nexport const readBody: PrependOverload<typeof _readBody, WrappedReadBody> =\n  createWrapperFunction(_readBody)\ntype WrappedGetQuery = <\n  T,\n  TEventInput = Exclude<InferEventInput<'query', H3Event, T>, undefined>,\n>(\n  ...args: Tail<Parameters<typeof _getQuery<T, H3Event, TEventInput>>>\n) => ReturnType<typeof _getQuery<T, H3Event, TEventInput>>\nexport const getQuery: PrependOverload<typeof _getQuery, WrappedGetQuery> =\n  createWrapperFunction(_getQuery)\nexport const isMethod = createWrapperFunction(_isMethod)\nexport const isPreflightRequest = createWrapperFunction(_isPreflightRequest)\ntype WrappedGetValidatedQuery = <\n  T,\n  TEventInput = InferEventInput<'query', H3Event, T>,\n>(\n  ...args: Tail<Parameters<typeof _getValidatedQuery<T, H3Event, TEventInput>>>\n) => ReturnType<typeof _getValidatedQuery<T, H3Event, TEventInput>>\nexport const getValidatedQuery: PrependOverload<\n  typeof _getValidatedQuery,\n  WrappedGetValidatedQuery\n> = createWrapperFunction(_getValidatedQuery)\nexport const getRouterParams = createWrapperFunction(_getRouterParams)\nexport const getRouterParam = createWrapperFunction(_getRouterParam)\ntype WrappedGetValidatedRouterParams = <\n  T,\n  TEventInput = InferEventInput<'routerParams', H3Event, T>,\n>(\n  ...args: Tail<\n    Parameters<typeof _getValidatedRouterParams<T, H3Event, TEventInput>>\n  >\n) => ReturnType<typeof _getValidatedRouterParams<T, H3Event, TEventInput>>\nexport const getValidatedRouterParams: PrependOverload<\n  typeof _getValidatedRouterParams,\n  WrappedGetValidatedRouterParams\n> = createWrapperFunction(_getValidatedRouterParams)\nexport const assertMethod = createWrapperFunction(_assertMethod)\nexport const getRequestHeaders = createWrapperFunction(_getRequestHeaders)\nexport const getRequestHeader = createWrapperFunction(_getRequestHeader)\nexport const getRequestURL = createWrapperFunction(_getRequestURL)\nexport const getRequestHost = createWrapperFunction(_getRequestHost)\nexport const getRequestProtocol = createWrapperFunction(_getRequestProtocol)\nexport const getRequestIP = createWrapperFunction(_getRequestIP)\nexport const send = createWrapperFunction(_send)\nexport const sendNoContent = createWrapperFunction(_sendNoContent)\nexport const setResponseStatus = createWrapperFunction(_setResponseStatus)\nexport const getResponseStatus = createWrapperFunction(_getResponseStatus)\nexport const getResponseStatusText = createWrapperFunction(\n  _getResponseStatusText,\n)\nexport const getResponseHeaders = createWrapperFunction(_getResponseHeaders)\nexport const getResponseHeader = createWrapperFunction(_getResponseHeader)\nexport const setResponseHeaders = createWrapperFunction(_setResponseHeaders)\ntype WrappedSetResponseHeader = <T extends HTTPHeaderName>(\n  ...args: Tail<Parameters<typeof _setResponseHeader<T>>>\n) => ReturnType<typeof _setResponseHeader<T>>\nexport const setResponseHeader: PrependOverload<\n  typeof _setResponseHeader,\n  WrappedSetResponseHeader\n> = createWrapperFunction(_setResponseHeader)\nexport const appendResponseHeaders = createWrapperFunction(\n  _appendResponseHeaders,\n)\ntype WrappedAppendResponseHeader = <T extends HTTPHeaderName>(\n  ...args: Tail<Parameters<typeof _appendResponseHeader<T>>>\n) => ReturnType<typeof _appendResponseHeader<T>>\nexport const appendResponseHeader: PrependOverload<\n  typeof _appendResponseHeader,\n  WrappedAppendResponseHeader\n> = createWrapperFunction(_appendResponseHeader)\nexport const defaultContentType = createWrapperFunction(_defaultContentType)\nexport const sendRedirect = createWrapperFunction(_sendRedirect)\nexport const sendStream = createWrapperFunction(_sendStream)\nexport const writeEarlyHints = createWrapperFunction(_writeEarlyHints)\nexport const sendError = createWrapperFunction(_sendError)\nexport const sendProxy = createWrapperFunction(_sendProxy)\nexport const proxyRequest = createWrapperFunction(_proxyRequest)\ntype WrappedFetchWithEvent = <\n  T = unknown,\n  TResponse = any,\n  TFetch extends (req: RequestInfo | URL, opts?: any) => any = typeof fetch,\n>(\n  ...args: Tail<Parameters<typeof _fetchWithEvent<T, TResponse, TFetch>>>\n) => ReturnType<typeof _fetchWithEvent<T, TResponse, TFetch>>\nexport const fetchWithEvent: PrependOverload<\n  typeof _fetchWithEvent,\n  WrappedFetchWithEvent\n> = createWrapperFunction(_fetchWithEvent)\nexport const getProxyRequestHeaders = createWrapperFunction(\n  _getProxyRequestHeaders,\n)\n\nexport const parseCookies = createWrapperFunction(_parseCookies)\nexport const getCookie = createWrapperFunction(_getCookie)\nexport const setCookie = createWrapperFunction(_setCookie)\nexport const deleteCookie = createWrapperFunction(_deleteCookie)\n// not exported :(\ntype SessionDataT = Record<string, any>\ntype WrappedUseSession = <T extends SessionDataT>(\n  ...args: Tail<Parameters<typeof _useSession<T>>>\n) => ReturnType<typeof _useSession<T>>\n// we need to `as` these because the WrapFunction doesn't work for them\n// because they also accept CompatEvent instead of H3Event\nexport const useSession = createWrapperFunction(_useSession) as PrependOverload<\n  typeof _useSession,\n  WrappedUseSession\n>\ntype WrappedGetSession = <T extends SessionDataT>(\n  ...args: Tail<Parameters<typeof _getSession<T>>>\n) => ReturnType<typeof _getSession<T>>\nexport const getSession = createWrapperFunction(_getSession) as PrependOverload<\n  typeof _getSession,\n  WrappedGetSession\n>\ntype WrappedUpdateSession = <T extends SessionDataT>(\n  ...args: Tail<Parameters<typeof _updateSession<T>>>\n) => ReturnType<typeof _updateSession<T>>\nexport const updateSession: PrependOverload<\n  typeof _updateSession,\n  WrappedUpdateSession\n> = createWrapperFunction(_updateSession)\ntype WrappedSealSession = <T extends SessionDataT>(\n  ...args: Tail<Parameters<typeof _sealSession<T>>>\n) => ReturnType<typeof _sealSession<T>>\nexport const sealSession = createWrapperFunction(\n  _sealSession,\n) as PrependOverload<typeof _sealSession, WrappedSealSession>\nexport const unsealSession = createWrapperFunction(_unsealSession)\nexport const clearSession = createWrapperFunction(_clearSession)\nexport const handleCacheHeaders = createWrapperFunction(_handleCacheHeaders)\nexport const handleCors = createWrapperFunction(_handleCors)\nexport const appendCorsHeaders = createWrapperFunction(_appendCorsHeaders)\nexport const appendCorsPreflightHeaders = createWrapperFunction(\n  _appendCorsPreflightHeaders,\n)\nexport const sendWebResponse = createWrapperFunction(_sendWebResponse)\ntype WrappedAppendHeader = <T extends HTTPHeaderName>(\n  ...args: Tail<Parameters<typeof _appendHeader<T>>>\n) => ReturnType<typeof _appendHeader<T>>\nexport const appendHeader: PrependOverload<\n  typeof _appendHeader,\n  WrappedAppendHeader\n> = createWrapperFunction(_appendHeader)\nexport const appendHeaders = createWrapperFunction(_appendHeaders)\ntype WrappedSetHeader = <T extends HTTPHeaderName>(\n  ...args: Tail<Parameters<typeof _setHeader<T>>>\n) => ReturnType<typeof _setHeader<T>>\nexport const setHeader: PrependOverload<typeof _setHeader, WrappedSetHeader> =\n  createWrapperFunction(_setHeader)\nexport const setHeaders = createWrapperFunction(_setHeaders)\nexport const getHeader = createWrapperFunction(_getHeader)\nexport const getHeaders = createWrapperFunction(_getHeaders)\nexport const getRequestFingerprint = createWrapperFunction(\n  _getRequestFingerprint,\n)\nexport const getRequestWebStream = createWrapperFunction(_getRequestWebStream)\nexport const readFormData = createWrapperFunction(_readFormData)\nexport const readMultipartFormData = createWrapperFunction(\n  _readMultipartFormData,\n)\ntype WrappedReadValidatedBody = <\n  T,\n  TEventInput = InferEventInput<'body', H3Event, T>,\n>(\n  ...args: Tail<Parameters<typeof _readValidatedBody<T, H3Event, TEventInput>>>\n) => ReturnType<typeof _readValidatedBody<T, H3Event, TEventInput>>\nexport const readValidatedBody: PrependOverload<\n  typeof _readValidatedBody,\n  WrappedReadValidatedBody\n> = createWrapperFunction(_readValidatedBody)\nexport const removeResponseHeader = createWrapperFunction(_removeResponseHeader)\nexport const getContext = createWrapperFunction(_getContext)\nexport const setContext = createWrapperFunction(_setContext)\n\nexport const clearResponseHeaders = createWrapperFunction(_clearResponseHeaders)\n\nexport const getWebRequest = createWrapperFunction(toWebRequest)\n\nexport { createApp as createServer } from 'h3'\n\nfunction getNitroAsyncContext() {\n  const nitroAsyncContext = getUnctxContext('nitro-app', {\n    asyncContext: (globalThis as any).app.config.server.experimental\n      ?.asyncContext\n      ? true\n      : false,\n    AsyncLocalStorage,\n  })\n\n  return nitroAsyncContext\n}\n\nexport function getEvent() {\n  const event = (getNitroAsyncContext().use() as any).event as\n    | H3Event\n    | undefined\n  if (!event) {\n    throw new Error(\n      `No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.`,\n    )\n  }\n  return event\n}\n\nexport async function handleHTTPEvent(event: H3Event) {\n  return await (globalThis as any).$handle(event)\n}\n"],"names":["_readRawBody","_readBody","_getQuery","_isMethod","_isPreflightRequest","_getValidatedQuery","_getRouterParams","_getRouterParam","_getValidatedRouterParams","_assertMethod","_getRequestHeaders","_getRequestHeader","_getRequestURL","_getRequestHost","_getRequestProtocol","_getRequestIP","_send","_sendNoContent","_setResponseStatus","_getResponseStatus","_getResponseStatusText","_getResponseHeaders","_getResponseHeader","_setResponseHeaders","_setResponseHeader","_appendResponseHeaders","_appendResponseHeader","_defaultContentType","_sendRedirect","_sendStream","_writeEarlyHints","_sendError","_sendProxy","_proxyRequest","_fetchWithEvent","_getProxyRequestHeaders","_parseCookies","_getCookie","_setCookie","_deleteCookie","_useSession","_getSession","_updateSession","_sealSession","_unsealSession","_clearSession","_handleCacheHeaders","_handleCors","_appendCorsHeaders","_appendCorsPreflightHeaders","_sendWebResponse","_appendHeader","_appendHeaders","_setHeader","_setHeaders","_getHeader","_getHeaders","_getRequestFingerprint","_getRequestWebStream","_readFormData","_readMultipartFormData","_readValidatedBody","_removeResponseHeader","_clearResponseHeaders","getUnctxContext"],"mappings":";;;;AA6EA,SAAS,YAAY,OAAgB,KAAa,OAAY;AACtD,QAAA,QAAQ,GAAG,IAAI;AACvB;AAEA,SAAS,YAAY,OAAgB,KAAa;AACzC,SAAA,MAAM,QAAQ,GAAG;AAC1B;AAEO,SAAS,iBAAiB,SAG9B;AACM,SAAA;AACT;AAEA,SAAS,eAAe,OAAgB;AAIlC,MAAA;AAEE,QAAA,MAAM,cAAc,KAAK;AAC/B,QAAM,OAAO;AAAA;AAAA,IAEX,QAAQ;AAAA,IACR,QAAQ,MAAM;AAAA,IACd,SAAS,MAAM;AAAA,EACjB;AAEA,MAAK,MAAM,KAAK,IAAY,gBAAgB,aAAa;AAChD,WAAA,IAAI,QAAQ,KAAK;AAAA,MACtB,GAAG;AAAA,MACH,MAAO,MAAM,KAAK,IAAY;AAAA,IAAA,CAC/B;AAAA,EAAA;AAGI,SAAA,IAAI,QAAQ,KAAK;AAAA,IACtB,GAAG;AAAA,IACH,IAAI,OAAO;AACT,UAAI,gBAAgB;AACX,eAAA;AAAA,MAAA;AAET,uBAAiB,oBAAoB,KAAK;AACnC,aAAA;AAAA,IAAA;AAAA,EACT,CACD;AACH;AAEO,SAAS,aAAa,OAAgB;AAC3C,QAAM,QAAN,MAAM,MAAQ;AAAA,IACZ,SAAS,eAAe,KAAK;AAAA,IAC7B,KAAK,cAAc,KAAK;AAAA,EAC1B;AACA,SAAO,MAAM,IAAI;AACnB;AA4FA,SAAS,eAAe;AACtB,SAAO,SAAS;AAClB;AAEa,MAAA,kBAAkB,OAAO,YAAY;AAE3C,SAAS,QACd,KACiD;AAE/C,SAAA,OAAO,QAAQ,aACd,eAAe,YACd,2BAAM,6BAA4B,YAClC,2BAAK,kBAAiB;AAG5B;AAmBA,SAAS,sBACP,YACmB;AACnB,SAAO,YAAa,MAAkB;;AAC9B,UAAA,QAAQ,KAAK,CAAC;AAChB,QAAA,CAAC,QAAQ,KAAK,GAAG;AACnB,UAAI,GAAE,gBAAmB,IAAI,OAAO,OAAO,iBAArC,mBAAmD,eAAc;AACrE,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MAAA;AAEG,WAAA,QAAQ,cAAc;AAAA,IAAA,OACtB;AACA,WAAA,CAAC,IACJ,iBAAiB,WAAY,MAAc,eACvC,QACA,MAAM,eAAe;AAAA,IAAA;AAGrB,WAAA,WAAmB,GAAG,IAAI;AAAA,EACpC;AACF;AAMa,MAAA,cAGT,sBAAsBA,aAAY;AAIzB,MAAA,WACX,sBAAsBC,UAAS;AAOpB,MAAA,WACX,sBAAsBC,UAAS;AACpB,MAAA,WAAW,sBAAsBC,UAAS;AAC1C,MAAA,qBAAqB,sBAAsBC,oBAAmB;AAO9D,MAAA,oBAGT,sBAAsBC,mBAAkB;AAC/B,MAAA,kBAAkB,sBAAsBC,iBAAgB;AACxD,MAAA,iBAAiB,sBAAsBC,gBAAe;AAStD,MAAA,2BAGT,sBAAsBC,0BAAyB;AACtC,MAAA,eAAe,sBAAsBC,cAAa;AAClD,MAAA,oBAAoB,sBAAsBC,mBAAkB;AAC5D,MAAA,mBAAmB,sBAAsBC,kBAAiB;AAC1D,MAAA,gBAAgB,sBAAsBC,eAAc;AACpD,MAAA,iBAAiB,sBAAsBC,gBAAe;AACtD,MAAA,qBAAqB,sBAAsBC,oBAAmB;AAC9D,MAAA,eAAe,sBAAsBC,cAAa;AAClD,MAAA,OAAO,sBAAsBC,MAAK;AAClC,MAAA,gBAAgB,sBAAsBC,eAAc;AACpD,MAAA,oBAAoB,sBAAsBC,mBAAkB;AAC5D,MAAA,oBAAoB,sBAAsBC,mBAAkB;AAClE,MAAM,wBAAwB;AAAA,EACnCC;AACF;AACa,MAAA,qBAAqB,sBAAsBC,oBAAmB;AAC9D,MAAA,oBAAoB,sBAAsBC,mBAAkB;AAC5D,MAAA,qBAAqB,sBAAsBC,oBAAmB;AAI9D,MAAA,oBAGT,sBAAsBC,mBAAkB;AACrC,MAAM,wBAAwB;AAAA,EACnCC;AACF;AAIa,MAAA,uBAGT,sBAAsBC,sBAAqB;AAClC,MAAA,qBAAqB,sBAAsBC,oBAAmB;AAC9D,MAAA,eAAe,sBAAsBC,cAAa;AAClD,MAAA,aAAa,sBAAsBC,YAAW;AAC9C,MAAA,kBAAkB,sBAAsBC,iBAAgB;AACxD,MAAA,YAAY,sBAAsBC,WAAU;AAC5C,MAAA,YAAY,sBAAsBC,WAAU;AAC5C,MAAA,eAAe,sBAAsBC,cAAa;AAQlD,MAAA,iBAGT,sBAAsBC,gBAAe;AAClC,MAAM,yBAAyB;AAAA,EACpCC;AACF;AAEa,MAAA,eAAe,sBAAsBC,cAAa;AAClD,MAAA,YAAY,sBAAsBC,WAAU;AAC5C,MAAA,YAAY,sBAAsBC,WAAU;AAC5C,MAAA,eAAe,sBAAsBC,cAAa;AAQlD,MAAA,aAAa,sBAAsBC,YAAW;AAO9C,MAAA,aAAa,sBAAsBC,YAAW;AAO9C,MAAA,gBAGT,sBAAsBC,eAAc;AAIjC,MAAM,cAAc;AAAA,EACzBC;AACF;AACa,MAAA,gBAAgB,sBAAsBC,eAAc;AACpD,MAAA,eAAe,sBAAsBC,cAAa;AAClD,MAAA,qBAAqB,sBAAsBC,oBAAmB;AAC9D,MAAA,aAAa,sBAAsBC,YAAW;AAC9C,MAAA,oBAAoB,sBAAsBC,mBAAkB;AAClE,MAAM,6BAA6B;AAAA,EACxCC;AACF;AACa,MAAA,kBAAkB,sBAAsBC,iBAAgB;AAIxD,MAAA,eAGT,sBAAsBC,cAAa;AAC1B,MAAA,gBAAgB,sBAAsBC,eAAc;AAIpD,MAAA,YACX,sBAAsBC,WAAU;AACrB,MAAA,aAAa,sBAAsBC,YAAW;AAC9C,MAAA,YAAY,sBAAsBC,WAAU;AAC5C,MAAA,aAAa,sBAAsBC,YAAW;AACpD,MAAM,wBAAwB;AAAA,EACnCC;AACF;AACa,MAAA,sBAAsB,sBAAsBC,qBAAoB;AAChE,MAAA,eAAe,sBAAsBC,cAAa;AACxD,MAAM,wBAAwB;AAAA,EACnCC;AACF;AAOa,MAAA,oBAGT,sBAAsBC,mBAAkB;AAC/B,MAAA,uBAAuB,sBAAsBC,sBAAqB;AAClE,MAAA,aAAa,sBAAsB,WAAW;AAC9C,MAAA,aAAa,sBAAsB,WAAW;AAE9C,MAAA,uBAAuB,sBAAsBC,sBAAqB;AAElE,MAAA,gBAAgB,sBAAsB,YAAY;AAI/D,SAAS,uBAAuB;;AACxB,QAAA,oBAAoBC,aAAgB,aAAa;AAAA,IACrD,gBAAe,gBAAmB,IAAI,OAAO,OAAO,iBAArC,mBACX,gBACA,OACA;AAAA,IACJ;AAAA,EAAA,CACD;AAEM,SAAA;AACT;AAEO,SAAS,WAAW;AACzB,QAAM,QAAS,uBAAuB,IAAc,EAAA;AAGpD,MAAI,CAAC,OAAO;AACV,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EAAA;AAEK,SAAA;AACT;AAEA,eAAsB,gBAAgB,OAAgB;AAC7C,SAAA,MAAO,WAAmB,QAAQ,KAAK;AAChD;"}